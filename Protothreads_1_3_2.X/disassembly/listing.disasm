Disassembly Listing for Protothreads_1_2
Generated From:
Z:/EEdocs/4760/PIC/Big_board_pt_1_2/Protothreads_1_2.X/dist/default/production/Protothreads_1_2.X.production.elf
Jul 19, 2017 12:21:08 PM

---  z:/eedocs/4760/pic/big_board_pt_1_2/tft_master.c  --------------------------------------------------
1:                   /* Code rewritten from Adafruit Arduino library for the TFT
2:                    *  by Syed Tahmid Mahbub
3:                    * The TFT itself is Adafruit product 1480
4:                    * Included below is the text header from the original Adafruit library
5:                    *  followed by the code
6:                    *
7:                    */
8:                   // 
9:                   /***************************************************
10:                    This is an Arduino Library for the Adafruit 2.2" SPI display.
11:                    This library works with the Adafruit 2.2" TFT Breakout w/SD card
12:                    ----> http://www.adafruit.com/products/1480
13:                  
14:                    Check out the links above for our tutorials and wiring diagrams
15:                    These displays use SPI to communicate, 4 or 5 pins are required to
16:                    interface (RST is optional)
17:                    Adafruit invests time and resources providing this open source code,
18:                    please support Adafruit and open-source hardware by purchasing
19:                    products from Adafruit!
20:                  
21:                    Written by Limor Fried/Ladyada for Adafruit Industries.
22:                    MIT license, all text above must be included in any redistribution
23:                   ****************************************************/
24:                  
25:                  #include "plib.h"
26:                  #include "tft_master.h"
27:                  #include <xc.h>
28:                  
29:                  inline void Mode16(void){  // configure SPI1 for 16-bit mode
30:                      SPI1CONSET = 0x400;
9D00293C  24030400   ADDIU V1, ZERO, 1024
9D002940  3C02BF80   LUI V0, -16512
9D002944  AC435808   SW V1, 22536(V0)
9D002948  03E00008   JR RA
9D00294C  00000000   NOP
9D0029FC  24030400   ADDIU V1, ZERO, 1024
9D002A00  AC435808   SW V1, 22536(V0)
9D002A04  03E00008   JR RA
9D002A08  00000000   NOP
9D002E9C  24030400   ADDIU V1, ZERO, 1024
9D002EA0  3C02BF80   LUI V0, -16512
9D002EA4  AC435808   SW V1, 22536(V0)
9D003030  24030400   ADDIU V1, ZERO, 1024
9D003034  3C02BF80   LUI V0, -16512
9D003038  AC435808   SW V1, 22536(V0)
9D003254  24030400   ADDIU V1, ZERO, 1024
9D003258  3C02BF80   LUI V0, -16512
9D00325C  AC435808   SW V1, 22536(V0)
9D003470  24030400   ADDIU V1, ZERO, 1024
9D003474  3C02BF80   LUI V0, -16512
9D003478  AC435808   SW V1, 22536(V0)
31:                  }
32:                  
33:                  inline void Mode8(void){  // configure SPI1 for 8-bit mode
34:                      SPI1CONCLR = 0x400;
9D002950  24030400   ADDIU V1, ZERO, 1024
9D002954  3C02BF80   LUI V0, -16512
9D002958  AC435804   SW V1, 22532(V0)
9D00295C  03E00008   JR RA
9D002960  00000000   NOP
9D0029C4  24030400   ADDIU V1, ZERO, 1024
9D0029C8  3C02BF80   LUI V0, -16512
9D0029CC  AC435804   SW V1, 22532(V0)
9D002FC8  24030400   ADDIU V1, ZERO, 1024
9D002FCC  3C02BF80   LUI V0, -16512
9D002FD0  AC435804   SW V1, 22532(V0)
9D0031DC  24030400   ADDIU V1, ZERO, 1024
9D0031E0  3C02BF80   LUI V0, -16512
9D0031E4  AC435804   SW V1, 22532(V0)
9D0033F8  24030400   ADDIU V1, ZERO, 1024
9D0033FC  3C02BF80   LUI V0, -16512
9D003400  AC435804   SW V1, 22532(V0)
35:                  }
36:                  
37:                  void tft_init_hw(void) {
38:                    _width = ILI9340_TFTWIDTH;
9D002964  240200F0   ADDIU V0, ZERO, 240
9D002968  A7828070   SH V0, -32656(GP)
39:                    _height = ILI9340_TFTHEIGHT;
9D00296C  24020140   ADDIU V0, ZERO, 320
9D002970  A7828078   SH V0, -32648(GP)
40:                    RPB11R = 3;              //SDO pin for SPI - goes to MOSI on TFT
9D002974  24030003   ADDIU V1, ZERO, 3
9D002978  3C02BF81   LUI V0, -16511
9D00297C  AC43FB58   SW V1, -1192(V0)
9D002980  03E00008   JR RA
9D002984  00000000   NOP
41:                    //RPA1R = 3; // SDO pin for SPI - goes to MOSI on TFT
42:                    //PPSOutput(2, RPA1, SDO1);
43:                    //SDI1R = 0; // RA1       // I won't be reading from TFT
44:                  }
45:                  
46:                  void tft_spiwrite(unsigned char c){ // Transfer to SPI
9D002988  308400FF   ANDI A0, A0, 255
47:                      while (TxBufFullSPI1());
9D00298C  3C03BF80   LUI V1, -16512
9D002990  8C625810   LW V0, 22544(V1)
9D002994  30420008   ANDI V0, V0, 8
9D002998  1040FFFD   BEQ V0, ZERO, 0x9D002990
9D00299C  3C02BF80   LUI V0, -16512
48:                      WriteSPI1(c);
9D0029A0  AC445820   SW A0, 22560(V0)
49:                      while (SPI1STATbits.SPIBUSY); // wait for it to end of transaction
9D0029A4  3C03BF80   LUI V1, -16512
9D0029A8  8C625810   LW V0, 22544(V1)
9D0029AC  30420800   ANDI V0, V0, 2048
9D0029B0  1440FFFD   BNE V0, ZERO, 0x9D0029A8
9D0029B4  00000000   NOP
50:                  }
9D0029B8  03E00008   JR RA
9D0029BC  00000000   NOP
51:                  
52:                  void tft_spiwrite8(unsigned char c) {   // Transfer one byte c to SPI
9D0029C0  308400FF   ANDI A0, A0, 255
53:                   /* The default mode for me is to transfer 16-bits at once
54:                    * However, it is necessary sometimes to transfer only 8-bits at a time
55:                    * But this is required less often than 16-bits at once
56:                    * So, the default mode is 16-bit mode and is switched to 8-bit mode when
57:                    *     required, and then switched back at the end of the function
58:                    */
59:                      Mode8(); // switch to 8-bit mode
60:                      while (TxBufFullSPI1());
9D0029D0  3C03BF80   LUI V1, -16512
9D0029D4  8C625810   LW V0, 22544(V1)
9D0029D8  30420008   ANDI V0, V0, 8
9D0029DC  1040FFFD   BEQ V0, ZERO, 0x9D0029D4
9D0029E0  3C02BF80   LUI V0, -16512
61:                      WriteSPI1(c);
9D0029E4  AC445820   SW A0, 22560(V0)
62:                      while (SPI1STATbits.SPIBUSY); // wait for it to end of transaction
9D0029E8  3C03BF80   LUI V1, -16512
9D0029EC  8C625810   LW V0, 22544(V1)
9D0029F0  30420800   ANDI V0, V0, 2048
9D0029F4  1440FFFD   BNE V0, ZERO, 0x9D0029EC
9D0029F8  3C02BF80   LUI V0, -16512
63:                      Mode16(); // switch back to 16-bit mode
64:                  }
65:                  
66:                  void tft_spiwrite16(unsigned short c){  // Transfer two bytes "c" to SPI
9D002A0C  3084FFFF   ANDI A0, A0, -1
67:                      while (TxBufFullSPI1());
9D002A10  3C03BF80   LUI V1, -16512
9D002A14  8C625810   LW V0, 22544(V1)
9D002A18  30420008   ANDI V0, V0, 8
9D002A1C  1040FFFD   BEQ V0, ZERO, 0x9D002A14
9D002A20  3C02BF80   LUI V0, -16512
68:                      WriteSPI1(c);
9D002A24  AC445820   SW A0, 22560(V0)
69:                      while (SPI1STATbits.SPIBUSY); // wait for it to end of transaction
9D002A28  3C03BF80   LUI V1, -16512
9D002A2C  8C625810   LW V0, 22544(V1)
9D002A30  30420800   ANDI V0, V0, 2048
9D002A34  1440FFFD   BNE V0, ZERO, 0x9D002A2C
9D002A38  00000000   NOP
70:                  }
9D002A3C  03E00008   JR RA
9D002A40  00000000   NOP
71:                  
72:                  
73:                  void tft_writecommand(unsigned char c) {
9D002A44  27BDFFE8   ADDIU SP, SP, -24
9D002A48  AFBF0014   SW RA, 20(SP)
9D002A4C  AFB00010   SW S0, 16(SP)
74:                      _dc_low();
9D002A50  3C02BF88   LUI V0, -16504
9D002A54  24030001   ADDIU V1, ZERO, 1
9D002A58  AC436134   SW V1, 24884(V0)
75:                      _cs_low();
9D002A5C  24100002   ADDIU S0, ZERO, 2
9D002A60  AC506134   SW S0, 24884(V0)
76:                  
77:                      tft_spiwrite8(c);
9D002A64  0F400A70   JAL tft_spiwrite8
9D002A68  308400FF   ANDI A0, A0, 255
78:                  
79:                      _cs_high();
9D002A6C  3C02BF88   LUI V0, -16504
9D002A70  AC506138   SW S0, 24888(V0)
80:                  
81:                  }
9D002A74  8FBF0014   LW RA, 20(SP)
9D002A78  8FB00010   LW S0, 16(SP)
9D002A7C  03E00008   JR RA
9D002A80  27BD0018   ADDIU SP, SP, 24
82:                  
83:                  void tft_writecommand16(unsigned short c) {
9D002A84  27BDFFE8   ADDIU SP, SP, -24
9D002A88  AFBF0014   SW RA, 20(SP)
9D002A8C  AFB00010   SW S0, 16(SP)
84:                      _dc_low();
9D002A90  3C02BF88   LUI V0, -16504
9D002A94  24030001   ADDIU V1, ZERO, 1
9D002A98  AC436134   SW V1, 24884(V0)
85:                      _cs_low();
9D002A9C  24100002   ADDIU S0, ZERO, 2
9D002AA0  AC506134   SW S0, 24884(V0)
86:                  
87:                      tft_spiwrite16(c);
9D002AA4  0F400A83   JAL tft_spiwrite16
9D002AA8  3084FFFF   ANDI A0, A0, -1
88:                  
89:                      _cs_high();
9D002AAC  3C02BF88   LUI V0, -16504
9D002AB0  AC506138   SW S0, 24888(V0)
90:                  
91:                  }
9D002AB4  8FBF0014   LW RA, 20(SP)
9D002AB8  8FB00010   LW S0, 16(SP)
9D002ABC  03E00008   JR RA
9D002AC0  27BD0018   ADDIU SP, SP, 24
92:                  
93:                  
94:                  void tft_writedata(unsigned char c) {
9D002AC4  27BDFFE0   ADDIU SP, SP, -32
9D002AC8  AFBF001C   SW RA, 28(SP)
9D002ACC  AFB10018   SW S1, 24(SP)
9D002AD0  AFB00014   SW S0, 20(SP)
95:                      _dc_high();
9D002AD4  3C10BF88   LUI S0, -16504
9D002AD8  24020001   ADDIU V0, ZERO, 1
9D002ADC  AE026138   SW V0, 24888(S0)
96:                      _cs_low();
9D002AE0  24110002   ADDIU S1, ZERO, 2
9D002AE4  3C02BF88   LUI V0, -16504
9D002AE8  AC516134   SW S1, 24884(V0)
97:                  
98:                      tft_spiwrite8(c);
9D002AEC  0F400A70   JAL tft_spiwrite8
9D002AF0  308400FF   ANDI A0, A0, 255
99:                  
100:                     _cs_high();
9D002AF4  AE116138   SW S1, 24888(S0)
101:                 
102:                 }
9D002AF8  8FBF001C   LW RA, 28(SP)
9D002AFC  8FB10018   LW S1, 24(SP)
9D002B00  8FB00014   LW S0, 20(SP)
9D002B04  03E00008   JR RA
9D002B08  27BD0020   ADDIU SP, SP, 32
103:                 
104:                 void tft_writedata16(unsigned short c) {
9D002B0C  27BDFFE0   ADDIU SP, SP, -32
9D002B10  AFBF001C   SW RA, 28(SP)
9D002B14  AFB10018   SW S1, 24(SP)
9D002B18  AFB00014   SW S0, 20(SP)
105:                     _dc_high();
9D002B1C  3C10BF88   LUI S0, -16504
9D002B20  24020001   ADDIU V0, ZERO, 1
9D002B24  AE026138   SW V0, 24888(S0)
106:                     _cs_low();
9D002B28  24110002   ADDIU S1, ZERO, 2
9D002B2C  3C02BF88   LUI V0, -16504
9D002B30  AC516134   SW S1, 24884(V0)
107:                 
108:                     tft_spiwrite16(c);
9D002B34  0F400A83   JAL tft_spiwrite16
9D002B38  3084FFFF   ANDI A0, A0, -1
109:                 
110:                     _cs_high();
9D002B3C  AE116138   SW S1, 24888(S0)
111:                 
112:                 }
9D002B40  8FBF001C   LW RA, 28(SP)
9D002B44  8FB10018   LW S1, 24(SP)
9D002B48  8FB00014   LW S0, 20(SP)
9D002B4C  03E00008   JR RA
9D002B50  27BD0020   ADDIU SP, SP, 32
113:                 
114:                 // Rather than a bazillion writecommand() and writedata() calls, screen
115:                 // initialization commands and arguments are organized in these tables
116:                 // stored in PROGMEM.  The table may look bulky, but that's mostly the
117:                 // formatting -- storage-wise this is hundreds of bytes more compact
118:                 // than the equivalent code.  Companion function follows.
119:                 #define DELAY 0x80
120:                 
121:                 void tft_begin(void) {
9D002B54  27BDFFE0   ADDIU SP, SP, -32
9D002B58  AFBF001C   SW RA, 28(SP)
9D002B5C  AFB20018   SW S2, 24(SP)
9D002B60  AFB10014   SW S1, 20(SP)
9D002B64  AFB00010   SW S0, 16(SP)
122:                 
123:                   TRIS_rst = 0;
9D002B68  3C02BF88   LUI V0, -16504
9D002B6C  94436110   LHU V1, 24848(V0)
9D002B70  7C031084   INS V1, ZERO, 2, 1
9D002B74  A4436110   SH V1, 24848(V0)
124:                   _rst_low();
9D002B78  3C12BF88   LUI S2, -16504
9D002B7C  24100004   ADDIU S0, ZERO, 4
9D002B80  AE506134   SW S0, 24884(S2)
125:                   TRIS_dc = 0;
9D002B84  94436110   LHU V1, 24848(V0)
9D002B88  7C030004   INS V1, ZERO, 0, 1
9D002B8C  A4436110   SH V1, 24848(V0)
126:                   TRIS_cs = 0;
9D002B90  94436110   LHU V1, 24848(V0)
9D002B94  7C030844   INS V1, ZERO, 1, 1
9D002B98  A4436110   SH V1, 24848(V0)
127:                 
128:                   _dc_low();
9D002B9C  24020001   ADDIU V0, ZERO, 1
9D002BA0  AE426134   SW V0, 24884(S2)
129:                   _cs_high();
9D002BA4  3C11BF88   LUI S1, -16504
9D002BA8  24020002   ADDIU V0, ZERO, 2
9D002BAC  AE226138   SW V0, 24888(S1)
130:                 
131:                     SpiChnOpen(1, SPI_OPEN_MSTEN | SPI_OPEN_MODE8 | SPI_OPEN_ON |
9D002BB0  24040001   ADDIU A0, ZERO, 1
9D002BB4  34058130   ORI A1, ZERO, -32464
9D002BB8  0F401B20   JAL SpiChnOpen
9D002BBC  24060002   ADDIU A2, ZERO, 2
132:                         SPI_OPEN_DISSDI | SPI_OPEN_CKE_REV , PBCLK/SPI_freq ); //PBCLK/SPI_freq);
133:                 
134:                     // Start with 8-bit mode for initialization - move to 16-bit mode once
135:                     // that's done
136:                 
137:                   _rst_high();
9D002BC0  AE306138   SW S0, 24888(S1)
138:                   delay_ms(5);
9D002BC4  0F400E4A   JAL delay_ms
9D002BC8  24040005   ADDIU A0, ZERO, 5
139:                   _rst_low();
9D002BCC  AE506134   SW S0, 24884(S2)
140:                   delay_ms(20);
9D002BD0  0F400E4A   JAL delay_ms
9D002BD4  24040014   ADDIU A0, ZERO, 20
141:                   _rst_high();
9D002BD8  AE306138   SW S0, 24888(S1)
142:                   delay_ms(150);
9D002BDC  0F400E4A   JAL delay_ms
9D002BE0  24040096   ADDIU A0, ZERO, 150
143:                 
144:                   tft_writecommand(0xEF);
9D002BE4  0F400A91   JAL tft_writecommand
9D002BE8  240400EF   ADDIU A0, ZERO, 239
145:                   tft_writedata(0x03);
9D002BEC  0F400AB1   JAL tft_writedata
9D002BF0  24040003   ADDIU A0, ZERO, 3
146:                   tft_writedata(0x80);
9D002BF4  0F400AB1   JAL tft_writedata
9D002BF8  24040080   ADDIU A0, ZERO, 128
147:                   tft_writedata(0x02);
9D002BFC  0F400AB1   JAL tft_writedata
9D002C00  24040002   ADDIU A0, ZERO, 2
148:                 
149:                   tft_writecommand(0xCF);
9D002C04  0F400A91   JAL tft_writecommand
9D002C08  240400CF   ADDIU A0, ZERO, 207
150:                   tft_writedata(0x00);
9D002C0C  0F400AB1   JAL tft_writedata
9D002C10  00002021   ADDU A0, ZERO, ZERO
151:                   tft_writedata(0xC1);
9D002C14  0F400AB1   JAL tft_writedata
9D002C18  240400C1   ADDIU A0, ZERO, 193
152:                   tft_writedata(0x30);
9D002C1C  0F400AB1   JAL tft_writedata
9D002C20  24040030   ADDIU A0, ZERO, 48
153:                 
154:                   tft_writecommand(0xED);
9D002C24  0F400A91   JAL tft_writecommand
9D002C28  240400ED   ADDIU A0, ZERO, 237
155:                   tft_writedata(0x64);
9D002C2C  0F400AB1   JAL tft_writedata
9D002C30  24040064   ADDIU A0, ZERO, 100
156:                   tft_writedata(0x03);
9D002C34  0F400AB1   JAL tft_writedata
9D002C38  24040003   ADDIU A0, ZERO, 3
157:                   tft_writedata(0x12);
9D002C3C  0F400AB1   JAL tft_writedata
9D002C40  24040012   ADDIU A0, ZERO, 18
158:                   tft_writedata(0x81);
9D002C44  0F400AB1   JAL tft_writedata
9D002C48  24040081   ADDIU A0, ZERO, 129
159:                 
160:                   tft_writecommand(0xE8);
9D002C4C  0F400A91   JAL tft_writecommand
9D002C50  240400E8   ADDIU A0, ZERO, 232
161:                   tft_writedata(0x85);
9D002C54  0F400AB1   JAL tft_writedata
9D002C58  24040085   ADDIU A0, ZERO, 133
162:                   tft_writedata(0x00);
9D002C5C  0F400AB1   JAL tft_writedata
9D002C60  00002021   ADDU A0, ZERO, ZERO
163:                   tft_writedata(0x78);
9D002C64  0F400AB1   JAL tft_writedata
9D002C68  24040078   ADDIU A0, ZERO, 120
164:                 
165:                   tft_writecommand(0xCB);
9D002C6C  0F400A91   JAL tft_writecommand
9D002C70  240400CB   ADDIU A0, ZERO, 203
166:                   tft_writedata(0x39);
9D002C74  0F400AB1   JAL tft_writedata
9D002C78  24040039   ADDIU A0, ZERO, 57
167:                   tft_writedata(0x2C);
9D002C7C  0F400AB1   JAL tft_writedata
9D002C80  2404002C   ADDIU A0, ZERO, 44
168:                   tft_writedata(0x00);
9D002C84  0F400AB1   JAL tft_writedata
9D002C88  00002021   ADDU A0, ZERO, ZERO
169:                   tft_writedata(0x34);
9D002C8C  0F400AB1   JAL tft_writedata
9D002C90  24040034   ADDIU A0, ZERO, 52
170:                   tft_writedata(0x02);
9D002C94  0F400AB1   JAL tft_writedata
9D002C98  24040002   ADDIU A0, ZERO, 2
171:                 
172:                   tft_writecommand(0xF7);
9D002C9C  0F400A91   JAL tft_writecommand
9D002CA0  240400F7   ADDIU A0, ZERO, 247
173:                   tft_writedata(0x20);
9D002CA4  0F400AB1   JAL tft_writedata
9D002CA8  24040020   ADDIU A0, ZERO, 32
174:                 
175:                   tft_writecommand(0xEA);
9D002CAC  0F400A91   JAL tft_writecommand
9D002CB0  240400EA   ADDIU A0, ZERO, 234
176:                   tft_writedata(0x00);
9D002CB4  0F400AB1   JAL tft_writedata
9D002CB8  00002021   ADDU A0, ZERO, ZERO
177:                   tft_writedata(0x00);
9D002CBC  0F400AB1   JAL tft_writedata
9D002CC0  00002021   ADDU A0, ZERO, ZERO
178:                 
179:                   tft_writecommand(ILI9340_PWCTR1);    //Power control
9D002CC4  0F400A91   JAL tft_writecommand
9D002CC8  240400C0   ADDIU A0, ZERO, 192
180:                   tft_writedata(0x23);   //VRH[5:0]
9D002CCC  0F400AB1   JAL tft_writedata
9D002CD0  24040023   ADDIU A0, ZERO, 35
181:                 
182:                   tft_writecommand(ILI9340_PWCTR2);    //Power control
9D002CD4  0F400A91   JAL tft_writecommand
9D002CD8  240400C1   ADDIU A0, ZERO, 193
183:                   tft_writedata(0x10);   //SAP[2:0];BT[3:0]
9D002CDC  0F400AB1   JAL tft_writedata
9D002CE0  24040010   ADDIU A0, ZERO, 16
184:                 
185:                   tft_writecommand(ILI9340_VMCTR1);    //VCM control
9D002CE4  0F400A91   JAL tft_writecommand
9D002CE8  240400C5   ADDIU A0, ZERO, 197
186:                   tft_writedata(0x3e);
9D002CEC  0F400AB1   JAL tft_writedata
9D002CF0  2404003E   ADDIU A0, ZERO, 62
187:                   tft_writedata(0x28);
9D002CF4  0F400AB1   JAL tft_writedata
9D002CF8  24040028   ADDIU A0, ZERO, 40
188:                 
189:                   tft_writecommand(ILI9340_VMCTR2);    //VCM control2
9D002CFC  0F400A91   JAL tft_writecommand
9D002D00  240400C7   ADDIU A0, ZERO, 199
190:                   tft_writedata(0x86);
9D002D04  0F400AB1   JAL tft_writedata
9D002D08  24040086   ADDIU A0, ZERO, 134
191:                 
192:                   tft_writecommand(ILI9340_MADCTL);    // Memory Access Control
9D002D0C  0F400A91   JAL tft_writecommand
9D002D10  24040036   ADDIU A0, ZERO, 54
193:                   tft_writedata(ILI9340_MADCTL_MX | ILI9340_MADCTL_BGR);
9D002D14  0F400AB1   JAL tft_writedata
9D002D18  24040048   ADDIU A0, ZERO, 72
194:                 
195:                   tft_writecommand(ILI9340_PIXFMT);
9D002D1C  0F400A91   JAL tft_writecommand
9D002D20  2404003A   ADDIU A0, ZERO, 58
196:                   tft_writedata(0x55);
9D002D24  0F400AB1   JAL tft_writedata
9D002D28  24040055   ADDIU A0, ZERO, 85
197:                 
198:                   tft_writecommand(ILI9340_FRMCTR1);
9D002D2C  0F400A91   JAL tft_writecommand
9D002D30  240400B1   ADDIU A0, ZERO, 177
199:                   tft_writedata(0x00);
9D002D34  0F400AB1   JAL tft_writedata
9D002D38  00002021   ADDU A0, ZERO, ZERO
200:                   tft_writedata(0x18);
9D002D3C  0F400AB1   JAL tft_writedata
9D002D40  24040018   ADDIU A0, ZERO, 24
201:                 
202:                   tft_writecommand(ILI9340_DFUNCTR);    // Display Function Control
9D002D44  0F400A91   JAL tft_writecommand
9D002D48  240400B6   ADDIU A0, ZERO, 182
203:                   tft_writedata(0x08);
9D002D4C  0F400AB1   JAL tft_writedata
9D002D50  24040008   ADDIU A0, ZERO, 8
204:                   tft_writedata(0x82);
9D002D54  0F400AB1   JAL tft_writedata
9D002D58  24040082   ADDIU A0, ZERO, 130
205:                   tft_writedata(0x27);
9D002D5C  0F400AB1   JAL tft_writedata
9D002D60  24040027   ADDIU A0, ZERO, 39
206:                 
207:                   tft_writecommand(0xF2);    // 3Gamma Function Disable
9D002D64  0F400A91   JAL tft_writecommand
9D002D68  240400F2   ADDIU A0, ZERO, 242
208:                   tft_writedata(0x00);
9D002D6C  0F400AB1   JAL tft_writedata
9D002D70  00002021   ADDU A0, ZERO, ZERO
209:                 
210:                   tft_writecommand(ILI9340_GAMMASET);    //Gamma curve selected
9D002D74  0F400A91   JAL tft_writecommand
9D002D78  24040026   ADDIU A0, ZERO, 38
211:                   tft_writedata(0x01);
9D002D7C  0F400AB1   JAL tft_writedata
9D002D80  24040001   ADDIU A0, ZERO, 1
212:                 
213:                   tft_writecommand(ILI9340_GMCTRP1);    //Set Gamma
9D002D84  0F400A91   JAL tft_writecommand
9D002D88  240400E0   ADDIU A0, ZERO, 224
214:                   tft_writedata(0x0F);
9D002D8C  0F400AB1   JAL tft_writedata
9D002D90  2404000F   ADDIU A0, ZERO, 15
215:                   tft_writedata(0x31);
9D002D94  0F400AB1   JAL tft_writedata
9D002D98  24040031   ADDIU A0, ZERO, 49
216:                   tft_writedata(0x2B);
9D002D9C  0F400AB1   JAL tft_writedata
9D002DA0  2404002B   ADDIU A0, ZERO, 43
217:                   tft_writedata(0x0C);
9D002DA4  0F400AB1   JAL tft_writedata
9D002DA8  2404000C   ADDIU A0, ZERO, 12
218:                   tft_writedata(0x0E);
9D002DAC  0F400AB1   JAL tft_writedata
9D002DB0  2404000E   ADDIU A0, ZERO, 14
219:                   tft_writedata(0x08);
9D002DB4  0F400AB1   JAL tft_writedata
9D002DB8  24040008   ADDIU A0, ZERO, 8
220:                   tft_writedata(0x4E);
9D002DBC  0F400AB1   JAL tft_writedata
9D002DC0  2404004E   ADDIU A0, ZERO, 78
221:                   tft_writedata(0xF1);
9D002DC4  0F400AB1   JAL tft_writedata
9D002DC8  240400F1   ADDIU A0, ZERO, 241
222:                   tft_writedata(0x37);
9D002DCC  0F400AB1   JAL tft_writedata
9D002DD0  24040037   ADDIU A0, ZERO, 55
223:                   tft_writedata(0x07);
9D002DD4  0F400AB1   JAL tft_writedata
9D002DD8  24040007   ADDIU A0, ZERO, 7
224:                   tft_writedata(0x10);
9D002DDC  0F400AB1   JAL tft_writedata
9D002DE0  24040010   ADDIU A0, ZERO, 16
225:                   tft_writedata(0x03);
9D002DE4  0F400AB1   JAL tft_writedata
9D002DE8  24040003   ADDIU A0, ZERO, 3
226:                   tft_writedata(0x0E);
9D002DEC  0F400AB1   JAL tft_writedata
9D002DF0  2404000E   ADDIU A0, ZERO, 14
227:                   tft_writedata(0x09);
9D002DF4  0F400AB1   JAL tft_writedata
9D002DF8  24040009   ADDIU A0, ZERO, 9
228:                   tft_writedata(0x00);
9D002DFC  0F400AB1   JAL tft_writedata
9D002E00  00002021   ADDU A0, ZERO, ZERO
229:                 
230:                   tft_writecommand(ILI9340_GMCTRN1);    //Set Gamma
9D002E04  0F400A91   JAL tft_writecommand
9D002E08  240400E1   ADDIU A0, ZERO, 225
231:                   tft_writedata(0x00);
9D002E0C  0F400AB1   JAL tft_writedata
9D002E10  00002021   ADDU A0, ZERO, ZERO
232:                   tft_writedata(0x0E);
9D002E14  0F400AB1   JAL tft_writedata
9D002E18  2404000E   ADDIU A0, ZERO, 14
233:                   tft_writedata(0x14);
9D002E1C  0F400AB1   JAL tft_writedata
9D002E20  24040014   ADDIU A0, ZERO, 20
234:                   tft_writedata(0x03);
9D002E24  0F400AB1   JAL tft_writedata
9D002E28  24040003   ADDIU A0, ZERO, 3
235:                   tft_writedata(0x11);
9D002E2C  0F400AB1   JAL tft_writedata
9D002E30  24040011   ADDIU A0, ZERO, 17
236:                   tft_writedata(0x07);
9D002E34  0F400AB1   JAL tft_writedata
9D002E38  24040007   ADDIU A0, ZERO, 7
237:                   tft_writedata(0x31);
9D002E3C  0F400AB1   JAL tft_writedata
9D002E40  24040031   ADDIU A0, ZERO, 49
238:                   tft_writedata(0xC1);
9D002E44  0F400AB1   JAL tft_writedata
9D002E48  240400C1   ADDIU A0, ZERO, 193
239:                   tft_writedata(0x48);
9D002E4C  0F400AB1   JAL tft_writedata
9D002E50  24040048   ADDIU A0, ZERO, 72
240:                   tft_writedata(0x08);
9D002E54  0F400AB1   JAL tft_writedata
9D002E58  24040008   ADDIU A0, ZERO, 8
241:                   tft_writedata(0x0F);
9D002E5C  0F400AB1   JAL tft_writedata
9D002E60  2404000F   ADDIU A0, ZERO, 15
242:                   tft_writedata(0x0C);
9D002E64  0F400AB1   JAL tft_writedata
9D002E68  2404000C   ADDIU A0, ZERO, 12
243:                   tft_writedata(0x31);
9D002E6C  0F400AB1   JAL tft_writedata
9D002E70  24040031   ADDIU A0, ZERO, 49
244:                   tft_writedata(0x36);
9D002E74  0F400AB1   JAL tft_writedata
9D002E78  24040036   ADDIU A0, ZERO, 54
245:                   tft_writedata(0x0F);
9D002E7C  0F400AB1   JAL tft_writedata
9D002E80  2404000F   ADDIU A0, ZERO, 15
246:                 
247:                   tft_writecommand(ILI9340_SLPOUT);    //Exit Sleep
9D002E84  0F400A91   JAL tft_writecommand
9D002E88  24040011   ADDIU A0, ZERO, 17
248:                   delay_ms(120);
9D002E8C  0F400E4A   JAL delay_ms
9D002E90  24040078   ADDIU A0, ZERO, 120
249:                   tft_writecommand(ILI9340_DISPON);    //Display on
9D002E94  0F400A91   JAL tft_writecommand
9D002E98  24040029   ADDIU A0, ZERO, 41
250:                 
251:                   // Now move to 16-bit mode to speed things up for display
252:                   Mode16();
253:                 }
9D002EA8  8FBF001C   LW RA, 28(SP)
9D002EAC  8FB20018   LW S2, 24(SP)
9D002EB0  8FB10014   LW S1, 20(SP)
9D002EB4  8FB00010   LW S0, 16(SP)
9D002EB8  03E00008   JR RA
9D002EBC  27BD0020   ADDIU SP, SP, 32
254:                 
255:                 
256:                 void tft_setAddrWindow(unsigned short x0, unsigned short y0, unsigned short x1, unsigned short y1) {
9D002EC0  27BDFFD8   ADDIU SP, SP, -40
9D002EC4  AFBF0024   SW RA, 36(SP)
9D002EC8  AFB30020   SW S3, 32(SP)
9D002ECC  AFB2001C   SW S2, 28(SP)
9D002ED0  AFB10018   SW S1, 24(SP)
9D002ED4  AFB00014   SW S0, 20(SP)
9D002ED8  3093FFFF   ANDI S3, A0, -1
9D002EDC  30B1FFFF   ANDI S1, A1, -1
9D002EE0  30D2FFFF   ANDI S2, A2, -1
9D002EE4  30F0FFFF   ANDI S0, A3, -1
257:                 
258:                   tft_writecommand(ILI9340_CASET); // Column addr set
9D002EE8  0F400A91   JAL tft_writecommand
9D002EEC  2404002A   ADDIU A0, ZERO, 42
259:                   tft_writedata16(x0);
9D002EF0  0F400AC3   JAL tft_writedata16
9D002EF4  02602021   ADDU A0, S3, ZERO
260:                   tft_writedata16(x1);
9D002EF8  0F400AC3   JAL tft_writedata16
9D002EFC  02402021   ADDU A0, S2, ZERO
261:                 
262:                   tft_writecommand(ILI9340_PASET); // Row addr set
9D002F00  0F400A91   JAL tft_writecommand
9D002F04  2404002B   ADDIU A0, ZERO, 43
263:                   tft_writedata16(y0);
9D002F08  0F400AC3   JAL tft_writedata16
9D002F0C  02202021   ADDU A0, S1, ZERO
264:                   tft_writedata16(y1);
9D002F10  0F400AC3   JAL tft_writedata16
9D002F14  02002021   ADDU A0, S0, ZERO
265:                 
266:                   tft_writecommand(ILI9340_RAMWR); // write to RAM
9D002F18  0F400A91   JAL tft_writecommand
9D002F1C  2404002C   ADDIU A0, ZERO, 44
267:                 }
9D002F20  8FBF0024   LW RA, 36(SP)
9D002F24  8FB30020   LW S3, 32(SP)
9D002F28  8FB2001C   LW S2, 28(SP)
9D002F2C  8FB10018   LW S1, 24(SP)
9D002F30  8FB00014   LW S0, 20(SP)
9D002F34  03E00008   JR RA
9D002F38  27BD0028   ADDIU SP, SP, 40
268:                 
269:                 
270:                 void tft_pushColor(unsigned short color) {
9D002F3C  27BDFFE0   ADDIU SP, SP, -32
9D002F40  AFBF001C   SW RA, 28(SP)
9D002F44  AFB10018   SW S1, 24(SP)
9D002F48  AFB00014   SW S0, 20(SP)
271:                   _dc_high();
9D002F4C  3C10BF88   LUI S0, -16504
9D002F50  24020001   ADDIU V0, ZERO, 1
9D002F54  AE026138   SW V0, 24888(S0)
272:                   _cs_low();
9D002F58  24110002   ADDIU S1, ZERO, 2
9D002F5C  3C02BF88   LUI V0, -16504
9D002F60  AC516134   SW S1, 24884(V0)
273:                 
274:                   tft_spiwrite16(color);
9D002F64  0F400A83   JAL tft_spiwrite16
9D002F68  3084FFFF   ANDI A0, A0, -1
275:                 
276:                   _cs_high();
9D002F6C  AE116138   SW S1, 24888(S0)
277:                 }
9D002F70  8FBF001C   LW RA, 28(SP)
9D002F74  8FB10018   LW S1, 24(SP)
9D002F78  8FB00014   LW S0, 20(SP)
9D002F7C  03E00008   JR RA
9D002F80  27BD0020   ADDIU SP, SP, 32
278:                 #define NOP asm("nop");
279:                 #define wait16 NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;
280:                 #define wait8 NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;
281:                 #define wait12 NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;
282:                 #define wait15 NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;NOP;
283:                 
284:                 void tft_drawPixel(short x, short y, unsigned short color) {
9D002F84  7C042620   SEH A0, A0
9D002F88  7C052E20   SEH A1, A1
285:                 /* Draw a pixel at location (x,y) with given color
286:                  * Parameters:
287:                  *      x:  x-coordinate of pixel to draw; top left of screen is x=0
288:                  *              and x increases to the right
289:                  *      y:  y-coordinate of pixel to draw; top left of screen is y=0
290:                  *              and y increases to the bottom
291:                  *      color:  16-bit color value
292:                  * Returns:     Nothing
293:                  */
294:                 
295:                   if((x < 0) ||(x >= _width) || (y < 0) || (y >= _height)) return;
9D002F8C  0480016E   BLTZ A0, 0x9D003548
9D002F90  30C6FFFF   ANDI A2, A2, -1
9D002F94  97828070   LHU V0, -32656(GP)
9D002F98  0082102A   SLT V0, A0, V0
9D002F9C  1040016A   BEQ V0, ZERO, 0x9D003548
9D002FA0  00000000   NOP
9D002FA4  04A00168   BLTZ A1, 0x9D003548
9D002FA8  97828078   LHU V0, -32648(GP)
9D002FAC  00A2102A   SLT V0, A1, V0
9D002FB0  10400165   BEQ V0, ZERO, 0x9D003548
9D002FB4  3C02BF88   LUI V0, -16504
296:                 /*
297:                   tft_setAddrWindow(x,y,x+1,y+1);
298:                 
299:                   _dc_high();
300:                   _cs_low();
301:                 
302:                   tft_spiwrite16(color);
303:                 
304:                   _cs_high();
305:                 }
306:                 */
307:                   //tft_writecommand(ILI9340_CASET); // Column addr set
308:                    _dc_low();
9D002FB8  24030001   ADDIU V1, ZERO, 1
9D002FBC  AC436134   SW V1, 24884(V0)
309:                     _cs_low();
9D002FC0  24030002   ADDIU V1, ZERO, 2
9D002FC4  AC436134   SW V1, 24884(V0)
310:                     //tft_spiwrite8(ILI9340_CASET);
311:                     Mode8(); // switch to 8-bit mode
312:                     while (TxBufFullSPI1());
9D002FD4  3C03BF80   LUI V1, -16512
9D002FD8  8C625810   LW V0, 22544(V1)
9D002FDC  30420008   ANDI V0, V0, 8
9D002FE0  1040FFFD   BEQ V0, ZERO, 0x9D002FD8
9D002FE4  3C02BF80   LUI V0, -16512
313:                     WriteSPI1(ILI9340_CASET);
9D002FE8  2403002A   ADDIU V1, ZERO, 42
9D002FEC  AC435820   SW V1, 22560(V0)
314:                     //while (SPI1STATbits.SPIBUSY); // wait for it to end of transaction
315:                     wait16;
9D002FF0  00000000   NOP
9D002FF4  00000000   NOP
9D002FF8  00000000   NOP
9D002FFC  00000000   NOP
9D003000  00000000   NOP
9D003004  00000000   NOP
9D003008  00000000   NOP
9D00300C  00000000   NOP
9D003010  00000000   NOP
9D003014  00000000   NOP
9D003018  00000000   NOP
9D00301C  00000000   NOP
9D003020  00000000   NOP
9D003024  00000000   NOP
9D003028  00000000   NOP
9D00302C  00000000   NOP
316:                     Mode16(); // switch back to 16-bit mode
317:                     _cs_high();
9D00303C  3C03BF88   LUI V1, -16504
9D003040  24020002   ADDIU V0, ZERO, 2
9D003044  AC626138   SW V0, 24888(V1)
318:                 
319:                   //tft_writedata16(x);
320:                    _dc_high();
9D003048  24070001   ADDIU A3, ZERO, 1
9D00304C  AC676138   SW A3, 24888(V1)
321:                     _cs_low();
9D003050  3C03BF88   LUI V1, -16504
9D003054  AC626134   SW V0, 24884(V1)
322:                     //tft_spiwrite16(c);
323:                    // while (TxBufFullSPI1());
324:                     WriteSPI1(x);
9D003058  3C02BF80   LUI V0, -16512
9D00305C  AC445820   SW A0, 22560(V0)
325:                     //while (SPI1STATbits.SPIBUSY);
326:                     wait16;wait16;wait8;
9D003060  00000000   NOP
9D003064  00000000   NOP
9D003068  00000000   NOP
9D00306C  00000000   NOP
9D003070  00000000   NOP
9D003074  00000000   NOP
9D003078  00000000   NOP
9D00307C  00000000   NOP
9D003080  00000000   NOP
9D003084  00000000   NOP
9D003088  00000000   NOP
9D00308C  00000000   NOP
9D003090  00000000   NOP
9D003094  00000000   NOP
9D003098  00000000   NOP
9D00309C  00000000   NOP
9D0030A0  00000000   NOP
9D0030A4  00000000   NOP
9D0030A8  00000000   NOP
9D0030AC  00000000   NOP
9D0030B0  00000000   NOP
9D0030B4  00000000   NOP
9D0030B8  00000000   NOP
9D0030BC  00000000   NOP
9D0030C0  00000000   NOP
9D0030C4  00000000   NOP
9D0030C8  00000000   NOP
9D0030CC  00000000   NOP
9D0030D0  00000000   NOP
9D0030D4  00000000   NOP
9D0030D8  00000000   NOP
9D0030DC  00000000   NOP
9D0030E0  00000000   NOP
9D0030E4  00000000   NOP
9D0030E8  00000000   NOP
9D0030EC  00000000   NOP
9D0030F0  00000000   NOP
9D0030F4  00000000   NOP
9D0030F8  00000000   NOP
9D0030FC  00000000   NOP
327:                     _cs_high();
9D003100  24020002   ADDIU V0, ZERO, 2
9D003104  3C03BF88   LUI V1, -16504
9D003108  AC626138   SW V0, 24888(V1)
328:                 
329:                     
330:                   //tft_writedata16(x+1);
331:                   // _dc_high();
332:                     _cs_low();
9D00310C  3C03BF88   LUI V1, -16504
9D003110  AC626134   SW V0, 24884(V1)
333:                     //tft_spiwrite16(c);
334:                     //while (TxBufFullSPI1());
335:                     WriteSPI1(x+1);
9D003114  24840001   ADDIU A0, A0, 1
9D003118  3C02BF80   LUI V0, -16512
9D00311C  AC445820   SW A0, 22560(V0)
336:                     //while (SPI1STATbits.SPIBUSY);
337:                     wait16;wait16;wait8;
9D003120  00000000   NOP
9D003124  00000000   NOP
9D003128  00000000   NOP
9D00312C  00000000   NOP
9D003130  00000000   NOP
9D003134  00000000   NOP
9D003138  00000000   NOP
9D00313C  00000000   NOP
9D003140  00000000   NOP
9D003144  00000000   NOP
9D003148  00000000   NOP
9D00314C  00000000   NOP
9D003150  00000000   NOP
9D003154  00000000   NOP
9D003158  00000000   NOP
9D00315C  00000000   NOP
9D003160  00000000   NOP
9D003164  00000000   NOP
9D003168  00000000   NOP
9D00316C  00000000   NOP
9D003170  00000000   NOP
9D003174  00000000   NOP
9D003178  00000000   NOP
9D00317C  00000000   NOP
9D003180  00000000   NOP
9D003184  00000000   NOP
9D003188  00000000   NOP
9D00318C  00000000   NOP
9D003190  00000000   NOP
9D003194  00000000   NOP
9D003198  00000000   NOP
9D00319C  00000000   NOP
9D0031A0  00000000   NOP
9D0031A4  00000000   NOP
9D0031A8  00000000   NOP
9D0031AC  00000000   NOP
9D0031B0  00000000   NOP
9D0031B4  00000000   NOP
9D0031B8  00000000   NOP
9D0031BC  00000000   NOP
338:                     _cs_high();
9D0031C0  24030002   ADDIU V1, ZERO, 2
9D0031C4  3C02BF88   LUI V0, -16504
9D0031C8  AC436138   SW V1, 24888(V0)
339:                 
340:                   //t_writecommand(ILI9340_PASET); // Row addr set
341:                   _dc_low();
9D0031CC  3C02BF88   LUI V0, -16504
9D0031D0  24040001   ADDIU A0, ZERO, 1
9D0031D4  AC446134   SW A0, 24884(V0)
342:                     _cs_low();
9D0031D8  AC436134   SW V1, 24884(V0)
343:                     //tft_spiwrite8(ILI9340_PASET);
344:                     Mode8(); // switch to 8-bit mode
345:                     //while (TxBufFullSPI1());
346:                     WriteSPI1(ILI9340_PASET);
9D0031E8  2403002B   ADDIU V1, ZERO, 43
9D0031EC  3C02BF80   LUI V0, -16512
9D0031F0  AC435820   SW V1, 22560(V0)
347:                     //while (SPI1STATbits.SPIBUSY); // wait for it to end of transaction
348:                     wait16;wait8;
9D0031F4  00000000   NOP
9D0031F8  00000000   NOP
9D0031FC  00000000   NOP
9D003200  00000000   NOP
9D003204  00000000   NOP
9D003208  00000000   NOP
9D00320C  00000000   NOP
9D003210  00000000   NOP
9D003214  00000000   NOP
9D003218  00000000   NOP
9D00321C  00000000   NOP
9D003220  00000000   NOP
9D003224  00000000   NOP
9D003228  00000000   NOP
9D00322C  00000000   NOP
9D003230  00000000   NOP
9D003234  00000000   NOP
9D003238  00000000   NOP
9D00323C  00000000   NOP
9D003240  00000000   NOP
9D003244  00000000   NOP
9D003248  00000000   NOP
9D00324C  00000000   NOP
9D003250  00000000   NOP
349:                     Mode16(); // switch back to 16-bit mode
350:                     _cs_high();
9D003260  3C03BF88   LUI V1, -16504
9D003264  24020002   ADDIU V0, ZERO, 2
9D003268  AC626138   SW V0, 24888(V1)
351:                 
352:                   //tft_writedata16(y);
353:                    _dc_high();
9D00326C  AC646138   SW A0, 24888(V1)
354:                     _cs_low();
9D003270  3C03BF88   LUI V1, -16504
9D003274  AC626134   SW V0, 24884(V1)
355:                     //tft_spiwrite16(c);
356:                    // while (TxBufFullSPI1());
357:                     WriteSPI1(y);
9D003278  3C02BF80   LUI V0, -16512
9D00327C  AC455820   SW A1, 22560(V0)
358:                    // while (SPI1STATbits.SPIBUSY);
359:                     wait16;wait16;wait8;
9D003280  00000000   NOP
9D003284  00000000   NOP
9D003288  00000000   NOP
9D00328C  00000000   NOP
9D003290  00000000   NOP
9D003294  00000000   NOP
9D003298  00000000   NOP
9D00329C  00000000   NOP
9D0032A0  00000000   NOP
9D0032A4  00000000   NOP
9D0032A8  00000000   NOP
9D0032AC  00000000   NOP
9D0032B0  00000000   NOP
9D0032B4  00000000   NOP
9D0032B8  00000000   NOP
9D0032BC  00000000   NOP
9D0032C0  00000000   NOP
9D0032C4  00000000   NOP
9D0032C8  00000000   NOP
9D0032CC  00000000   NOP
9D0032D0  00000000   NOP
9D0032D4  00000000   NOP
9D0032D8  00000000   NOP
9D0032DC  00000000   NOP
9D0032E0  00000000   NOP
9D0032E4  00000000   NOP
9D0032E8  00000000   NOP
9D0032EC  00000000   NOP
9D0032F0  00000000   NOP
9D0032F4  00000000   NOP
9D0032F8  00000000   NOP
9D0032FC  00000000   NOP
9D003300  00000000   NOP
9D003304  00000000   NOP
9D003308  00000000   NOP
9D00330C  00000000   NOP
9D003310  00000000   NOP
9D003314  00000000   NOP
9D003318  00000000   NOP
9D00331C  00000000   NOP
360:                     _cs_high();
9D003320  24020002   ADDIU V0, ZERO, 2
9D003324  3C03BF88   LUI V1, -16504
9D003328  AC626138   SW V0, 24888(V1)
361:                 
362:                     
363:                   //tft_writedata16(y+1);
364:                    //_dc_high();
365:                     _cs_low();
9D00332C  3C03BF88   LUI V1, -16504
9D003330  AC626134   SW V0, 24884(V1)
366:                     //tft_spiwrite16(c);
367:                     //while (TxBufFullSPI1());
368:                     WriteSPI1(y+1);
9D003334  24A50001   ADDIU A1, A1, 1
9D003338  3C02BF80   LUI V0, -16512
9D00333C  AC455820   SW A1, 22560(V0)
369:                     //while (SPI1STATbits.SPIBUSY);
370:                     wait16;wait16;wait8;
9D003340  00000000   NOP
9D003344  00000000   NOP
9D003348  00000000   NOP
9D00334C  00000000   NOP
9D003350  00000000   NOP
9D003354  00000000   NOP
9D003358  00000000   NOP
9D00335C  00000000   NOP
9D003360  00000000   NOP
9D003364  00000000   NOP
9D003368  00000000   NOP
9D00336C  00000000   NOP
9D003370  00000000   NOP
9D003374  00000000   NOP
9D003378  00000000   NOP
9D00337C  00000000   NOP
9D003380  00000000   NOP
9D003384  00000000   NOP
9D003388  00000000   NOP
9D00338C  00000000   NOP
9D003390  00000000   NOP
9D003394  00000000   NOP
9D003398  00000000   NOP
9D00339C  00000000   NOP
9D0033A0  00000000   NOP
9D0033A4  00000000   NOP
9D0033A8  00000000   NOP
9D0033AC  00000000   NOP
9D0033B0  00000000   NOP
9D0033B4  00000000   NOP
9D0033B8  00000000   NOP
9D0033BC  00000000   NOP
9D0033C0  00000000   NOP
9D0033C4  00000000   NOP
9D0033C8  00000000   NOP
9D0033CC  00000000   NOP
9D0033D0  00000000   NOP
9D0033D4  00000000   NOP
9D0033D8  00000000   NOP
9D0033DC  00000000   NOP
371:                     _cs_high();
9D0033E0  24030002   ADDIU V1, ZERO, 2
9D0033E4  3C02BF88   LUI V0, -16504
9D0033E8  AC436138   SW V1, 24888(V0)
372:                 
373:                   //tft_writecommand(ILI9340_RAMWR); // write to RAM
374:                     _dc_low();
9D0033EC  3C02BF88   LUI V0, -16504
9D0033F0  AC446134   SW A0, 24884(V0)
375:                     _cs_low();
9D0033F4  AC436134   SW V1, 24884(V0)
376:                     //tft_spiwrite8(ILI9340_RAMWR);
377:                     Mode8(); // switch to 8-bit mode
378:                    // while (TxBufFullSPI1());
379:                     WriteSPI1(ILI9340_RAMWR);
9D003404  2403002C   ADDIU V1, ZERO, 44
9D003408  3C02BF80   LUI V0, -16512
9D00340C  AC435820   SW V1, 22560(V0)
380:                    // while (SPI1STATbits.SPIBUSY); // wait for it to end of transaction
381:                     wait16;wait8;
9D003410  00000000   NOP
9D003414  00000000   NOP
9D003418  00000000   NOP
9D00341C  00000000   NOP
9D003420  00000000   NOP
9D003424  00000000   NOP
9D003428  00000000   NOP
9D00342C  00000000   NOP
9D003430  00000000   NOP
9D003434  00000000   NOP
9D003438  00000000   NOP
9D00343C  00000000   NOP
9D003440  00000000   NOP
9D003444  00000000   NOP
9D003448  00000000   NOP
9D00344C  00000000   NOP
9D003450  00000000   NOP
9D003454  00000000   NOP
9D003458  00000000   NOP
9D00345C  00000000   NOP
9D003460  00000000   NOP
9D003464  00000000   NOP
9D003468  00000000   NOP
9D00346C  00000000   NOP
382:                     Mode16(); // switch back to 16-bit mode
383:                     _cs_high();
9D00347C  3C03BF88   LUI V1, -16504
9D003480  24020002   ADDIU V0, ZERO, 2
9D003484  AC626138   SW V0, 24888(V1)
384:                 
385:                   _dc_high();
9D003488  AC646138   SW A0, 24888(V1)
386:                   _cs_low();
9D00348C  3C03BF88   LUI V1, -16504
9D003490  AC626134   SW V0, 24884(V1)
387:                   //tft_spiwrite16(color);
388:                  // while (TxBufFullSPI1());
389:                     WriteSPI1(color);
9D003494  3C02BF80   LUI V0, -16512
9D003498  AC465820   SW A2, 22560(V0)
390:                     //while (SPI1STATbits.SPIBUSY);
391:                     wait16;wait16;wait8;
9D00349C  00000000   NOP
9D0034A0  00000000   NOP
9D0034A4  00000000   NOP
9D0034A8  00000000   NOP
9D0034AC  00000000   NOP
9D0034B0  00000000   NOP
9D0034B4  00000000   NOP
9D0034B8  00000000   NOP
9D0034BC  00000000   NOP
9D0034C0  00000000   NOP
9D0034C4  00000000   NOP
9D0034C8  00000000   NOP
9D0034CC  00000000   NOP
9D0034D0  00000000   NOP
9D0034D4  00000000   NOP
9D0034D8  00000000   NOP
9D0034DC  00000000   NOP
9D0034E0  00000000   NOP
9D0034E4  00000000   NOP
9D0034E8  00000000   NOP
9D0034EC  00000000   NOP
9D0034F0  00000000   NOP
9D0034F4  00000000   NOP
9D0034F8  00000000   NOP
9D0034FC  00000000   NOP
9D003500  00000000   NOP
9D003504  00000000   NOP
9D003508  00000000   NOP
9D00350C  00000000   NOP
9D003510  00000000   NOP
9D003514  00000000   NOP
9D003518  00000000   NOP
9D00351C  00000000   NOP
9D003520  00000000   NOP
9D003524  00000000   NOP
9D003528  00000000   NOP
9D00352C  00000000   NOP
9D003530  00000000   NOP
9D003534  00000000   NOP
9D003538  00000000   NOP
392:                   _cs_high();
9D00353C  24030002   ADDIU V1, ZERO, 2
9D003540  3C02BF88   LUI V0, -16504
9D003544  AC436138   SW V1, 24888(V0)
9D003548  03E00008   JR RA
9D00354C  00000000   NOP
393:                 }
394:                 
395:                 void tft_drawFastVLine(short x, short y, short h, unsigned short color) {
9D003550  27BDFFE0   ADDIU SP, SP, -32
9D003554  AFBF001C   SW RA, 28(SP)
9D003558  AFB20018   SW S2, 24(SP)
9D00355C  AFB10014   SW S1, 20(SP)
9D003560  AFB00010   SW S0, 16(SP)
9D003564  7C042620   SEH A0, A0
9D003568  7C052E20   SEH A1, A1
9D00356C  7C069620   SEH S2, A2
396:                 /* Draw a vertical line at location from (x,y) to (x,y+h-1) with color
397:                  * Parameters:
398:                  *      x:  x-coordinate line to draw; top left of screen is x=0
399:                  *              and x increases to the right
400:                  *      y:  y-coordinate of starting point of line; top left of screen is y=0
401:                  *              and y increases to the bottom
402:                  *      h:  height of line to draw
403:                  *      color:  16-bit color value
404:                  * Returns:     Nothing
405:                  */
406:                 
407:                   // Rudimentary clipping
408:                   if((x >= _width) || (y >= _height)) return;
9D003570  97828070   LHU V0, -32656(GP)
9D003574  0082102A   SLT V0, A0, V0
9D003578  10400023   BEQ V0, ZERO, 0x9D003608
9D00357C  30F1FFFF   ANDI S1, A3, -1
9D003580  97828078   LHU V0, -32648(GP)
9D003584  00A2182A   SLT V1, A1, V0
9D003588  1060001F   BEQ V1, ZERO, 0x9D003608
9D00358C  00B21821   ADDU V1, A1, S2
409:                 
410:                   if((y+h-1) >= _height)
9D003590  2463FFFF   ADDIU V1, V1, -1
9D003594  0062182A   SLT V1, V1, V0
9D003598  54600004   BNEL V1, ZERO, 0x9D0035AC
9D00359C  30A5FFFF   ANDI A1, A1, -1
411:                     h = _height-y;
9D0035A0  00451023   SUBU V0, V0, A1
9D0035A4  7C029620   SEH S2, V0
412:                 
413:                   tft_setAddrWindow(x, y, x, y+h-1);
9D0035A8  30A5FFFF   ANDI A1, A1, -1
9D0035AC  3086FFFF   ANDI A2, A0, -1
9D0035B0  3250FFFF   ANDI S0, S2, -1
9D0035B4  24A7FFFF   ADDIU A3, A1, -1
9D0035B8  02073821   ADDU A3, S0, A3
9D0035BC  00C02021   ADDU A0, A2, ZERO
9D0035C0  0F400BB0   JAL tft_setAddrWindow
9D0035C4  30E7FFFF   ANDI A3, A3, -1
414:                 
415:                   _dc_high();
9D0035C8  24030001   ADDIU V1, ZERO, 1
9D0035CC  3C02BF88   LUI V0, -16504
9D0035D0  AC436138   SW V1, 24888(V0)
416:                   _cs_low();
9D0035D4  24030002   ADDIU V1, ZERO, 2
9D0035D8  3C02BF88   LUI V0, -16504
9D0035DC  AC436134   SW V1, 24884(V0)
417:                 
418:                   while (h--) {
9D0035E0  12400007   BEQ S2, ZERO, 0x9D003600
9D0035E4  24030002   ADDIU V1, ZERO, 2
9D0035F8  1600FFFB   BNE S0, ZERO, 0x9D0035E8
9D0035FC  24030002   ADDIU V1, ZERO, 2
419:                       tft_spiwrite16(color);
9D0035E8  0F400A83   JAL tft_spiwrite16
9D0035EC  02202021   ADDU A0, S1, ZERO
9D0035F0  2610FFFF   ADDIU S0, S0, -1
9D0035F4  3210FFFF   ANDI S0, S0, -1
420:                   }
421:                 
422:                   _cs_high();
9D003600  3C02BF88   LUI V0, -16504
9D003604  AC436138   SW V1, 24888(V0)
423:                 }
9D003608  8FBF001C   LW RA, 28(SP)
9D00360C  8FB20018   LW S2, 24(SP)
9D003610  8FB10014   LW S1, 20(SP)
9D003614  8FB00010   LW S0, 16(SP)
9D003618  03E00008   JR RA
9D00361C  27BD0020   ADDIU SP, SP, 32
424:                 
425:                 
426:                 void tft_drawFastHLine(short x, short y, short w, unsigned short color) {
9D003620  27BDFFE0   ADDIU SP, SP, -32
9D003624  AFBF001C   SW RA, 28(SP)
9D003628  AFB20018   SW S2, 24(SP)
9D00362C  AFB10014   SW S1, 20(SP)
9D003630  AFB00010   SW S0, 16(SP)
9D003634  7C042620   SEH A0, A0
9D003638  7C052E20   SEH A1, A1
9D00363C  7C069620   SEH S2, A2
427:                 /* Draw a horizontal line at location from (x,y) to (x+w-1,y) with color
428:                  * Parameters:
429:                  *      x:  x-coordinate starting point of line; top left of screen is x=0
430:                  *              and x increases to the right
431:                  *      y:  y-coordinate of starting point of line; top left of screen is y=0
432:                  *              and y increases to the bottom
433:                  *      w:  width of line to draw
434:                  *      color:  16-bit color value
435:                  * Returns:     Nothing
436:                  */
437:                 
438:                   // Rudimentary clipping
439:                   if((x >= _width) || (y >= _height)) return;
9D003640  97828070   LHU V0, -32656(GP)
9D003644  0082182A   SLT V1, A0, V0
9D003648  10600023   BEQ V1, ZERO, 0x9D0036D8
9D00364C  30F1FFFF   ANDI S1, A3, -1
9D003650  97838078   LHU V1, -32648(GP)
9D003654  00A3182A   SLT V1, A1, V1
9D003658  1060001F   BEQ V1, ZERO, 0x9D0036D8
9D00365C  00921821   ADDU V1, A0, S2
440:                   if((x+w-1) >= _width)  w = _width-x;
9D003660  2463FFFF   ADDIU V1, V1, -1
9D003664  0062182A   SLT V1, V1, V0
9D003668  54600004   BNEL V1, ZERO, 0x9D00367C
9D00366C  3084FFFF   ANDI A0, A0, -1
9D003670  00441023   SUBU V0, V0, A0
9D003674  7C029620   SEH S2, V0
441:                   tft_setAddrWindow(x, y, x+w-1, y);
9D003678  3084FFFF   ANDI A0, A0, -1
9D00367C  3250FFFF   ANDI S0, S2, -1
9D003680  30A7FFFF   ANDI A3, A1, -1
9D003684  2486FFFF   ADDIU A2, A0, -1
9D003688  02063021   ADDU A2, S0, A2
9D00368C  00E02821   ADDU A1, A3, ZERO
9D003690  0F400BB0   JAL tft_setAddrWindow
9D003694  30C6FFFF   ANDI A2, A2, -1
442:                 
443:                   _dc_high();
9D003698  24030001   ADDIU V1, ZERO, 1
9D00369C  3C02BF88   LUI V0, -16504
9D0036A0  AC436138   SW V1, 24888(V0)
444:                   _cs_low();
9D0036A4  24030002   ADDIU V1, ZERO, 2
9D0036A8  3C02BF88   LUI V0, -16504
9D0036AC  AC436134   SW V1, 24884(V0)
445:                 
446:                   while (w--) {
9D0036B0  12400007   BEQ S2, ZERO, 0x9D0036D0
9D0036B4  24030002   ADDIU V1, ZERO, 2
9D0036C8  1600FFFB   BNE S0, ZERO, 0x9D0036B8
9D0036CC  24030002   ADDIU V1, ZERO, 2
447:                       tft_spiwrite16(color);
9D0036B8  0F400A83   JAL tft_spiwrite16
9D0036BC  02202021   ADDU A0, S1, ZERO
9D0036C0  2610FFFF   ADDIU S0, S0, -1
9D0036C4  3210FFFF   ANDI S0, S0, -1
448:                   }
449:                 
450:                   _cs_high();
9D0036D0  3C02BF88   LUI V0, -16504
9D0036D4  AC436138   SW V1, 24888(V0)
451:                 }
9D0036D8  8FBF001C   LW RA, 28(SP)
9D0036DC  8FB20018   LW S2, 24(SP)
9D0036E0  8FB10014   LW S1, 20(SP)
9D0036E4  8FB00010   LW S0, 16(SP)
9D0036E8  03E00008   JR RA
9D0036EC  27BD0020   ADDIU SP, SP, 32
452:                 
453:                 void tft_fillScreen(unsigned short color) {
9D0036F0  27BDFFE0   ADDIU SP, SP, -32
9D0036F4  AFBF001C   SW RA, 28(SP)
9D0036F8  3084FFFF   ANDI A0, A0, -1
454:                 /* Fill entire screen with given color
455:                  * Parameters:
456:                  *      color: 16-bit color value
457:                  * Returs:  Nothing
458:                  */
459:                     tft_fillRect(0, 0,  _width, _height, color);
9D0036FC  87868070   LH A2, -32656(GP)
9D003700  87878078   LH A3, -32648(GP)
9D003704  AFA40010   SW A0, 16(SP)
9D003708  00002021   ADDU A0, ZERO, ZERO
9D00370C  0F400DC8   JAL tft_fillRect
9D003710  00002821   ADDU A1, ZERO, ZERO
460:                 }
9D003714  8FBF001C   LW RA, 28(SP)
9D003718  03E00008   JR RA
9D00371C  27BD0020   ADDIU SP, SP, 32
461:                 
462:                 // fill a rectangle
463:                 void tft_fillRect(short x, short y, short w, short h,
464:                   unsigned short color) {
9D003720  27BDFFD8   ADDIU SP, SP, -40
9D003724  AFBF0024   SW RA, 36(SP)
9D003728  AFB30020   SW S3, 32(SP)
9D00372C  AFB2001C   SW S2, 28(SP)
9D003730  AFB10018   SW S1, 24(SP)
9D003734  AFB00014   SW S0, 20(SP)
9D003738  7C042620   SEH A0, A0
9D00373C  7C052E20   SEH A1, A1
9D003740  7C069E20   SEH S3, A2
9D003744  7C079620   SEH S2, A3
465:                 /* Draw a filled rectangle with starting top-left vertex (x,y),
466:                  *  width w and height h with given color
467:                  * Parameters:
468:                  *      x:  x-coordinate of top-left vertex; top left of screen is x=0
469:                  *              and x increases to the right
470:                  *      y:  y-coordinate of top-left vertex; top left of screen is y=0
471:                  *              and y increases to the bottom
472:                  *      w:  width of rectangle
473:                  *      h:  height of rectangle
474:                  *      color:  16-bit color value
475:                  * Returns:     Nothing
476:                  */
477:                 
478:                   // rudimentary clipping (drawChar w/big text requires this)
479:                   if((x >= _width) || (y >= _height)) return;
9D003748  97828070   LHU V0, -32656(GP)
9D00374C  0082182A   SLT V1, A0, V0
9D003750  10600034   BEQ V1, ZERO, 0x9D003824
9D003754  97B10038   LHU S1, 56(SP)
9D003758  97838078   LHU V1, -32648(GP)
9D00375C  00A3302A   SLT A2, A1, V1
9D003760  10C00030   BEQ A2, ZERO, 0x9D003824
9D003764  00933021   ADDU A2, A0, S3
480:                   if((x + w - 1) >= _width)  w = _width  - x;
9D003768  24C6FFFF   ADDIU A2, A2, -1
9D00376C  00C2302A   SLT A2, A2, V0
9D003770  54C00004   BNEL A2, ZERO, 0x9D003784
9D003774  00B21021   ADDU V0, A1, S2
9D003778  00441023   SUBU V0, V0, A0
9D00377C  7C029E20   SEH S3, V0
481:                   if((y + h - 1) >= _height) h = _height - y;
9D003780  00B21021   ADDU V0, A1, S2
9D003784  2442FFFF   ADDIU V0, V0, -1
9D003788  0043102A   SLT V0, V0, V1
9D00378C  14400003   BNE V0, ZERO, 0x9D00379C
9D003790  3084FFFF   ANDI A0, A0, -1
9D003794  00651823   SUBU V1, V1, A1
9D003798  7C039620   SEH S2, V1
482:                 
483:                   tft_setAddrWindow(x, y, x+w-1, y+h-1);
9D00379C  30A5FFFF   ANDI A1, A1, -1
9D0037A0  2486FFFF   ADDIU A2, A0, -1
9D0037A4  00D33021   ADDU A2, A2, S3
9D0037A8  24A7FFFF   ADDIU A3, A1, -1
9D0037AC  00F23821   ADDU A3, A3, S2
9D0037B0  30C6FFFF   ANDI A2, A2, -1
9D0037B4  0F400BB0   JAL tft_setAddrWindow
9D0037B8  30E7FFFF   ANDI A3, A3, -1
484:                 
485:                   _dc_high();
9D0037BC  24030001   ADDIU V1, ZERO, 1
9D0037C0  3C02BF88   LUI V0, -16504
9D0037C4  AC436138   SW V1, 24888(V0)
486:                   _cs_low();
9D0037C8  24030002   ADDIU V1, ZERO, 2
9D0037CC  3C02BF88   LUI V0, -16504
9D0037D0  AC436134   SW V1, 24884(V0)
487:                 
488:                   for(y=h; y>0; y--) {
9D0037D4  1A400011   BLEZ S2, 0x9D00381C
9D0037D8  24030002   ADDIU V1, ZERO, 2
9D0037DC  0B400E03   J 0x9D00380C
9D0037E0  00000000   NOP
9D0037FC  2652FFFF   ADDIU S2, S2, -1
9D003800  7C129620   SEH S2, S2
9D003804  12400005   BEQ S2, ZERO, 0x9D00381C
9D003808  24030002   ADDIU V1, ZERO, 2
489:                     for(x=w; x>0; x--) {
9D0037EC  2610FFFF   ADDIU S0, S0, -1
9D0037F0  7C108620   SEH S0, S0
9D0037F4  1600FFFB   BNE S0, ZERO, 0x9D0037E4
9D0037F8  00000000   NOP
9D00380C  5A60FFFC   BLEZL S3, 0x9D003800
9D003810  2652FFFF   ADDIU S2, S2, -1
9D003814  0B400DF9   J 0x9D0037E4
9D003818  02608021   ADDU S0, S3, ZERO
490:                         tft_spiwrite16(color);
9D0037E4  0F400A83   JAL tft_spiwrite16
9D0037E8  02202021   ADDU A0, S1, ZERO
491:                     }
492:                   }
493:                 
494:                   _cs_high();
9D00381C  3C02BF88   LUI V0, -16504
9D003820  AC436138   SW V1, 24888(V0)
495:                 }
9D003824  8FBF0024   LW RA, 36(SP)
9D003828  8FB30020   LW S3, 32(SP)
9D00382C  8FB2001C   LW S2, 28(SP)
9D003830  8FB10018   LW S1, 24(SP)
9D003834  8FB00014   LW S0, 20(SP)
9D003838  03E00008   JR RA
9D00383C  27BD0028   ADDIU SP, SP, 40
496:                 
497:                 inline unsigned short tft_Color565(unsigned char r, unsigned char g, unsigned char b) {
498:                 /* Pass 8-bit (each) R,G,B, get back 16-bit packed color
499:                  * Parameters:
500:                  *      r:  8-bit R/red value from RGB
501:                  *      g:  8-bit g/green value from RGB
502:                  *      b:  8-bit b/blue value from RGB
503:                  * Returns:
504:                  *      16-bit packed color value for color info
505:                  */
506:                   return ((r & 0xF8) << 8) | ((g & 0xFC) << 3) | (b >> 3);
9D003840  30A500FC   ANDI A1, A1, 252
9D003844  000528C0   SLL A1, A1, 3
9D003848  7CC620C0   EXT A2, A2, 3, 5
9D00384C  00A62825   OR A1, A1, A2
9D003850  308400F8   ANDI A0, A0, 248
9D003854  00042200   SLL A0, A0, 8
9D003858  00A41025   OR V0, A1, A0
507:                 }
9D00385C  03E00008   JR RA
9D003860  3042FFFF   ANDI V0, V0, -1
508:                 
509:                 
510:                 void tft_setRotation(unsigned char m) {
9D003864  27BDFFE8   ADDIU SP, SP, -24
9D003868  AFBF0014   SW RA, 20(SP)
9D00386C  AFB00010   SW S0, 16(SP)
9D003870  309000FF   ANDI S0, A0, 255
511:                   unsigned char rotation;
512:                   tft_writecommand(ILI9340_MADCTL);
9D003874  0F400A91   JAL tft_writecommand
9D003878  24040036   ADDIU A0, ZERO, 54
513:                   rotation = m % 4; // can't be higher than 3
514:                   switch (rotation) {
9D00387C  32040003   ANDI A0, S0, 3
9D003880  24020001   ADDIU V0, ZERO, 1
9D003884  10820010   BEQ A0, V0, 0x9D0038C8
9D003888  00000000   NOP
9D00388C  10800007   BEQ A0, ZERO, 0x9D0038AC
9D003890  24020002   ADDIU V0, ZERO, 2
9D003894  10820013   BEQ A0, V0, 0x9D0038E4
9D003898  24020003   ADDIU V0, ZERO, 3
9D00389C  10820018   BEQ A0, V0, 0x9D003900
9D0038A0  8FBF0014   LW RA, 20(SP)
515:                    case 0:
516:                      tft_writedata(ILI9340_MADCTL_MX | ILI9340_MADCTL_BGR);
9D0038AC  0F400AB1   JAL tft_writedata
9D0038B0  24040048   ADDIU A0, ZERO, 72
517:                      _width  = ILI9340_TFTWIDTH;
9D0038B4  240200F0   ADDIU V0, ZERO, 240
9D0038B8  A7828070   SH V0, -32656(GP)
518:                      _height = ILI9340_TFTHEIGHT;
9D0038BC  24020140   ADDIU V0, ZERO, 320
519:                      break;
9D0038C0  0B400E46   J 0x9D003918
9D0038C4  A7828078   SH V0, -32648(GP)
520:                    case 1:
521:                      tft_writedata(ILI9340_MADCTL_MV | ILI9340_MADCTL_BGR);
9D0038C8  0F400AB1   JAL tft_writedata
9D0038CC  24040028   ADDIU A0, ZERO, 40
522:                      _width  = ILI9340_TFTHEIGHT;
9D0038D0  24020140   ADDIU V0, ZERO, 320
9D0038D4  A7828070   SH V0, -32656(GP)
523:                      _height = ILI9340_TFTWIDTH;
9D0038D8  240200F0   ADDIU V0, ZERO, 240
524:                      break;
9D0038DC  0B400E46   J 0x9D003918
9D0038E0  A7828078   SH V0, -32648(GP)
525:                   case 2:
526:                     tft_writedata(ILI9340_MADCTL_MY | ILI9340_MADCTL_BGR);
9D0038E4  0F400AB1   JAL tft_writedata
9D0038E8  24040088   ADDIU A0, ZERO, 136
527:                      _width  = ILI9340_TFTWIDTH;
9D0038EC  240200F0   ADDIU V0, ZERO, 240
9D0038F0  A7828070   SH V0, -32656(GP)
528:                      _height = ILI9340_TFTHEIGHT;
9D0038F4  24020140   ADDIU V0, ZERO, 320
529:                     break;
9D0038F8  0B400E46   J 0x9D003918
9D0038FC  A7828078   SH V0, -32648(GP)
530:                    case 3:
531:                      tft_writedata(ILI9340_MADCTL_MV | ILI9340_MADCTL_MY | ILI9340_MADCTL_MX | ILI9340_MADCTL_BGR);
9D003900  0F400AB1   JAL tft_writedata
9D003904  240400E8   ADDIU A0, ZERO, 232
532:                      _width  = ILI9340_TFTHEIGHT;
9D003908  24020140   ADDIU V0, ZERO, 320
9D00390C  A7828070   SH V0, -32656(GP)
533:                      _height = ILI9340_TFTWIDTH;
9D003910  240200F0   ADDIU V0, ZERO, 240
9D003914  A7828078   SH V0, -32648(GP)
534:                      break;
535:                   }
536:                 }
9D0038A4  0B400E48   J 0x9D003920
9D0038A8  8FB00010   LW S0, 16(SP)
9D003918  8FBF0014   LW RA, 20(SP)
9D00391C  8FB00010   LW S0, 16(SP)
9D003920  03E00008   JR RA
9D003924  27BD0018   ADDIU SP, SP, 24
537:                 
538:                 void delay_ms(unsigned long i){
9D003928  27BDFFE8   ADDIU SP, SP, -24
9D00392C  AFBF0014   SW RA, 20(SP)
9D003930  AFB00010   SW S0, 16(SP)
539:                 /* Create a software delay about i ms long
540:                  * Parameters:
541:                  *      i:  equal to number of milliseconds for delay
542:                  * Returns: Nothing
543:                  * Note: Uses Core Timer. Core Timer is cleared at the initialiazion of
544:                  *      this function. So, applications sensitive to the Core Timer are going
545:                  *      to be affected
546:                  */
547:                     unsigned int j;
548:                     j = dTime_ms * i;
9D003934  00041080   SLL V0, A0, 2
9D003938  000481C0   SLL S0, A0, 7
9D00393C  02028023   SUBU S0, S0, V0
9D003940  02042021   ADDU A0, S0, A0
9D003944  00048080   SLL S0, A0, 2
9D003948  00902021   ADDU A0, A0, S0
9D00394C  00048140   SLL S0, A0, 5
549:                     WriteCoreTimer(0);
9D003950  0F401D8D   JAL WriteCoreTimer
9D003954  00002021   ADDU A0, ZERO, ZERO
550:                     while (ReadCoreTimer() < j);
9D003958  0F401D8B   JAL ReadCoreTimer
9D00395C  00000000   NOP
9D003960  0050102B   SLTU V0, V0, S0
9D003964  1440FFFC   BNE V0, ZERO, 0x9D003958
9D003968  8FBF0014   LW RA, 20(SP)
551:                 }
9D00396C  8FB00010   LW S0, 16(SP)
9D003970  03E00008   JR RA
9D003974  27BD0018   ADDIU SP, SP, 24
552:                 
553:                 void delay_us(unsigned long i){
9D003978  27BDFFE8   ADDIU SP, SP, -24
9D00397C  AFBF0014   SW RA, 20(SP)
9D003980  AFB00010   SW S0, 16(SP)
554:                 /* Create a software delay about i us long
555:                  * Parameters:
556:                  *      i:  equal to number of microseconds for delay
557:                  * Returns: Nothing
558:                  * Note: Uses Core Timer. Core Timer is cleared at the initialiazion of
559:                  *      this function. So, applications sensitive to the Core Timer are going
560:                  *      to be affected
561:                  */
562:                     unsigned int j;
563:                     j = dTime_us * i;
9D003984  00048080   SLL S0, A0, 2
9D003988  00042100   SLL A0, A0, 4
9D00398C  02048021   ADDU S0, S0, A0
564:                     WriteCoreTimer(0);
9D003990  0F401D8D   JAL WriteCoreTimer
9D003994  00002021   ADDU A0, ZERO, ZERO
565:                     while (ReadCoreTimer() < j);
9D003998  0F401D8B   JAL ReadCoreTimer
9D00399C  00000000   NOP
9D0039A0  0050102B   SLTU V0, V0, S0
9D0039A4  1440FFFC   BNE V0, ZERO, 0x9D003998
9D0039A8  8FBF0014   LW RA, 20(SP)
566:                 }
9D0039AC  8FB00010   LW S0, 16(SP)
9D0039B0  03E00008   JR RA
9D0039B4  27BD0018   ADDIU SP, SP, 24
567:                 
568:                 //void tft_invertDisplay(boolean i) {
569:                 //  writecommand(i ? ILI9340_INVON : ILI9340_INVOFF);
570:                 //}
571:                 
572:                 
573:                 ////////// stuff not actively being used, but kept for posterity
574:                 
575:                 
576:                 //unsigned char tft_spiread(void) {
577:                 //  unsigned char r = 0;
578:                 //
579:                 //  /*
580:                 //   * ADD SPI INTERFACE CODE -----------------------------------------------&**************************
581:                 //  */
582:                 //  //Serial.print("read: 0x"); Serial.print(r, HEX);
583:                 //
584:                 //  return r;
585:                 //}
586:                 
587:                 // unsigned char tft_readdata(void) {
588:                 //   unsigned char r;
589:                 //   _dc_high();
590:                 //   _cs_low();
591:                 //   r = tft_spiread();
592:                 //   _cs_high();
593:                 //   return r;
594:                 //
595:                 //}
596:                 //
597:                 //
598:                 // unsigned char tft_readcommand8(unsigned char c) {
599:                 //     _dc_low();
600:                 ////     _sclk = 0;
601:                 //     _cs_low();
602:                 //     tft_spiwrite8(c);
603:                 //
604:                 //     _dc_high();
605:                 //     unsigned char r = tft_spiread();
606:                 //     _cs_high();
607:                 //     return r;
608:                 //
609:                 //   /*
610:                 //   digitalWrite(_dc, LOW);
611:                 //   digitalWrite(_sclk, LOW);
612:                 //   digitalWrite(_cs, LOW);
613:                 //   spiwrite(c);
614:                 //
615:                 //   digitalWrite(_dc, HIGH);
616:                 //   unsigned char r = spiread();
617:                 //   digitalWrite(_cs, HIGH);
618:                 //   return r;
619:                 //    */
620:                 //}
---  z:/eedocs/4760/pic/big_board_pt_1_2/tft_gfx.c  -----------------------------------------------------
1:                   /* Code rewritten from Adafruit Arduino library for the TFT
2:                    *  by Syed Tahmid Mahbub
3:                    * The TFT itself is Adafruit product 1480
4:                    * Included below is the text header from the original Adafruit library
5:                    *  followed by the code
6:                    */
7:                   
8:                   /*
9:                   This is the core graphics library for all our displays, providing a common
10:                  set of graphics primitives (points, lines, circles, etc.).  It needs to be
11:                  paired with a hardware-specific library for each display device we carry
12:                  (to handle the lower-level functions).
13:                  
14:                  Adafruit invests time and resources providing this open source code, please
15:                  support Adafruit & open-source hardware by purchasing products from Adafruit!
16:                  
17:                  Copyright (c) 2013 Adafruit Industries.  All rights reserved.
18:                  
19:                  Redistribution and use in source and binary forms, with or without
20:                  modification, are permitted provided that the following conditions are met:
21:                  
22:                  - Redistributions of source code must retain the above copyright notice,
23:                    this list of conditions and the following disclaimer.
24:                  - Redistributions in binary form must reproduce the above copyright notice,
25:                    this list of conditions and the following disclaimer in the documentation
26:                    and/or other materials provided with the distribution.
27:                  
28:                  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
29:                  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
30:                  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
31:                  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
32:                  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
33:                  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
34:                  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
35:                  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
36:                  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
37:                  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
38:                  POSSIBILITY OF SUCH DAMAGE.
39:                  */
40:                  
41:                  #include "tft_gfx.h"
42:                  #include "glcdfont.c"
43:                  #include "tft_master.h"
44:                  
45:                  #define pgm_read_byte(addr) (*(const unsigned char *)(addr))
46:                  
47:                  void tft_drawCircle(short x0, short y0, short r, unsigned short color) {
9D000000  27BDFFA8   ADDIU SP, SP, -88
9D000004  AFBF0054   SW RA, 84(SP)
9D000008  AFBE0050   SW S8, 80(SP)
9D00000C  AFB7004C   SW S7, 76(SP)
9D000010  AFB60048   SW S6, 72(SP)
9D000014  AFB50044   SW S5, 68(SP)
9D000018  AFB40040   SW S4, 64(SP)
9D00001C  AFB3003C   SW S3, 60(SP)
9D000020  AFB20038   SW S2, 56(SP)
9D000024  AFB10034   SW S1, 52(SP)
9D000028  AFB00030   SW S0, 48(SP)
9D00002C  7C04B620   SEH S6, A0
9D000030  7C05AE20   SEH S5, A1
9D000034  7C06A620   SEH S4, A2
9D000038  30F2FFFF   ANDI S2, A3, -1
48:                  /* Draw a circle outline with center (x0,y0) and radius r, with given color
49:                   * Parameters:
50:                   *      x0: x-coordinate of center of circle. The top-left of the screen
51:                   *          has x-coordinate 0 and increases to the right
52:                   *      y0: y-coordinate of center of circle. The top-left of the screen
53:                   *          has y-coordinate 0 and increases to the bottom
54:                   *      r:  radius of circle
55:                   *      color: 16-bit color value for the circle. Note that the circle
56:                   *          isn't filled. So, this is the color of the outline of the circle
57:                   * Returns: Nothing
58:                   */
59:                    short f = 1 - r;
9D00003C  3291FFFF   ANDI S1, S4, -1
9D000040  24130001   ADDIU S3, ZERO, 1
9D000044  02719823   SUBU S3, S3, S1
9D000048  7C139E20   SEH S3, S3
60:                    short ddF_x = 1;
61:                    short ddF_y = -2 * r;
9D00004C  00111023   SUBU V0, ZERO, S1
9D000050  00021040   SLL V0, V0, 1
9D000054  7C021620   SEH V0, V0
9D000058  AFA20018   SW V0, 24(SP)
62:                    short x = 0;
63:                    short y = r;
64:                  
65:                    tft_drawPixel(x0  , y0+r, color);
9D00005C  32A2FFFF   ANDI V0, S5, -1
9D000060  AFA20010   SW V0, 16(SP)
9D000064  02222821   ADDU A1, S1, V0
9D000068  02C02021   ADDU A0, S6, ZERO
9D00006C  7C052E20   SEH A1, A1
9D000070  0F400BE1   JAL tft_drawPixel
9D000074  02403021   ADDU A2, S2, ZERO
66:                    tft_drawPixel(x0  , y0-r, color);
9D000078  8FA30010   LW V1, 16(SP)
9D00007C  00712823   SUBU A1, V1, S1
9D000080  02C02021   ADDU A0, S6, ZERO
9D000084  7C052E20   SEH A1, A1
9D000088  0F400BE1   JAL tft_drawPixel
9D00008C  02403021   ADDU A2, S2, ZERO
67:                    tft_drawPixel(x0+r, y0  , color);
9D000090  32D6FFFF   ANDI S6, S6, -1
9D000094  AFB60014   SW S6, 20(SP)
9D000098  02362021   ADDU A0, S1, S6
9D00009C  7C042620   SEH A0, A0
9D0000A0  02A02821   ADDU A1, S5, ZERO
9D0000A4  0F400BE1   JAL tft_drawPixel
9D0000A8  02403021   ADDU A2, S2, ZERO
68:                    tft_drawPixel(x0-r, y0  , color);
9D0000AC  8FB60014   LW S6, 20(SP)
9D0000B0  02D12023   SUBU A0, S6, S1
9D0000B4  7C042620   SEH A0, A0
9D0000B8  02A02821   ADDU A1, S5, ZERO
9D0000BC  0F400BE1   JAL tft_drawPixel
9D0000C0  02403021   ADDU A2, S2, ZERO
69:                  
70:                    while (x<y) {
9D0000C4  1A80005A   BLEZ S4, 0x9D000230
9D0000C8  02408021   ADDU S0, S2, ZERO
9D0000CC  0000A821   ADDU S5, ZERO, ZERO
9D0000D0  8FB60014   LW S6, 20(SP)
9D0000D4  26C20001   ADDIU V0, S6, 1
9D0000D8  AFA2001C   SW V0, 28(SP)
9D0000DC  26C3FFFF   ADDIU V1, S6, -1
9D0000E0  AFA30020   SW V1, 32(SP)
9D0000E4  8FA20010   LW V0, 16(SP)
9D0000E8  24420001   ADDIU V0, V0, 1
9D0000EC  AFA20024   SW V0, 36(SP)
9D0000F0  8FA30010   LW V1, 16(SP)
9D0000F4  2463FFFF   ADDIU V1, V1, -1
9D0000F8  AFA30028   SW V1, 40(SP)
9D000220  7C118E20   SEH S1, S1
9D000224  0234882A   SLT S1, S1, S4
9D000228  1620FFB4   BNE S1, ZERO, 0x9D0000FC
9D00022C  26B50001   ADDIU S5, S5, 1
71:                      if (f >= 0) {
9D0000FC  06600009   BLTZ S3, 0x9D000124
9D000100  8FA30018   LW V1, 24(SP)
72:                        y--;
9D000104  2694FFFF   ADDIU S4, S4, -1
9D000108  7C14A620   SEH S4, S4
73:                        ddF_y += 2;
9D00010C  24620002   ADDIU V0, V1, 2
9D000110  3042FFFF   ANDI V0, V0, -1
9D000114  7C021E20   SEH V1, V0
9D000118  AFA30018   SW V1, 24(SP)
74:                        f += ddF_y;
9D00011C  00539821   ADDU S3, V0, S3
9D000120  7C139E20   SEH S3, S3
9D000124  32B1FFFF   ANDI S1, S5, -1
9D000128  00111040   SLL V0, S1, 1
9D00012C  24420003   ADDIU V0, V0, 3
75:                      }
76:                      x++;
77:                      ddF_x += 2;
78:                      f += ddF_x;
9D000130  00539821   ADDU S3, V0, S3
9D000134  7C139E20   SEH S3, S3
9D000138  8FA2001C   LW V0, 28(SP)
9D00013C  0222F021   ADDU S8, S1, V0
79:                  
80:                      tft_drawPixel(x0 + x, y0 + y, color);
9D000140  7C1EF620   SEH S8, S8
9D000144  3292FFFF   ANDI S2, S4, -1
9D000148  8FA30010   LW V1, 16(SP)
9D00014C  0243B021   ADDU S6, S2, V1
9D000150  7C16B620   SEH S6, S6
9D000154  03C02021   ADDU A0, S8, ZERO
9D000158  02C02821   ADDU A1, S6, ZERO
9D00015C  0F400BE1   JAL tft_drawPixel
9D000160  02003021   ADDU A2, S0, ZERO
9D000164  8FA20020   LW V0, 32(SP)
9D000168  0051B823   SUBU S7, V0, S1
81:                      tft_drawPixel(x0 - x, y0 + y, color);
9D00016C  7C17BE20   SEH S7, S7
9D000170  02E02021   ADDU A0, S7, ZERO
9D000174  02C02821   ADDU A1, S6, ZERO
9D000178  0F400BE1   JAL tft_drawPixel
9D00017C  02003021   ADDU A2, S0, ZERO
82:                      tft_drawPixel(x0 + x, y0 - y, color);
9D000180  8FA30010   LW V1, 16(SP)
9D000184  0072B023   SUBU S6, V1, S2
9D000188  7C16B620   SEH S6, S6
9D00018C  03C02021   ADDU A0, S8, ZERO
9D000190  02C02821   ADDU A1, S6, ZERO
9D000194  0F400BE1   JAL tft_drawPixel
9D000198  02003021   ADDU A2, S0, ZERO
83:                      tft_drawPixel(x0 - x, y0 - y, color);
9D00019C  02E02021   ADDU A0, S7, ZERO
9D0001A0  02C02821   ADDU A1, S6, ZERO
9D0001A4  0F400BE1   JAL tft_drawPixel
9D0001A8  02003021   ADDU A2, S0, ZERO
84:                      tft_drawPixel(x0 + y, y0 + x, color);
9D0001AC  8FA20014   LW V0, 20(SP)
9D0001B0  0242B021   ADDU S6, S2, V0
9D0001B4  7C16B620   SEH S6, S6
9D0001B8  8FA30024   LW V1, 36(SP)
9D0001BC  0223B821   ADDU S7, S1, V1
9D0001C0  7C17BE20   SEH S7, S7
9D0001C4  02C02021   ADDU A0, S6, ZERO
9D0001C8  02E02821   ADDU A1, S7, ZERO
9D0001CC  0F400BE1   JAL tft_drawPixel
9D0001D0  02003021   ADDU A2, S0, ZERO
85:                      tft_drawPixel(x0 - y, y0 + x, color);
9D0001D4  8FA20014   LW V0, 20(SP)
9D0001D8  00529023   SUBU S2, V0, S2
9D0001DC  7C129620   SEH S2, S2
9D0001E0  02402021   ADDU A0, S2, ZERO
9D0001E4  02E02821   ADDU A1, S7, ZERO
9D0001E8  0F400BE1   JAL tft_drawPixel
9D0001EC  02003021   ADDU A2, S0, ZERO
9D0001F0  8FA30028   LW V1, 40(SP)
9D0001F4  0071B823   SUBU S7, V1, S1
86:                      tft_drawPixel(x0 + y, y0 - x, color);
9D0001F8  7C17BE20   SEH S7, S7
9D0001FC  02C02021   ADDU A0, S6, ZERO
9D000200  02E02821   ADDU A1, S7, ZERO
9D000204  0F400BE1   JAL tft_drawPixel
9D000208  02003021   ADDU A2, S0, ZERO
87:                      tft_drawPixel(x0 - y, y0 - x, color);
9D00020C  02402021   ADDU A0, S2, ZERO
9D000210  02E02821   ADDU A1, S7, ZERO
9D000214  0F400BE1   JAL tft_drawPixel
9D000218  02003021   ADDU A2, S0, ZERO
9D00021C  26310001   ADDIU S1, S1, 1
88:                    }
89:                  }
9D000230  8FBF0054   LW RA, 84(SP)
9D000234  8FBE0050   LW S8, 80(SP)
9D000238  8FB7004C   LW S7, 76(SP)
9D00023C  8FB60048   LW S6, 72(SP)
9D000240  8FB50044   LW S5, 68(SP)
9D000244  8FB40040   LW S4, 64(SP)
9D000248  8FB3003C   LW S3, 60(SP)
9D00024C  8FB20038   LW S2, 56(SP)
9D000250  8FB10034   LW S1, 52(SP)
9D000254  8FB00030   LW S0, 48(SP)
9D000258  03E00008   JR RA
9D00025C  27BD0058   ADDIU SP, SP, 88
90:                  
91:                  void tft_drawCircleHelper( short x0, short y0,
92:                                 short r, unsigned char cornername, unsigned short color) {
9D000260  27BDFFB0   ADDIU SP, SP, -80
9D000264  AFBF004C   SW RA, 76(SP)
9D000268  AFBE0048   SW S8, 72(SP)
9D00026C  AFB70044   SW S7, 68(SP)
9D000270  AFB60040   SW S6, 64(SP)
9D000274  AFB5003C   SW S5, 60(SP)
9D000278  AFB40038   SW S4, 56(SP)
9D00027C  AFB30034   SW S3, 52(SP)
9D000280  AFB20030   SW S2, 48(SP)
9D000284  AFB1002C   SW S1, 44(SP)
9D000288  AFB00028   SW S0, 40(SP)
9D00028C  7C042620   SEH A0, A0
9D000290  7C05BE20   SEH S7, A1
9D000294  7C069620   SEH S2, A2
9D000298  30E700FF   ANDI A3, A3, 255
9D00029C  97B30060   LHU S3, 96(SP)
93:                  // Helper function for drawing circles and circular objects
94:                    short f     = 1 - r;
9D0002A0  3256FFFF   ANDI S6, S2, -1
9D0002A4  24110001   ADDIU S1, ZERO, 1
9D0002A8  02368823   SUBU S1, S1, S6
9D0002AC  7C118E20   SEH S1, S1
95:                    short ddF_x = 1;
96:                    short ddF_y = -2 * r;
9D0002B0  0016B023   SUBU S6, ZERO, S6
9D0002B4  0016B040   SLL S6, S6, 1
97:                    short x     = 0;
98:                    short y     = r;
99:                  
100:                   while (x<y) {
9D0002B8  1A400070   BLEZ S2, 0x9D00047C
9D0002BC  7C16B620   SEH S6, S6
9D0002C0  24100001   ADDIU S0, ZERO, 1
9D000470  02B2A82A   SLT S5, S5, S2
9D000474  16A0FF9E   BNE S5, ZERO, 0x9D0002F0
9D000478  3210FFFF   ANDI S0, S0, -1
101:                     if (f >= 0) {
9D0002F0  06200008   BLTZ S1, 0x9D000314
9D0002F4  7C10AE20   SEH S5, S0
102:                       y--;
9D0002F8  2652FFFF   ADDIU S2, S2, -1
9D0002FC  7C129620   SEH S2, S2
103:                       ddF_y += 2;
9D000300  26D60002   ADDIU S6, S6, 2
9D000304  32C2FFFF   ANDI V0, S6, -1
9D000308  7C02B620   SEH S6, V0
104:                       f     += ddF_y;
9D00030C  00518821   ADDU S1, V0, S1
9D000310  7C118E20   SEH S1, S1
9D000314  00101040   SLL V0, S0, 1
9D000318  24420001   ADDIU V0, V0, 1
105:                     }
106:                     x++;
107:                     ddF_x += 2;
108:                     f     += ddF_x;
9D00031C  02228821   ADDU S1, S1, V0
109:                     if (cornername & 0x4) {
9D0002C4  30FE0004   ANDI S8, A3, 4
9D0002C8  33DE00FF   ANDI S8, S8, 255
9D000320  13C00013   BEQ S8, ZERO, 0x9D000370
9D000324  7C118E20   SEH S1, S1
110:                       tft_drawPixel(x0 + x, y0 + y, color);
9D0002CC  3094FFFF   ANDI S4, A0, -1
9D000328  32E3FFFF   ANDI V1, S7, -1
9D00032C  3242FFFF   ANDI V0, S2, -1
9D000330  02902021   ADDU A0, S4, S0
9D000334  AFA30010   SW V1, 16(SP)
9D000338  AFA20014   SW V0, 20(SP)
9D00033C  00432821   ADDU A1, V0, V1
9D000340  7C042620   SEH A0, A0
9D000344  7C052E20   SEH A1, A1
9D000348  0F400BE1   JAL tft_drawPixel
9D00034C  02603021   ADDU A2, S3, ZERO
111:                       tft_drawPixel(x0 + y, y0 + x, color);
9D000350  8FA20014   LW V0, 20(SP)
9D000354  00542021   ADDU A0, V0, S4
9D000358  8FA30010   LW V1, 16(SP)
9D00035C  00702821   ADDU A1, V1, S0
9D000360  7C042620   SEH A0, A0
9D000364  7C052E20   SEH A1, A1
9D000368  0F400BE1   JAL tft_drawPixel
9D00036C  02603021   ADDU A2, S3, ZERO
112:                     }
113:                     if (cornername & 0x2) {
9D0002D0  30E20002   ANDI V0, A3, 2
9D0002D4  304200FF   ANDI V0, V0, 255
9D0002D8  AFA20018   SW V0, 24(SP)
9D000370  8FA20018   LW V0, 24(SP)
9D000374  10400014   BEQ V0, ZERO, 0x9D0003C8
9D000378  8FA3001C   LW V1, 28(SP)
114:                       tft_drawPixel(x0 + x, y0 - y, color);
9D00037C  32E3FFFF   ANDI V1, S7, -1
9D000380  3242FFFF   ANDI V0, S2, -1
9D000384  02902021   ADDU A0, S4, S0
9D000388  AFA30010   SW V1, 16(SP)
9D00038C  AFA20014   SW V0, 20(SP)
9D000390  00622823   SUBU A1, V1, V0
9D000394  7C042620   SEH A0, A0
9D000398  7C052E20   SEH A1, A1
9D00039C  0F400BE1   JAL tft_drawPixel
9D0003A0  02603021   ADDU A2, S3, ZERO
115:                       tft_drawPixel(x0 + y, y0 - x, color);
9D0003A4  8FA30014   LW V1, 20(SP)
9D0003A8  00742021   ADDU A0, V1, S4
9D0003AC  8FA20010   LW V0, 16(SP)
9D0003B0  00502823   SUBU A1, V0, S0
9D0003B4  7C042620   SEH A0, A0
9D0003B8  7C052E20   SEH A1, A1
9D0003BC  0F400BE1   JAL tft_drawPixel
9D0003C0  02603021   ADDU A2, S3, ZERO
116:                     }
117:                     if (cornername & 0x8) {
9D0002DC  30E20008   ANDI V0, A3, 8
9D0002E0  304200FF   ANDI V0, V0, 255
9D0002E4  AFA2001C   SW V0, 28(SP)
9D0003C4  8FA3001C   LW V1, 28(SP)
9D0003C8  10600014   BEQ V1, ZERO, 0x9D00041C
9D0003CC  8FA20020   LW V0, 32(SP)
118:                       tft_drawPixel(x0 - y, y0 + x, color);
9D0003D0  3243FFFF   ANDI V1, S2, -1
9D0003D4  32E2FFFF   ANDI V0, S7, -1
9D0003D8  AFA30010   SW V1, 16(SP)
9D0003DC  02832023   SUBU A0, S4, V1
9D0003E0  AFA20014   SW V0, 20(SP)
9D0003E4  00502821   ADDU A1, V0, S0
9D0003E8  7C042620   SEH A0, A0
9D0003EC  7C052E20   SEH A1, A1
9D0003F0  0F400BE1   JAL tft_drawPixel
9D0003F4  02603021   ADDU A2, S3, ZERO
9D0003F8  02902023   SUBU A0, S4, S0
119:                       tft_drawPixel(x0 - x, y0 + y, color);
9D0003FC  8FA20010   LW V0, 16(SP)
9D000400  8FA30014   LW V1, 20(SP)
9D000404  00432821   ADDU A1, V0, V1
9D000408  7C042620   SEH A0, A0
9D00040C  7C052E20   SEH A1, A1
9D000410  0F400BE1   JAL tft_drawPixel
9D000414  02603021   ADDU A2, S3, ZERO
120:                     }
121:                     if (cornername & 0x1) {
9D0002E8  30E70001   ANDI A3, A3, 1
9D0002EC  AFA70020   SW A3, 32(SP)
9D000418  8FA20020   LW V0, 32(SP)
9D00041C  50400014   BEQL V0, ZERO, 0x9D000470
9D000420  26100001   ADDIU S0, S0, 1
122:                       tft_drawPixel(x0 - y, y0 - x, color);
9D000424  3243FFFF   ANDI V1, S2, -1
9D000428  32E2FFFF   ANDI V0, S7, -1
9D00042C  AFA30010   SW V1, 16(SP)
9D000430  02832023   SUBU A0, S4, V1
9D000434  AFA20014   SW V0, 20(SP)
9D000438  00502823   SUBU A1, V0, S0
9D00043C  7C042620   SEH A0, A0
9D000440  7C052E20   SEH A1, A1
9D000444  0F400BE1   JAL tft_drawPixel
9D000448  02603021   ADDU A2, S3, ZERO
9D00044C  02902023   SUBU A0, S4, S0
123:                       tft_drawPixel(x0 - x, y0 - y, color);
9D000450  8FA30014   LW V1, 20(SP)
9D000454  8FA20010   LW V0, 16(SP)
9D000458  00622823   SUBU A1, V1, V0
9D00045C  7C042620   SEH A0, A0
9D000460  7C052E20   SEH A1, A1
9D000464  0F400BE1   JAL tft_drawPixel
9D000468  02603021   ADDU A2, S3, ZERO
9D00046C  26100001   ADDIU S0, S0, 1
124:                     }
125:                   }
126:                 }
9D00047C  8FBF004C   LW RA, 76(SP)
9D000480  8FBE0048   LW S8, 72(SP)
9D000484  8FB70044   LW S7, 68(SP)
9D000488  8FB60040   LW S6, 64(SP)
9D00048C  8FB5003C   LW S5, 60(SP)
9D000490  8FB40038   LW S4, 56(SP)
9D000494  8FB30034   LW S3, 52(SP)
9D000498  8FB20030   LW S2, 48(SP)
9D00049C  8FB1002C   LW S1, 44(SP)
9D0004A0  8FB00028   LW S0, 40(SP)
9D0004A4  03E00008   JR RA
9D0004A8  27BD0050   ADDIU SP, SP, 80
127:                 
128:                 void tft_fillCircle(short x0, short y0, short r, unsigned short color) {
9D0004AC  27BDFFD0   ADDIU SP, SP, -48
9D0004B0  AFBF002C   SW RA, 44(SP)
9D0004B4  AFB30028   SW S3, 40(SP)
9D0004B8  AFB20024   SW S2, 36(SP)
9D0004BC  AFB10020   SW S1, 32(SP)
9D0004C0  AFB0001C   SW S0, 28(SP)
9D0004C4  7C049620   SEH S2, A0
9D0004C8  7C058E20   SEH S1, A1
9D0004CC  7C068620   SEH S0, A2
9D0004D0  30F3FFFF   ANDI S3, A3, -1
129:                 /* Draw a filled circle with center (x0,y0) and radius r, with given color
130:                  * Parameters:
131:                  *      x0: x-coordinate of center of circle. The top-left of the screen
132:                  *          has x-coordinate 0 and increases to the right
133:                  *      y0: y-coordinate of center of circle. The top-left of the screen
134:                  *          has y-coordinate 0 and increases to the bottom
135:                  *      r:  radius of circle
136:                  *      color: 16-bit color value for the circle
137:                  * Returns: Nothing
138:                  */
139:                   tft_drawFastVLine(x0, y0-r, 2*r+1, color);
9D0004D4  3202FFFF   ANDI V0, S0, -1
9D0004D8  02222823   SUBU A1, S1, V0
9D0004DC  00021040   SLL V0, V0, 1
9D0004E0  24460001   ADDIU A2, V0, 1
9D0004E4  02402021   ADDU A0, S2, ZERO
9D0004E8  7C052E20   SEH A1, A1
9D0004EC  7C063620   SEH A2, A2
9D0004F0  0F400D54   JAL tft_drawFastVLine
9D0004F4  02603821   ADDU A3, S3, ZERO
140:                   tft_fillCircleHelper(x0, y0, r, 3, 0, color);
9D0004F8  AFA00010   SW ZERO, 16(SP)
9D0004FC  AFB30014   SW S3, 20(SP)
9D000500  02402021   ADDU A0, S2, ZERO
9D000504  02202821   ADDU A1, S1, ZERO
9D000508  02003021   ADDU A2, S0, ZERO
9D00050C  0F40014C   JAL tft_fillCircleHelper
9D000510  24070003   ADDIU A3, ZERO, 3
141:                 }
9D000514  8FBF002C   LW RA, 44(SP)
9D000518  8FB30028   LW S3, 40(SP)
9D00051C  8FB20024   LW S2, 36(SP)
9D000520  8FB10020   LW S1, 32(SP)
9D000524  8FB0001C   LW S0, 28(SP)
9D000528  03E00008   JR RA
9D00052C  27BD0030   ADDIU SP, SP, 48
142:                 
143:                 void tft_fillCircleHelper(short x0, short y0, short r,
144:                     unsigned char cornername, short delta, unsigned short color) {
9D000530  27BDFFA8   ADDIU SP, SP, -88
9D000534  AFBF0054   SW RA, 84(SP)
9D000538  AFBE0050   SW S8, 80(SP)
9D00053C  AFB7004C   SW S7, 76(SP)
9D000540  AFB60048   SW S6, 72(SP)
9D000544  AFB50044   SW S5, 68(SP)
9D000548  AFB40040   SW S4, 64(SP)
9D00054C  AFB3003C   SW S3, 60(SP)
9D000550  AFB20038   SW S2, 56(SP)
9D000554  AFB10034   SW S1, 52(SP)
9D000558  AFB00030   SW S0, 48(SP)
9D00055C  7C042620   SEH A0, A0
9D000560  7C052E20   SEH A1, A1
9D000564  7C069620   SEH S2, A2
9D000568  30E700FF   ANDI A3, A3, 255
9D00056C  87A20068   LH V0, 104(SP)
9D000570  97B7006C   LHU S7, 108(SP)
145:                 // Helper function for drawing filled circles
146:                   short f     = 1 - r;
9D000574  3256FFFF   ANDI S6, S2, -1
9D000578  24100001   ADDIU S0, ZERO, 1
9D00057C  02168023   SUBU S0, S0, S6
9D000580  7C108620   SEH S0, S0
147:                   short ddF_x = 1;
148:                   short ddF_y = -2 * r;
9D000584  0016B023   SUBU S6, ZERO, S6
9D000588  0016B040   SLL S6, S6, 1
149:                   short x     = 0;
150:                   short y     = r;
151:                 
152:                   while (x<y) {
9D00058C  1A40005F   BLEZ S2, 0x9D00070C
9D000590  7C16B620   SEH S6, S6
9D000594  00009821   ADDU S3, ZERO, ZERO
9D000700  02B2A82A   SLT S5, S5, S2
9D000704  16A0FFB6   BNE S5, ZERO, 0x9D0005E0
9D000708  26730001   ADDIU S3, S3, 1
153:                     if (f >= 0) {
9D0005E0  06000008   BLTZ S0, 0x9D000604
9D0005E4  3271FFFF   ANDI S1, S3, -1
154:                       y--;
9D0005E8  2652FFFF   ADDIU S2, S2, -1
9D0005EC  7C129620   SEH S2, S2
155:                       ddF_y += 2;
9D0005F0  26D60002   ADDIU S6, S6, 2
9D0005F4  32C2FFFF   ANDI V0, S6, -1
9D0005F8  7C02B620   SEH S6, V0
156:                       f     += ddF_y;
9D0005FC  00508021   ADDU S0, V0, S0
9D000600  7C108620   SEH S0, S0
9D000604  26350001   ADDIU S5, S1, 1
9D000608  7C15AE20   SEH S5, S5
9D00060C  0011A040   SLL S4, S1, 1
9D000610  3294FFFF   ANDI S4, S4, -1
9D000614  26820003   ADDIU V0, S4, 3
157:                     }
158:                     x++;
159:                     ddF_x += 2;
160:                     f     += ddF_x;
9D000618  02028021   ADDU S0, S0, V0
161:                 
162:                     if (cornername & 0x1) {
9D000598  30E30001   ANDI V1, A3, 1
9D00059C  AFA30010   SW V1, 16(SP)
9D00061C  8FA30010   LW V1, 16(SP)
9D000620  1060001A   BEQ V1, ZERO, 0x9D00068C
9D000624  7C108620   SEH S0, S0
163:                       tft_drawFastVLine(x0+x, y0-y, 2*y+1+delta, color);
9D0005A0  3084FFFF   ANDI A0, A0, -1
9D0005A4  AFA40018   SW A0, 24(SP)
9D0005A8  30A5FFFF   ANDI A1, A1, -1
9D0005AC  AFA5001C   SW A1, 28(SP)
9D0005B0  3042FFFF   ANDI V0, V0, -1
9D0005B4  AFA20020   SW V0, 32(SP)
9D0005B8  24820001   ADDIU V0, A0, 1
9D0005BC  AFA2002C   SW V0, 44(SP)
9D0005C0  8FA30020   LW V1, 32(SP)
9D0005C4  24630001   ADDIU V1, V1, 1
9D0005C8  AFA30024   SW V1, 36(SP)
9D0005CC  24A2FFFF   ADDIU V0, A1, -1
9D0005D0  AFA20028   SW V0, 40(SP)
9D000628  325EFFFF   ANDI S8, S2, -1
9D00062C  8FA2002C   LW V0, 44(SP)
9D000630  02222021   ADDU A0, S1, V0
9D000634  8FA3001C   LW V1, 28(SP)
9D000638  007E2823   SUBU A1, V1, S8
9D00063C  001E3040   SLL A2, S8, 1
9D000640  8FA20024   LW V0, 36(SP)
9D000644  00463021   ADDU A2, V0, A2
9D000648  7C042620   SEH A0, A0
9D00064C  7C052E20   SEH A1, A1
9D000650  7C063620   SEH A2, A2
9D000654  0F400D54   JAL tft_drawFastVLine
9D000658  02E03821   ADDU A3, S7, ZERO
164:                       tft_drawFastVLine(x0+y, y0-x, 2*x+1+delta, color);
9D00065C  8FA30018   LW V1, 24(SP)
9D000660  03C32021   ADDU A0, S8, V1
9D000664  8FA20028   LW V0, 40(SP)
9D000668  00512823   SUBU A1, V0, S1
9D00066C  8FA30020   LW V1, 32(SP)
9D000670  24660003   ADDIU A2, V1, 3
9D000674  02863021   ADDU A2, S4, A2
9D000678  7C042620   SEH A0, A0
9D00067C  7C052E20   SEH A1, A1
9D000680  7C063620   SEH A2, A2
9D000684  0F400D54   JAL tft_drawFastVLine
9D000688  02E03821   ADDU A3, S7, ZERO
165:                     }
166:                     if (cornername & 0x2) {
9D0005D4  30E70002   ANDI A3, A3, 2
9D0005D8  30E700FF   ANDI A3, A3, 255
9D0005DC  AFA70014   SW A3, 20(SP)
9D00068C  8FA20014   LW V0, 20(SP)
9D000690  5040001C   BEQL V0, ZERO, 0x9D000704
9D000694  02B2A82A   SLT S5, S5, S2
167:                       tft_drawFastVLine(x0-x, y0-y, 2*y+1+delta, color);
9D000698  325EFFFF   ANDI S8, S2, -1
9D00069C  8FA30018   LW V1, 24(SP)
9D0006A0  2464FFFF   ADDIU A0, V1, -1
9D0006A4  00912023   SUBU A0, A0, S1
9D0006A8  8FA2001C   LW V0, 28(SP)
9D0006AC  005E2823   SUBU A1, V0, S8
9D0006B0  001E3040   SLL A2, S8, 1
9D0006B4  8FA30024   LW V1, 36(SP)
9D0006B8  00663021   ADDU A2, V1, A2
9D0006BC  7C042620   SEH A0, A0
9D0006C0  7C052E20   SEH A1, A1
9D0006C4  7C063620   SEH A2, A2
9D0006C8  0F400D54   JAL tft_drawFastVLine
9D0006CC  02E03821   ADDU A3, S7, ZERO
168:                       tft_drawFastVLine(x0-y, y0-x, 2*x+1+delta, color);
9D0006D0  8FA20018   LW V0, 24(SP)
9D0006D4  005E2023   SUBU A0, V0, S8
9D0006D8  8FA30028   LW V1, 40(SP)
9D0006DC  00712823   SUBU A1, V1, S1
9D0006E0  8FA30020   LW V1, 32(SP)
9D0006E4  24620003   ADDIU V0, V1, 3
9D0006E8  02823021   ADDU A2, S4, V0
9D0006EC  7C042620   SEH A0, A0
9D0006F0  7C052E20   SEH A1, A1
9D0006F4  7C063620   SEH A2, A2
9D0006F8  0F400D54   JAL tft_drawFastVLine
9D0006FC  02E03821   ADDU A3, S7, ZERO
169:                     }
170:                   }
171:                 }
9D00070C  8FBF0054   LW RA, 84(SP)
9D000710  8FBE0050   LW S8, 80(SP)
9D000714  8FB7004C   LW S7, 76(SP)
9D000718  8FB60048   LW S6, 72(SP)
9D00071C  8FB50044   LW S5, 68(SP)
9D000720  8FB40040   LW S4, 64(SP)
9D000724  8FB3003C   LW S3, 60(SP)
9D000728  8FB20038   LW S2, 56(SP)
9D00072C  8FB10034   LW S1, 52(SP)
9D000730  8FB00030   LW S0, 48(SP)
9D000734  03E00008   JR RA
9D000738  27BD0058   ADDIU SP, SP, 88
172:                 
173:                 // Bresenham's algorithm - thx wikpedia
174:                 void tft_drawLine(short x0, short y0,
175:                 			    short x1, short y1,
176:                 			    unsigned short color) {
9D00073C  27BDFFC8   ADDIU SP, SP, -56
9D000740  AFBF0034   SW RA, 52(SP)
9D000744  AFBE0030   SW S8, 48(SP)
9D000748  AFB7002C   SW S7, 44(SP)
9D00074C  AFB60028   SW S6, 40(SP)
9D000750  AFB50024   SW S5, 36(SP)
9D000754  AFB40020   SW S4, 32(SP)
9D000758  AFB3001C   SW S3, 28(SP)
9D00075C  AFB20018   SW S2, 24(SP)
9D000760  AFB10014   SW S1, 20(SP)
9D000764  AFB00010   SW S0, 16(SP)
9D000768  7C048620   SEH S0, A0
9D00076C  7C059620   SEH S2, A1
9D000770  7C069E20   SEH S3, A2
9D000774  7C073E20   SEH A3, A3
177:                 /* Draw a straight line from (x0,y0) to (x1,y1) with given color
178:                  * Parameters:
179:                  *      x0: x-coordinate of starting point of line. The x-coordinate of
180:                  *          the top-left of the screen is 0. It increases to the right.
181:                  *      y0: y-coordinate of starting point of line. The y-coordinate of
182:                  *          the top-left of the screen is 0. It increases to the bottom.
183:                  *      x1: x-coordinate of ending point of line. The x-coordinate of
184:                  *          the top-left of the screen is 0. It increases to the right.
185:                  *      y1: y-coordinate of ending point of line. The y-coordinate of
186:                  *          the top-left of the screen is 0. It increases to the bottom.
187:                  *      color: 16-bit color value for line
188:                  */
189:                   short steep = abs(y1 - y0) > abs(x1 - x0);
9D000778  00F2A823   SUBU S5, A3, S2
9D00077C  001517C3   SRA V0, S5, 31
9D000780  0055A826   XOR S5, V0, S5
9D000784  02A2A823   SUBU S5, S5, V0
9D000788  02701823   SUBU V1, S3, S0
9D00078C  000317C3   SRA V0, V1, 31
9D000790  00431826   XOR V1, V0, V1
9D000794  00621823   SUBU V1, V1, V0
9D000798  0075A82A   SLT S5, V1, S5
190:                   if (steep) {
9D00079C  12A00007   BEQ S5, ZERO, 0x9D0007BC
9D0007A0  97B60048   LHU S6, 72(SP)
9D0007A4  02601021   ADDU V0, S3, ZERO
191:                     swap(x0, y0);
9D0007B4  02408021   ADDU S0, S2, ZERO
9D0007B8  00409021   ADDU S2, V0, ZERO
192:                     swap(x1, y1);
9D0007A8  00E09821   ADDU S3, A3, ZERO
9D0007AC  00403821   ADDU A3, V0, ZERO
9D0007B0  02001021   ADDU V0, S0, ZERO
193:                   }
194:                 
195:                   if (x0 > x1) {
9D0007BC  0270102A   SLT V0, S3, S0
9D0007C0  10400008   BEQ V0, ZERO, 0x9D0007E4
9D0007C4  0270B823   SUBU S7, S3, S0
9D0007C8  02401021   ADDU V0, S2, ZERO
196:                     swap(x0, x1);
9D0007D8  02608021   ADDU S0, S3, ZERO
9D0007DC  00409821   ADDU S3, V0, ZERO
197:                     swap(y0, y1);
9D0007CC  00E09021   ADDU S2, A3, ZERO
9D0007D0  00403821   ADDU A3, V0, ZERO
9D0007D4  02001021   ADDU V0, S0, ZERO
198:                   }
199:                 
200:                   short dx, dy;
201:                   dx = x1 - x0;
9D0007E0  0270B823   SUBU S7, S3, S0
9D0007E4  32F7FFFF   ANDI S7, S7, -1
202:                   dy = abs(y1 - y0);
9D0007E8  00F2A023   SUBU S4, A3, S2
9D0007EC  001417C3   SRA V0, S4, 31
9D0007F0  0054A026   XOR S4, V0, S4
9D0007F4  0282A023   SUBU S4, S4, V0
203:                 
204:                   short err = dx / 2;
9D0007F8  7C171620   SEH V0, S7
9D0007FC  00028FC2   SRL S1, V0, 31
9D000800  02228821   ADDU S1, S1, V0
205:                   short ystep;
206:                 
207:                   if (y0 < y1) {
9D000804  0247F02A   SLT S8, S2, A3
208:                     ystep = 1;
9D000808  24020001   ADDIU V0, ZERO, 1
9D00080C  2403FFFF   ADDIU V1, ZERO, -1
9D000810  007E100A   MOVZ V0, V1, S8
9D000814  0040F021   ADDU S8, V0, ZERO
209:                   } else {
210:                     ystep = -1;
211:                   }
212:                 
213:                   for (; x0<=x1; x0++) {
9D000818  0270102A   SLT V0, S3, S0
9D00081C  14400019   BNE V0, ZERO, 0x9D000884
9D000820  00118843   SRA S1, S1, 1
9D000874  7C108620   SEH S0, S0
9D000878  0270102A   SLT V0, S3, S0
9D00087C  1040FFE9   BEQ V0, ZERO, 0x9D000824
9D000880  00000000   NOP
214:                     if (steep) {
9D000824  12A00007   BEQ S5, ZERO, 0x9D000844
9D000828  02002021   ADDU A0, S0, ZERO
215:                       tft_drawPixel(y0, x0, color);
9D00082C  02402021   ADDU A0, S2, ZERO
9D000830  02002821   ADDU A1, S0, ZERO
9D000834  0F400BE1   JAL tft_drawPixel
9D000838  02C03021   ADDU A2, S6, ZERO
9D00083C  0B400215   J 0x9D000854
9D000840  02348823   SUBU S1, S1, S4
216:                     } else {
217:                       tft_drawPixel(x0, y0, color);
9D000844  02402821   ADDU A1, S2, ZERO
9D000848  0F400BE1   JAL tft_drawPixel
9D00084C  02C03021   ADDU A2, S6, ZERO
218:                     }
219:                     err -= dy;
9D000850  02348823   SUBU S1, S1, S4
9D000854  3222FFFF   ANDI V0, S1, -1
9D000858  7C028E20   SEH S1, V0
220:                     if (err < 0) {
9D00085C  06210005   BGEZ S1, 0x9D000874
9D000860  26100001   ADDIU S0, S0, 1
221:                       y0 += ystep;
9D000864  025E9021   ADDU S2, S2, S8
9D000868  7C129620   SEH S2, S2
222:                       err += dx;
9D00086C  00578821   ADDU S1, V0, S7
9D000870  7C118E20   SEH S1, S1
223:                     }
224:                   }
225:                 }
9D000884  8FBF0034   LW RA, 52(SP)
9D000888  8FBE0030   LW S8, 48(SP)
9D00088C  8FB7002C   LW S7, 44(SP)
9D000890  8FB60028   LW S6, 40(SP)
9D000894  8FB50024   LW S5, 36(SP)
9D000898  8FB40020   LW S4, 32(SP)
9D00089C  8FB3001C   LW S3, 28(SP)
9D0008A0  8FB20018   LW S2, 24(SP)
9D0008A4  8FB10014   LW S1, 20(SP)
9D0008A8  8FB00010   LW S0, 16(SP)
9D0008AC  03E00008   JR RA
9D0008B0  27BD0038   ADDIU SP, SP, 56
226:                 
227:                 // Draw a rectangle
228:                 void tft_drawRect(short x, short y, short w, short h, unsigned short color) {
9D0008B4  27BDFFD8   ADDIU SP, SP, -40
9D0008B8  AFBF0024   SW RA, 36(SP)
9D0008BC  AFB40020   SW S4, 32(SP)
9D0008C0  AFB3001C   SW S3, 28(SP)
9D0008C4  AFB20018   SW S2, 24(SP)
9D0008C8  AFB10014   SW S1, 20(SP)
9D0008CC  AFB00010   SW S0, 16(SP)
9D0008D0  7C049620   SEH S2, A0
9D0008D4  7C058E20   SEH S1, A1
9D0008D8  7C06A620   SEH S4, A2
9D0008DC  7C079E20   SEH S3, A3
9D0008E0  97B00038   LHU S0, 56(SP)
229:                 /* Draw a rectangle outline with top left vertex (x,y), width w
230:                  * and height h at given color
231:                  * Parameters:
232:                  *      x:  x-coordinate of top-left vertex. The x-coordinate of
233:                  *          the top-left of the screen is 0. It increases to the right.
234:                  *      y:  y-coordinate of top-left vertex. The y-coordinate of
235:                  *          the top-left of the screen is 0. It increases to the bottom.
236:                  *      w:  width of the rectangle
237:                  *      h:  height of the rectangle
238:                  *      color:  16-bit color of the rectangle outline
239:                  * Returns: Nothing
240:                  */
241:                   tft_drawFastHLine(x, y, w, color);
9D0008E4  02402021   ADDU A0, S2, ZERO
9D0008E8  02202821   ADDU A1, S1, ZERO
9D0008EC  02803021   ADDU A2, S4, ZERO
9D0008F0  0F400D88   JAL tft_drawFastHLine
9D0008F4  02003821   ADDU A3, S0, ZERO
242:                   tft_drawFastHLine(x, y+h-1, w, color);
9D0008F8  2665FFFF   ADDIU A1, S3, -1
9D0008FC  00B12821   ADDU A1, A1, S1
9D000900  02402021   ADDU A0, S2, ZERO
9D000904  7C052E20   SEH A1, A1
9D000908  02803021   ADDU A2, S4, ZERO
9D00090C  0F400D88   JAL tft_drawFastHLine
9D000910  02003821   ADDU A3, S0, ZERO
243:                   tft_drawFastVLine(x, y, h, color);
9D000914  02402021   ADDU A0, S2, ZERO
9D000918  02202821   ADDU A1, S1, ZERO
9D00091C  02603021   ADDU A2, S3, ZERO
9D000920  0F400D54   JAL tft_drawFastVLine
9D000924  02003821   ADDU A3, S0, ZERO
244:                   tft_drawFastVLine(x+w-1, y, h, color);
9D000928  2694FFFF   ADDIU S4, S4, -1
9D00092C  02922021   ADDU A0, S4, S2
9D000930  7C042620   SEH A0, A0
9D000934  02202821   ADDU A1, S1, ZERO
9D000938  02603021   ADDU A2, S3, ZERO
9D00093C  0F400D54   JAL tft_drawFastVLine
9D000940  02003821   ADDU A3, S0, ZERO
245:                 }
9D000944  8FBF0024   LW RA, 36(SP)
9D000948  8FB40020   LW S4, 32(SP)
9D00094C  8FB3001C   LW S3, 28(SP)
9D000950  8FB20018   LW S2, 24(SP)
9D000954  8FB10014   LW S1, 20(SP)
9D000958  8FB00010   LW S0, 16(SP)
9D00095C  03E00008   JR RA
9D000960  27BD0028   ADDIU SP, SP, 40
246:                 
247:                 // Draw a rounded rectangle
248:                 void tft_drawRoundRect(short x, short y, short w, short h,
249:                         short r, unsigned short color) {
9D000964  27BDFFB0   ADDIU SP, SP, -80
9D000968  AFBF004C   SW RA, 76(SP)
9D00096C  AFBE0048   SW S8, 72(SP)
9D000970  AFB70044   SW S7, 68(SP)
9D000974  AFB60040   SW S6, 64(SP)
9D000978  AFB5003C   SW S5, 60(SP)
9D00097C  AFB40038   SW S4, 56(SP)
9D000980  AFB30034   SW S3, 52(SP)
9D000984  AFB20030   SW S2, 48(SP)
9D000988  AFB1002C   SW S1, 44(SP)
9D00098C  AFB00028   SW S0, 40(SP)
9D000990  7C04AE20   SEH S5, A0
9D000994  7C05BE20   SEH S7, A1
9D000998  7C073E20   SEH A3, A3
9D00099C  AFA70018   SW A3, 24(SP)
9D0009A0  87B10060   LH S1, 96(SP)
9D0009A4  97B00064   LHU S0, 100(SP)
250:                 /* Draw a rounded rectangle outline with top left vertex (x,y), width w,
251:                  * height h and radius of curvature r at given color
252:                  * Parameters:
253:                  *      x:  x-coordinate of top-left vertex. The x-coordinate of
254:                  *          the top-left of the screen is 0. It increases to the right.
255:                  *      y:  y-coordinate of top-left vertex. The y-coordinate of
256:                  *          the top-left of the screen is 0. It increases to the bottom.
257:                  *      w:  width of the rectangle
258:                  *      h:  height of the rectangle
259:                  *      color:  16-bit color of the rectangle outline
260:                  * Returns: Nothing
261:                  */
262:                   // smarter version
263:                   tft_drawFastHLine(x+r  , y    , w-2*r, color); // Top
9D0009A8  32A2FFFF   ANDI V0, S5, -1
9D0009AC  AFA2001C   SW V0, 28(SP)
9D0009B0  3232FFFF   ANDI S2, S1, -1
9D0009B4  00529821   ADDU S3, V0, S2
9D0009B8  7C139E20   SEH S3, S3
9D0009BC  0012B023   SUBU S6, ZERO, S2
9D0009C0  0016B040   SLL S6, S6, 1
9D0009C4  32D6FFFF   ANDI S6, S6, -1
9D0009C8  30D4FFFF   ANDI S4, A2, -1
9D0009CC  02D4F021   ADDU S8, S6, S4
9D0009D0  7C1EF620   SEH S8, S8
9D0009D4  02602021   ADDU A0, S3, ZERO
9D0009D8  02E02821   ADDU A1, S7, ZERO
9D0009DC  03C03021   ADDU A2, S8, ZERO
9D0009E0  0F400D88   JAL tft_drawFastHLine
9D0009E4  02003821   ADDU A3, S0, ZERO
264:                   tft_drawFastHLine(x+r  , y+h-1, w-2*r, color); // Bottom
9D0009E8  32F7FFFF   ANDI S7, S7, -1
9D0009EC  8FA30018   LW V1, 24(SP)
9D0009F0  3063FFFF   ANDI V1, V1, -1
9D0009F4  AFA30018   SW V1, 24(SP)
9D0009F8  02E31021   ADDU V0, S7, V1
9D0009FC  2442FFFF   ADDIU V0, V0, -1
9D000A00  3042FFFF   ANDI V0, V0, -1
9D000A04  AFA20020   SW V0, 32(SP)
9D000A08  02602021   ADDU A0, S3, ZERO
9D000A0C  7C022E20   SEH A1, V0
9D000A10  03C03021   ADDU A2, S8, ZERO
9D000A14  0F400D88   JAL tft_drawFastHLine
9D000A18  02003821   ADDU A3, S0, ZERO
265:                   tft_drawFastVLine(x    , y+r  , h-2*r, color); // Left
9D000A1C  0257B821   ADDU S7, S2, S7
9D000A20  7C17BE20   SEH S7, S7
9D000A24  8FA20018   LW V0, 24(SP)
9D000A28  02C2B021   ADDU S6, S6, V0
9D000A2C  7C16B620   SEH S6, S6
9D000A30  02A02021   ADDU A0, S5, ZERO
9D000A34  02E02821   ADDU A1, S7, ZERO
9D000A38  02C03021   ADDU A2, S6, ZERO
9D000A3C  0F400D54   JAL tft_drawFastVLine
9D000A40  02003821   ADDU A3, S0, ZERO
266:                   tft_drawFastVLine(x+w-1, y+r  , h-2*r, color); // Right
9D000A44  8FA3001C   LW V1, 28(SP)
9D000A48  0074A021   ADDU S4, V1, S4
9D000A4C  3294FFFF   ANDI S4, S4, -1
9D000A50  2684FFFF   ADDIU A0, S4, -1
9D000A54  7C042620   SEH A0, A0
9D000A58  02E02821   ADDU A1, S7, ZERO
9D000A5C  02C03021   ADDU A2, S6, ZERO
9D000A60  0F400D54   JAL tft_drawFastVLine
9D000A64  02003821   ADDU A3, S0, ZERO
267:                   // draw four corners
268:                   tft_drawCircleHelper(x+r    , y+r    , r, 1, color);
9D000A68  AFB00010   SW S0, 16(SP)
9D000A6C  02602021   ADDU A0, S3, ZERO
9D000A70  02E02821   ADDU A1, S7, ZERO
9D000A74  02203021   ADDU A2, S1, ZERO
9D000A78  0F400098   JAL tft_drawCircleHelper
9D000A7C  24070001   ADDIU A3, ZERO, 1
269:                   tft_drawCircleHelper(x+w-r-1, y+r    , r, 2, color);
9D000A80  00121027   NOR V0, ZERO, S2
9D000A84  0282A021   ADDU S4, S4, V0
9D000A88  7C14A620   SEH S4, S4
9D000A8C  AFB00010   SW S0, 16(SP)
9D000A90  02802021   ADDU A0, S4, ZERO
9D000A94  02E02821   ADDU A1, S7, ZERO
9D000A98  02203021   ADDU A2, S1, ZERO
9D000A9C  0F400098   JAL tft_drawCircleHelper
9D000AA0  24070002   ADDIU A3, ZERO, 2
270:                   tft_drawCircleHelper(x+w-r-1, y+h-r-1, r, 4, color);
9D000AA4  8FA20020   LW V0, 32(SP)
9D000AA8  00529023   SUBU S2, V0, S2
9D000AAC  7C129620   SEH S2, S2
9D000AB0  AFB00010   SW S0, 16(SP)
9D000AB4  02802021   ADDU A0, S4, ZERO
9D000AB8  02402821   ADDU A1, S2, ZERO
9D000ABC  02203021   ADDU A2, S1, ZERO
9D000AC0  0F400098   JAL tft_drawCircleHelper
9D000AC4  24070004   ADDIU A3, ZERO, 4
271:                   tft_drawCircleHelper(x+r    , y+h-r-1, r, 8, color);
9D000AC8  AFB00010   SW S0, 16(SP)
9D000ACC  02602021   ADDU A0, S3, ZERO
9D000AD0  02402821   ADDU A1, S2, ZERO
9D000AD4  02203021   ADDU A2, S1, ZERO
9D000AD8  0F400098   JAL tft_drawCircleHelper
9D000ADC  24070008   ADDIU A3, ZERO, 8
272:                 }
9D000AE0  8FBF004C   LW RA, 76(SP)
9D000AE4  8FBE0048   LW S8, 72(SP)
9D000AE8  8FB70044   LW S7, 68(SP)
9D000AEC  8FB60040   LW S6, 64(SP)
9D000AF0  8FB5003C   LW S5, 60(SP)
9D000AF4  8FB40038   LW S4, 56(SP)
9D000AF8  8FB30034   LW S3, 52(SP)
9D000AFC  8FB20030   LW S2, 48(SP)
9D000B00  8FB1002C   LW S1, 44(SP)
9D000B04  8FB00028   LW S0, 40(SP)
9D000B08  03E00008   JR RA
9D000B0C  27BD0050   ADDIU SP, SP, 80
273:                 
274:                 // Fill a rounded rectangle
275:                 void tft_fillRoundRect(short x, short y, short w,
276:                 				 short h, short r, unsigned short color) {
9D000B10  27BDFFC0   ADDIU SP, SP, -64
9D000B14  AFBF003C   SW RA, 60(SP)
9D000B18  AFBE0038   SW S8, 56(SP)
9D000B1C  AFB70034   SW S7, 52(SP)
9D000B20  AFB60030   SW S6, 48(SP)
9D000B24  AFB5002C   SW S5, 44(SP)
9D000B28  AFB40028   SW S4, 40(SP)
9D000B2C  AFB30024   SW S3, 36(SP)
9D000B30  AFB20020   SW S2, 32(SP)
9D000B34  AFB1001C   SW S1, 28(SP)
9D000B38  AFB00018   SW S0, 24(SP)
9D000B3C  7C059E20   SEH S3, A1
9D000B40  7C07AE20   SEH S5, A3
9D000B44  87B10050   LH S1, 80(SP)
9D000B48  97B20054   LHU S2, 84(SP)
277:                   // smarter version
278:                   tft_fillRect(x+r, y, w-2*r, h, color);
9D000B4C  3096FFFF   ANDI S6, A0, -1
9D000B50  3230FFFF   ANDI S0, S1, -1
9D000B54  02D0A021   ADDU S4, S6, S0
9D000B58  7C14A620   SEH S4, S4
9D000B5C  0010F023   SUBU S8, ZERO, S0
9D000B60  001EF040   SLL S8, S8, 1
9D000B64  33DEFFFF   ANDI S8, S8, -1
9D000B68  30D7FFFF   ANDI S7, A2, -1
9D000B6C  03D73021   ADDU A2, S8, S7
9D000B70  AFB20010   SW S2, 16(SP)
9D000B74  02802021   ADDU A0, S4, ZERO
9D000B78  02602821   ADDU A1, S3, ZERO
9D000B7C  7C063620   SEH A2, A2
9D000B80  0F400DC8   JAL tft_fillRect
9D000B84  02A03821   ADDU A3, S5, ZERO
279:                 
280:                   // draw four corners
281:                   tft_fillCircleHelper(x+w-r-1, y+r, r, 1, h-2*r-1, color);
9D000B88  02139821   ADDU S3, S0, S3
9D000B8C  7C139E20   SEH S3, S3
9D000B90  26B5FFFF   ADDIU S5, S5, -1
9D000B94  03D5A821   ADDU S5, S8, S5
9D000B98  7C15AE20   SEH S5, S5
9D000B9C  26F7FFFF   ADDIU S7, S7, -1
9D000BA0  02D7B021   ADDU S6, S6, S7
9D000BA4  02D02023   SUBU A0, S6, S0
9D000BA8  AFB50010   SW S5, 16(SP)
9D000BAC  AFB20014   SW S2, 20(SP)
9D000BB0  7C042620   SEH A0, A0
9D000BB4  02602821   ADDU A1, S3, ZERO
9D000BB8  02203021   ADDU A2, S1, ZERO
9D000BBC  0F40014C   JAL tft_fillCircleHelper
9D000BC0  24070001   ADDIU A3, ZERO, 1
282:                   tft_fillCircleHelper(x+r    , y+r, r, 2, h-2*r-1, color);
9D000BC4  AFB50010   SW S5, 16(SP)
9D000BC8  AFB20014   SW S2, 20(SP)
9D000BCC  02802021   ADDU A0, S4, ZERO
9D000BD0  02602821   ADDU A1, S3, ZERO
9D000BD4  02203021   ADDU A2, S1, ZERO
9D000BD8  0F40014C   JAL tft_fillCircleHelper
9D000BDC  24070002   ADDIU A3, ZERO, 2
283:                 }
9D000BE0  8FBF003C   LW RA, 60(SP)
9D000BE4  8FBE0038   LW S8, 56(SP)
9D000BE8  8FB70034   LW S7, 52(SP)
9D000BEC  8FB60030   LW S6, 48(SP)
9D000BF0  8FB5002C   LW S5, 44(SP)
9D000BF4  8FB40028   LW S4, 40(SP)
9D000BF8  8FB30024   LW S3, 36(SP)
9D000BFC  8FB20020   LW S2, 32(SP)
9D000C00  8FB1001C   LW S1, 28(SP)
9D000C04  8FB00018   LW S0, 24(SP)
9D000C08  03E00008   JR RA
9D000C0C  27BD0040   ADDIU SP, SP, 64
284:                 
285:                 // Draw a triangle
286:                 void tft_drawTriangle(short x0, short y0,
287:                 				short x1, short y1,
288:                 				short x2, short y2, unsigned short color) {
9D000C10  27BDFFC8   ADDIU SP, SP, -56
9D000C14  AFBF0034   SW RA, 52(SP)
9D000C18  AFB60030   SW S6, 48(SP)
9D000C1C  AFB5002C   SW S5, 44(SP)
9D000C20  AFB40028   SW S4, 40(SP)
9D000C24  AFB30024   SW S3, 36(SP)
9D000C28  AFB20020   SW S2, 32(SP)
9D000C2C  AFB1001C   SW S1, 28(SP)
9D000C30  AFB00018   SW S0, 24(SP)
9D000C34  7C049620   SEH S2, A0
9D000C38  7C058E20   SEH S1, A1
9D000C3C  7C06B620   SEH S6, A2
9D000C40  7C07AE20   SEH S5, A3
9D000C44  87B40048   LH S4, 72(SP)
9D000C48  87B3004C   LH S3, 76(SP)
9D000C4C  97B00050   LHU S0, 80(SP)
289:                 /* Draw a triangle outline with vertices (x0,y0),(x1,y1),(x2,y2) with given color
290:                  * Parameters:
291:                  *      x0: x-coordinate of one of the 3 vertices
292:                  *      y0: y-coordinate of one of the 3 vertices
293:                  *      x1: x-coordinate of one of the 3 vertices
294:                  *      y1: y-coordinate of one of the 3 vertices
295:                  *      x2: x-coordinate of one of the 3 vertices
296:                  *      y2: y-coordinate of one of the 3 vertices
297:                  *      color: 16-bit color value for outline
298:                  * Returns: Nothing
299:                  */
300:                   tft_drawLine(x0, y0, x1, y1, color);
9D000C50  AFB00010   SW S0, 16(SP)
9D000C54  02402021   ADDU A0, S2, ZERO
9D000C58  02202821   ADDU A1, S1, ZERO
9D000C5C  02C03021   ADDU A2, S6, ZERO
9D000C60  0F4001CF   JAL tft_drawLine
9D000C64  02A03821   ADDU A3, S5, ZERO
301:                   tft_drawLine(x1, y1, x2, y2, color);
9D000C68  AFB00010   SW S0, 16(SP)
9D000C6C  02C02021   ADDU A0, S6, ZERO
9D000C70  02A02821   ADDU A1, S5, ZERO
9D000C74  02803021   ADDU A2, S4, ZERO
9D000C78  0F4001CF   JAL tft_drawLine
9D000C7C  02603821   ADDU A3, S3, ZERO
302:                   tft_drawLine(x2, y2, x0, y0, color);
9D000C80  AFB00010   SW S0, 16(SP)
9D000C84  02802021   ADDU A0, S4, ZERO
9D000C88  02602821   ADDU A1, S3, ZERO
9D000C8C  02403021   ADDU A2, S2, ZERO
9D000C90  0F4001CF   JAL tft_drawLine
9D000C94  02203821   ADDU A3, S1, ZERO
303:                 }
9D000C98  8FBF0034   LW RA, 52(SP)
9D000C9C  8FB60030   LW S6, 48(SP)
9D000CA0  8FB5002C   LW S5, 44(SP)
9D000CA4  8FB40028   LW S4, 40(SP)
9D000CA8  8FB30024   LW S3, 36(SP)
9D000CAC  8FB20020   LW S2, 32(SP)
9D000CB0  8FB1001C   LW S1, 28(SP)
9D000CB4  8FB00018   LW S0, 24(SP)
9D000CB8  03E00008   JR RA
9D000CBC  27BD0038   ADDIU SP, SP, 56
304:                 
305:                 // Fill a triangle
306:                 void tft_fillTriangle ( short x0, short y0,
307:                 				  short x1, short y1,
308:                 				  short x2, short y2, unsigned short color) {
9D000CC0  27BDFFA8   ADDIU SP, SP, -88
9D000CC4  AFBF0054   SW RA, 84(SP)
9D000CC8  AFBE0050   SW S8, 80(SP)
9D000CCC  AFB7004C   SW S7, 76(SP)
9D000CD0  AFB60048   SW S6, 72(SP)
9D000CD4  AFB50044   SW S5, 68(SP)
9D000CD8  AFB40040   SW S4, 64(SP)
9D000CDC  AFB3003C   SW S3, 60(SP)
9D000CE0  AFB20038   SW S2, 56(SP)
9D000CE4  AFB10034   SW S1, 52(SP)
9D000CE8  AFB00030   SW S0, 48(SP)
9D000CEC  7C04A620   SEH S4, A0
9D000CF0  7C052E20   SEH A1, A1
9D000CF4  AFA5001C   SW A1, 28(SP)
9D000CF8  7C063620   SEH A2, A2
9D000CFC  7C07F620   SEH S8, A3
9D000D00  87A40068   LH A0, 104(SP)
9D000D04  87B7006C   LH S7, 108(SP)
309:                 /* Draw a filled triangle with vertices (x0,y0),(x1,y1),(x2,y2) with given color
310:                  * Parameters:
311:                  *      x0: x-coordinate of one of the 3 vertices
312:                  *      y0: y-coordinate of one of the 3 vertices
313:                  *      x1: x-coordinate of one of the 3 vertices
314:                  *      y1: y-coordinate of one of the 3 vertices
315:                  *      x2: x-coordinate of one of the 3 vertices
316:                  *      y2: y-coordinate of one of the 3 vertices
317:                  *      color: 16-bit color value
318:                  * Returns: Nothing
319:                  */
320:                   short a, b, y, last;
321:                 
322:                   // Sort coordinates by Y order (y2 >= y1 >= y0)
323:                   if (y0 > y1) {
9D000D08  03C5102A   SLT V0, S8, A1
9D000D0C  10400006   BEQ V0, ZERO, 0x9D000D28
9D000D10  97B60070   LHU S6, 112(SP)
324:                     swap(y0, y1); swap(x0, x1);
9D000D14  AFBE001C   SW S8, 28(SP)
9D000D18  00A0F021   ADDU S8, A1, ZERO
9D000D1C  02801021   ADDU V0, S4, ZERO
9D000D20  00C0A021   ADDU S4, A2, ZERO
9D000D24  00403021   ADDU A2, V0, ZERO
325:                   }
326:                   if (y1 > y2) {
9D000D28  02FE102A   SLT V0, S7, S8
9D000D2C  10400007   BEQ V0, ZERO, 0x9D000D4C
9D000D30  8FA3001C   LW V1, 28(SP)
9D000D34  03C01021   ADDU V0, S8, ZERO
327:                     swap(y2, y1); swap(x2, x1);
9D000D38  02E0F021   ADDU S8, S7, ZERO
9D000D3C  0040B821   ADDU S7, V0, ZERO
9D000D40  00C01021   ADDU V0, A2, ZERO
9D000D44  00803021   ADDU A2, A0, ZERO
9D000D48  00402021   ADDU A0, V0, ZERO
328:                   }
329:                   if (y0 > y1) {
9D000D4C  03C3102A   SLT V0, S8, V1
9D000D50  10400007   BEQ V0, ZERO, 0x9D000D70
9D000D54  8FA5001C   LW A1, 28(SP)
330:                     swap(y0, y1); swap(x0, x1);
9D000D58  AFBE001C   SW S8, 28(SP)
9D000D5C  0060F021   ADDU S8, V1, ZERO
9D000D60  02801021   ADDU V0, S4, ZERO
9D000D64  00C0A021   ADDU S4, A2, ZERO
9D000D68  00403021   ADDU A2, V0, ZERO
331:                   }
332:                 
333:                   if(y0 == y2) { // Handle awkward all-on-same-line case as its own thing
9D000D6C  8FA5001C   LW A1, 28(SP)
9D000D70  54B7001A   BNEL A1, S7, 0x9D000DDC
9D000D74  30C6FFFF   ANDI A2, A2, -1
334:                     a = b = x0;
9D000D94  02803021   ADDU A2, S4, ZERO
9D000D98  7C02A620   SEH S4, V0
335:                     if(x1 < a)      a = x1;
9D000D78  00D4102A   SLT V0, A2, S4
9D000D7C  14400008   BNE V0, ZERO, 0x9D000DA0
9D000D80  0086102A   SLT V0, A0, A2
9D000D84  00C01021   ADDU V0, A2, ZERO
9D000D88  00D4302A   SLT A2, A2, S4
9D000D8C  54C00001   BNEL A2, ZERO, 0x9D000D94
9D000D90  02801021   ADDU V0, S4, ZERO
336:                     else if(x1 > b) b = x1;
337:                     if(x2 < a)      a = x2;
9D000D9C  0086102A   SLT V0, A0, A2
9D000DA0  14400006   BNE V0, ZERO, 0x9D000DBC
9D000DA4  02801021   ADDU V0, S4, ZERO
9D000DA8  0284A02A   SLT S4, S4, A0
9D000DAC  56800001   BNEL S4, ZERO, 0x9D000DB4
9D000DB0  00801021   ADDU V0, A0, ZERO
9D000DB4  7C02A620   SEH S4, V0
9D000DB8  00C02021   ADDU A0, A2, ZERO
338:                     else if(x2 > b) b = x2;
339:                     tft_drawFastHLine(a, y0, b-a+1, color);
9D000DBC  26940001   ADDIU S4, S4, 1
9D000DC0  02843023   SUBU A2, S4, A0
9D000DC4  8FA5001C   LW A1, 28(SP)
9D000DC8  7C063620   SEH A2, A2
9D000DCC  0F400D88   JAL tft_drawFastHLine
9D000DD0  02C03821   ADDU A3, S6, ZERO
340:                     return;
9D000DD4  0B4003EB   J 0x9D000FAC
9D000DD8  8FBF0054   LW RA, 84(SP)
341:                   }
342:                 
343:                   short
344:                     dx01 = x1 - x0,
9D000DDC  AFA60018   SW A2, 24(SP)
9D000DE0  3294FFFF   ANDI S4, S4, -1
9D000DE4  00D41023   SUBU V0, A2, S4
9D000DE8  3042FFFF   ANDI V0, V0, -1
9D000DEC  AFA20028   SW V0, 40(SP)
345:                     dy01 = y1 - y0,
9D000DF0  33C2FFFF   ANDI V0, S8, -1
9D000DF4  8FA3001C   LW V1, 28(SP)
9D000DF8  3071FFFF   ANDI S1, V1, -1
9D000DFC  00511823   SUBU V1, V0, S1
9D000E00  7C031E20   SEH V1, V1
9D000E04  AFA30010   SW V1, 16(SP)
346:                     dx02 = x2 - x0,
9D000E08  3084FFFF   ANDI A0, A0, -1
9D000E0C  0094A823   SUBU S5, A0, S4
9D000E10  32B5FFFF   ANDI S5, S5, -1
347:                     dy02 = y2 - y0,
9D000E14  32E3FFFF   ANDI V1, S7, -1
9D000E18  00718823   SUBU S1, V1, S1
9D000E1C  7C118E20   SEH S1, S1
348:                     dx12 = x2 - x1,
9D000E20  00862023   SUBU A0, A0, A2
9D000E24  3084FFFF   ANDI A0, A0, -1
9D000E28  AFA40020   SW A0, 32(SP)
349:                     dy12 = y2 - y1,
9D000E2C  00621823   SUBU V1, V1, V0
9D000E30  7C031E20   SEH V1, V1
350:                     sa   = 0,
9D000E68  00009021   ADDU S2, ZERO, ZERO
351:                     sb   = 0;
9D000E64  00009821   ADDU S3, ZERO, ZERO
352:                 
353:                   // For upper part of triangle, find scanline crossings for segments
354:                   // 0-1 and 0-2.  If y1=y2 (flat-bottomed triangle), the scanline y1
355:                   // is included here (and second loop will be skipped, avoiding a /0
356:                   // error there), otherwise scanline y1 is skipped here and handled
357:                   // in the second loop...which also avoids a /0 error here if y0=y1
358:                   // (flat-topped triangle).
359:                   if(y1 == y2) last = y1;   // Include y1 scanline
9D000E34  13D70005   BEQ S8, S7, 0x9D000E4C
9D000E38  AFA30014   SW V1, 20(SP)
9D000E4C  AFBE0024   SW S8, 36(SP)
360:                   else         last = y1-1; // Skip it
9D000E3C  2442FFFF   ADDIU V0, V0, -1
9D000E40  7C021620   SEH V0, V0
9D000E44  0B400394   J 0x9D000E50
9D000E48  AFA20024   SW V0, 36(SP)
361:                 
362:                   for(y=y0; y<=last; y++) {
9D000E50  8FA4001C   LW A0, 28(SP)
9D000E54  8FA50024   LW A1, 36(SP)
9D000E58  00A4102A   SLT V0, A1, A0
9D000E5C  14400026   BNE V0, ZERO, 0x9D000EF8
9D000E60  00808021   ADDU S0, A0, ZERO
9D000ED8  26100001   ADDIU S0, S0, 1
9D000EDC  7C108620   SEH S0, S0
9D000EE0  8FA40024   LW A0, 36(SP)
9D000EE4  0090102A   SLT V0, A0, S0
9D000EE8  1040FFE1   BEQ V0, ZERO, 0x9D000E70
9D000EEC  8FA40010   LW A0, 16(SP)
9D000EF0  0B4003C0   J 0x9D000F00
9D000EF4  021E9023   SUBU S2, S0, S8
9D000EF8  8FB0001C   LW S0, 28(SP)
363:                     a   = x0 + sa / dy01;
9D000E6C  8FA40010   LW A0, 16(SP)
9D000E70  0244001A   DIV S2, A0
9D000E74  008001F4   TEQ A0, ZERO
9D000E78  00001012   MFLO V0, 0
9D000E7C  02821021   ADDU V0, S4, V0
9D000E80  7C021620   SEH V0, V0
9D000EB8  00402021   ADDU A0, V0, ZERO
364:                     b   = x0 + sb / dy02;
9D000E84  0271001A   DIV S3, S1
9D000E88  022001F4   TEQ S1, ZERO
9D000E8C  00002012   MFLO A0, 0
9D000E90  02842021   ADDU A0, S4, A0
9D000E94  7C042620   SEH A0, A0
9D000E98  8FA30028   LW V1, 40(SP)
9D000E9C  00729021   ADDU S2, V1, S2
9D000EA0  7C129620   SEH S2, S2
9D000EA4  02B39821   ADDU S3, S5, S3
9D000EBC  00601021   ADDU V0, V1, ZERO
365:                     sa += dx01;
366:                     sb += dx02;
367:                     /* longhand:
368:                     a = x0 + (x1 - x0) * (y - y0) / (y1 - y0);
369:                     b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
370:                     */
371:                     if(a > b) swap(a,b);
9D000EA8  0082182A   SLT V1, A0, V0
9D000EAC  14600004   BNE V1, ZERO, 0x9D000EC0
9D000EB0  7C139E20   SEH S3, S3
9D000EB4  00801821   ADDU V1, A0, ZERO
372:                     tft_drawFastHLine(a, y, b-a+1, color);
9D000EC0  24420001   ADDIU V0, V0, 1
9D000EC4  00443023   SUBU A2, V0, A0
9D000EC8  02002821   ADDU A1, S0, ZERO
9D000ECC  7C063620   SEH A2, A2
9D000ED0  0F400D88   JAL tft_drawFastHLine
9D000ED4  02C03821   ADDU A3, S6, ZERO
373:                   }
374:                 
375:                   // For lower part of triangle, find scanline crossings for segments
376:                   // 0-2 and 1-2.  This loop is skipped if y1=y2.
377:                   sa = dx12 * (y - y1);
9D000EFC  021E9023   SUBU S2, S0, S8
9D000F00  8FA20020   LW V0, 32(SP)
9D000F04  70529002   MUL S2, V0, S2
9D000F08  7C129620   SEH S2, S2
378:                   sb = dx02 * (y - y0);
9D000F0C  8FA3001C   LW V1, 28(SP)
9D000F10  0203F023   SUBU S8, S0, V1
9D000F14  72BEF002   MUL S8, S5, S8
379:                   for(; y<=y2; y++) {
9D000F18  02F0102A   SLT V0, S7, S0
9D000F1C  14400022   BNE V0, ZERO, 0x9D000FA8
9D000F20  7C1EF620   SEH S8, S8
9D000F94  26100001   ADDIU S0, S0, 1
9D000F98  7C108620   SEH S0, S0
9D000F9C  02F0102A   SLT V0, S7, S0
9D000FA0  1040FFE1   BEQ V0, ZERO, 0x9D000F28
9D000FA4  8FA40014   LW A0, 20(SP)
380:                     a   = x1 + sa / dy12;
9D000F24  8FA40014   LW A0, 20(SP)
9D000F28  0244001A   DIV S2, A0
9D000F2C  008001F4   TEQ A0, ZERO
9D000F30  00001012   MFLO V0, 0
9D000F34  8FA50018   LW A1, 24(SP)
9D000F38  00A21021   ADDU V0, A1, V0
9D000F3C  7C021620   SEH V0, V0
9D000F74  00402021   ADDU A0, V0, ZERO
381:                     b   = x0 + sb / dy02;
9D000F40  03D1001A   DIV S8, S1
9D000F44  022001F4   TEQ S1, ZERO
9D000F48  00002012   MFLO A0, 0
9D000F4C  02842021   ADDU A0, S4, A0
9D000F50  7C042620   SEH A0, A0
9D000F54  8FA30020   LW V1, 32(SP)
9D000F58  00729021   ADDU S2, V1, S2
9D000F5C  7C129620   SEH S2, S2
9D000F60  02BEF021   ADDU S8, S5, S8
9D000F78  00601021   ADDU V0, V1, ZERO
382:                     sa += dx12;
383:                     sb += dx02;
384:                     /* longhand:
385:                     a = x1 + (x2 - x1) * (y - y1) / (y2 - y1);
386:                     b = x0 + (x2 - x0) * (y - y0) / (y2 - y0);
387:                     */
388:                     if(a > b) swap(a,b);
9D000F64  0082182A   SLT V1, A0, V0
9D000F68  14600004   BNE V1, ZERO, 0x9D000F7C
9D000F6C  7C1EF620   SEH S8, S8
9D000F70  00801821   ADDU V1, A0, ZERO
389:                     tft_drawFastHLine(a, y, b-a+1, color);
9D000F7C  24420001   ADDIU V0, V0, 1
9D000F80  00443023   SUBU A2, V0, A0
9D000F84  02002821   ADDU A1, S0, ZERO
9D000F88  7C063620   SEH A2, A2
9D000F8C  0F400D88   JAL tft_drawFastHLine
9D000F90  02C03821   ADDU A3, S6, ZERO
390:                   }
391:                 }
9D000FA8  8FBF0054   LW RA, 84(SP)
9D000FAC  8FBE0050   LW S8, 80(SP)
9D000FB0  8FB7004C   LW S7, 76(SP)
9D000FB4  8FB60048   LW S6, 72(SP)
9D000FB8  8FB50044   LW S5, 68(SP)
9D000FBC  8FB40040   LW S4, 64(SP)
9D000FC0  8FB3003C   LW S3, 60(SP)
9D000FC4  8FB20038   LW S2, 56(SP)
9D000FC8  8FB10034   LW S1, 52(SP)
9D000FCC  8FB00030   LW S0, 48(SP)
9D000FD0  03E00008   JR RA
9D000FD4  27BD0058   ADDIU SP, SP, 88
392:                 
393:                 void tft_drawBitmap(short x, short y,
394:                 			      const unsigned char *bitmap, short w, short h,
395:                 			      unsigned short color) {
9D000FD8  27BDFFC0   ADDIU SP, SP, -64
9D000FDC  AFBF003C   SW RA, 60(SP)
9D000FE0  AFBE0038   SW S8, 56(SP)
9D000FE4  AFB70034   SW S7, 52(SP)
9D000FE8  AFB60030   SW S6, 48(SP)
9D000FEC  AFB5002C   SW S5, 44(SP)
9D000FF0  AFB40028   SW S4, 40(SP)
9D000FF4  AFB30024   SW S3, 36(SP)
9D000FF8  AFB20020   SW S2, 32(SP)
9D000FFC  AFB1001C   SW S1, 28(SP)
9D001000  AFB00018   SW S0, 24(SP)
9D001004  AFA60048   SW A2, 72(SP)
9D001008  7C04B620   SEH S6, A0
9D00100C  7C052E20   SEH A1, A1
9D001010  7C078E20   SEH S1, A3
9D001014  87A20050   LH V0, 80(SP)
9D001018  97B70054   LHU S7, 84(SP)
396:                 
397:                   short i, j, byteWidth = (w + 7) / 8;
9D00101C  26230007   ADDIU V1, S1, 7
9D001020  2624000E   ADDIU A0, S1, 14
9D001024  28660000   SLTI A2, V1, 0
9D001028  0086180B   MOVN V1, A0, A2
398:                 
399:                   for(j=0; j<h; j++) {
9D00102C  1840002B   BLEZ V0, 0x9D0010DC
9D001030  000318C3   SRA V1, V1, 3
9D001034  AFA30010   SW V1, 16(SP)
9D001038  30B4FFFF   ANDI S4, A1, -1
9D00103C  02821021   ADDU V0, S4, V0
9D001040  3042FFFF   ANDI V0, V0, -1
9D001044  AFA20014   SW V0, 20(SP)
9D001048  0000F021   ADDU S8, ZERO, ZERO
9D0010B8  8FA20014   LW V0, 20(SP)
9D0010BC  12820008   BEQ S4, V0, 0x9D0010E0
9D0010C0  8FBF003C   LW RA, 60(SP)
400:                     for(i=0; i<w; i++ ) {
9D001098  26100001   ADDIU S0, S0, 1
9D00109C  7C108620   SEH S0, S0
9D0010A0  1611FFED   BNE S0, S1, 0x9D001058
9D0010A4  3202FFFF   ANDI V0, S0, -1
9D0010A8  8FA20010   LW V0, 16(SP)
9D0010AC  03C2F021   ADDU S8, S8, V0
9D0010B0  26940001   ADDIU S4, S4, 1
9D0010B4  3294FFFF   ANDI S4, S4, -1
9D0010C4  1A20FFF8   BLEZ S1, 0x9D0010A8
9D0010C8  8FA20048   LW V0, 72(SP)
9D0010CC  00008021   ADDU S0, ZERO, ZERO
401:                       if(pgm_read_byte(bitmap + j * byteWidth + i / 8) & (128 >> (i & 7))) {
9D00104C  0B400431   J 0x9D0010C4
9D001050  24130080   ADDIU S3, ZERO, 128
9D001054  3202FFFF   ANDI V0, S0, -1
9D001058  26030007   ADDIU V1, S0, 7
9D00105C  2A040000   SLTI A0, S0, 0
9D001060  0204180A   MOVZ V1, S0, A0
9D001064  000318C3   SRA V1, V1, 3
9D001068  02431821   ADDU V1, S2, V1
9D00106C  90640000   LBU A0, 0(V1)
9D001070  30430007   ANDI V1, V0, 7
9D001074  00731807   SRAV V1, S3, V1
9D001078  00831824   AND V1, A0, V1
9D00107C  50600007   BEQL V1, ZERO, 0x9D00109C
9D001080  26100001   ADDIU S0, S0, 1
9D001084  00562021   ADDU A0, V0, S6
9D0010D0  005E9021   ADDU S2, V0, S8
402:                 	tft_drawPixel(x+i, y+j, color);
9D001088  7C042620   SEH A0, A0
9D00108C  02A02821   ADDU A1, S5, ZERO
9D001090  0F400BE1   JAL tft_drawPixel
9D001094  02E03021   ADDU A2, S7, ZERO
9D0010D4  0B400415   J 0x9D001054
9D0010D8  7C14AE20   SEH S5, S4
403:                       }
404:                     }
405:                   }
406:                 }
9D0010DC  8FBF003C   LW RA, 60(SP)
9D0010E0  8FBE0038   LW S8, 56(SP)
9D0010E4  8FB70034   LW S7, 52(SP)
9D0010E8  8FB60030   LW S6, 48(SP)
9D0010EC  8FB5002C   LW S5, 44(SP)
9D0010F0  8FB40028   LW S4, 40(SP)
9D0010F4  8FB30024   LW S3, 36(SP)
9D0010F8  8FB20020   LW S2, 32(SP)
9D0010FC  8FB1001C   LW S1, 28(SP)
9D001100  8FB00018   LW S0, 24(SP)
9D001104  03E00008   JR RA
9D001108  27BD0040   ADDIU SP, SP, 64
407:                 
408:                 void tft_write(unsigned char c){
9D00110C  27BDFFE0   ADDIU SP, SP, -32
9D001110  308600FF   ANDI A2, A0, 255
409:                   if (c == '\n') {
9D001114  2402000A   ADDIU V0, ZERO, 10
9D001118  14C20008   BNE A2, V0, 0x9D00113C
9D00111C  AFBF001C   SW RA, 28(SP)
410:                     cursor_y += textsize*8;
9D001120  97828076   LHU V0, -32650(GP)
9D001124  000210C0   SLL V0, V0, 3
9D001128  9783806C   LHU V1, -32660(GP)
9D00112C  00431021   ADDU V0, V0, V1
9D001130  A782806C   SH V0, -32660(GP)
9D001134  0B400478   J 0x9D0011E0
9D001138  A7808072   SH ZERO, -32654(GP)
411:                     cursor_x  = 0;
412:                   } else if (c == '\r') {
9D00113C  2402000D   ADDIU V0, ZERO, 13
9D001140  10C20027   BEQ A2, V0, 0x9D0011E0
9D001144  24020009   ADDIU V0, ZERO, 9
413:                     // skip em
414:                   } else if (c == '\t'){
9D001148  14C20009   BNE A2, V0, 0x9D001170
9D00114C  87848072   LH A0, -32654(GP)
415:                       int new_x = cursor_x + tabspace;
9D001150  97828072   LHU V0, -32654(GP)
9D001154  24420004   ADDIU V0, V0, 4
416:                       if (new_x < _width){
9D001158  97838070   LHU V1, -32656(GP)
9D00115C  0043182A   SLT V1, V0, V1
9D001160  5460001F   BNEL V1, ZERO, 0x9D0011E0
9D001164  A7828072   SH V0, -32654(GP)
417:                           cursor_x = new_x;
418:                       }
419:                   } else {
420:                     tft_drawChar(cursor_x, cursor_y, c, textcolor, textbgcolor, textsize);
9D001170  8785806C   LH A1, -32660(GP)
9D001174  9787807C   LHU A3, -32644(GP)
9D001178  9782807A   LHU V0, -32646(GP)
9D00117C  AFA20010   SW V0, 16(SP)
9D001180  93828076   LBU V0, -32650(GP)
9D001184  0F40048C   JAL tft_drawChar
9D001188  AFA20014   SW V0, 20(SP)
421:                     cursor_x += textsize*6;
9D00118C  97828076   LHU V0, -32650(GP)
9D001190  00021840   SLL V1, V0, 1
9D001194  00032080   SLL A0, V1, 2
9D001198  00831823   SUBU V1, A0, V1
9D00119C  97848072   LHU A0, -32654(GP)
9D0011A0  00641821   ADDU V1, V1, A0
9D0011A4  3063FFFF   ANDI V1, V1, -1
9D0011A8  A7838072   SH V1, -32654(GP)
422:                     if (wrap && (cursor_x > (_width - textsize*6))) {
9D0011AC  97848074   LHU A0, -32652(GP)
9D0011B0  1080000B   BEQ A0, ZERO, 0x9D0011E0
9D0011B4  97858070   LHU A1, -32656(GP)
9D0011B8  00022040   SLL A0, V0, 1
9D0011BC  000230C0   SLL A2, V0, 3
9D0011C0  00862023   SUBU A0, A0, A2
9D0011C4  00A42021   ADDU A0, A1, A0
9D0011C8  0083182A   SLT V1, A0, V1
9D0011CC  10600004   BEQ V1, ZERO, 0x9D0011E0
9D0011D0  9783806C   LHU V1, -32660(GP)
423:                       cursor_y += textsize*8;
9D0011D4  00C31021   ADDU V0, A2, V1
9D0011D8  A782806C   SH V0, -32660(GP)
424:                       cursor_x = 0;
9D0011DC  A7808072   SH ZERO, -32654(GP)
425:                     }
426:                   }
427:                 }
9D001168  0B400479   J 0x9D0011E4
9D00116C  8FBF001C   LW RA, 28(SP)
9D0011E0  8FBF001C   LW RA, 28(SP)
9D0011E4  03E00008   JR RA
9D0011E8  27BD0020   ADDIU SP, SP, 32
428:                 
429:                 inline void tft_writeString(char* str){
9D0011EC  27BDFFE8   ADDIU SP, SP, -24
9D0011F0  AFBF0014   SW RA, 20(SP)
9D0011F4  AFB00010   SW S0, 16(SP)
9D0011F8  00808021   ADDU S0, A0, ZERO
430:                 /* Print text onto screen
431:                  * Call tft_setCursor(), tft_setTextColor(), tft_setTextSize()
432:                  *  as necessary before printing
433:                  */
434:                     while (*str){
9D0011FC  80840000   LB A0, 0(A0)
9D001200  10800008   BEQ A0, ZERO, 0x9D001224
9D001204  8FBF0014   LW RA, 20(SP)
9D001214  82040000   LB A0, 0(S0)
9D001218  1480FFFC   BNE A0, ZERO, 0x9D00120C
9D00121C  26100001   ADDIU S0, S0, 1
435:                         tft_write(*str++);
9D001208  26100001   ADDIU S0, S0, 1
9D00120C  0F400443   JAL tft_write
9D001210  308400FF   ANDI A0, A0, 255
436:                     }
437:                 }
9D001220  8FBF0014   LW RA, 20(SP)
9D001224  8FB00010   LW S0, 16(SP)
9D001228  03E00008   JR RA
9D00122C  27BD0018   ADDIU SP, SP, 24
438:                 
439:                 // Draw a character
440:                 void tft_drawChar(short x, short y, unsigned char c, unsigned short color, unsigned short bg, unsigned char size) {
9D001230  27BDFF98   ADDIU SP, SP, -104
9D001234  AFBF0064   SW RA, 100(SP)
9D001238  AFBE0060   SW S8, 96(SP)
9D00123C  AFB7005C   SW S7, 92(SP)
9D001240  AFB60058   SW S6, 88(SP)
9D001244  AFB50054   SW S5, 84(SP)
9D001248  AFB40050   SW S4, 80(SP)
9D00124C  AFB3004C   SW S3, 76(SP)
9D001250  AFB20048   SW S2, 72(SP)
9D001254  AFB10044   SW S1, 68(SP)
9D001258  AFB00040   SW S0, 64(SP)
9D00125C  7C042620   SEH A0, A0
9D001260  7C052E20   SEH A1, A1
9D001264  30C600FF   ANDI A2, A2, 255
9D001268  30F7FFFF   ANDI S7, A3, -1
9D00126C  97A20078   LHU V0, 120(SP)
9D001270  AFA20018   SW V0, 24(SP)
441:                     char i, j;
442:                   if((x >= _width)            || // Clip right
9D001274  97828070   LHU V0, -32656(GP)
9D001278  0082102A   SLT V0, A0, V0
9D00127C  1040006C   BEQ V0, ZERO, 0x9D001430
9D001280  93B5007C   LBU S5, 124(SP)
9D001288  00A2102A   SLT V0, A1, V0
9D00128C  10400068   BEQ V0, ZERO, 0x9D001430
9D001290  00151040   SLL V0, S5, 1
443:                      (y >= _height)           || // Clip bottom
9D001284  97828078   LHU V0, -32648(GP)
9D0012A4  04400062   BLTZ V0, 0x9D001430
9D0012A8  02A0B021   ADDU S6, S5, ZERO
444:                      ((x + 6 * size - 1) < 0) || // Clip left
9D001294  001518C0   SLL V1, S5, 3
9D001298  00621023   SUBU V0, V1, V0
9D00129C  00821021   ADDU V0, A0, V0
9D0012A0  2442FFFF   ADDIU V0, V0, -1
9D0012B4  0440005E   BLTZ V0, 0x9D001430
9D0012B8  00061080   SLL V0, A2, 2
445:                      ((y + 8 * size - 1) < 0))   // Clip top
9D0012AC  00A31021   ADDU V0, A1, V1
9D0012B0  2442FFFF   ADDIU V0, V0, -1
446:                     return;
447:                 
448:                   for (i=0; i<6; i++ ) {
9D0013C4  8FA40020   LW A0, 32(SP)
9D0013C8  24820001   ADDIU V0, A0, 1
9D0013CC  7C021420   SEB V0, V0
9D0013D0  AFA20020   SW V0, 32(SP)
9D0013D4  8FA50028   LW A1, 40(SP)
9D0013D8  24A2FFFF   ADDIU V0, A1, -1
9D0013DC  304200FF   ANDI V0, V0, 255
9D0013E0  1440FFC4   BNE V0, ZERO, 0x9D0012F4
9D0013E4  AFA20028   SW V0, 40(SP)
9D0013E8  0B40050D   J 0x9D001434
9D0013EC  8FBF0064   LW RA, 100(SP)
449:                     unsigned char line;
450:                     if (i == 5)
9D0012F4  24020005   ADDIU V0, ZERO, 5
9D0012F8  8FA40020   LW A0, 32(SP)
9D0012FC  1082003C   BEQ A0, V0, 0x9D0013F0
9D001300  8FA50034   LW A1, 52(SP)
451:                       line = 0x0;
9D0013F0  00008821   ADDU S1, ZERO, ZERO
452:                     else
453:                       line = pgm_read_byte(font+(c*5)+i);
9D0012BC  00461021   ADDU V0, V0, A2
9D0012C0  AFA20034   SW V0, 52(SP)
9D0012C4  24030006   ADDIU V1, ZERO, 6
9D0012C8  AFA30028   SW V1, 40(SP)
9D0012CC  AFA00020   SW ZERO, 32(SP)
9D0012D0  3C029D00   LUI V0, -25344
9D0012D4  24424B54   ADDIU V0, V0, 19284
9D0012D8  AFA20038   SW V0, 56(SP)
9D001304  00A41021   ADDU V0, A1, A0
9D001308  8FA30038   LW V1, 56(SP)
9D00130C  00621021   ADDU V0, V1, V0
9D001310  0B4004FD   J 0x9D0013F4
9D001314  90510000   LBU S1, 0(V0)
454:                     for ( j = 0; j<8; j++) {
9D0013BC  161EFFD6   BNE S0, S8, 0x9D001318
9D0013C0  3273FFFF   ANDI S3, S3, -1
455:                       if (line & 0x1) {
9D001318  32220001   ANDI V0, S1, 1
9D00131C  10400011   BEQ V0, ZERO, 0x9D001364
9D001320  8FA50018   LW A1, 24(SP)
456:                         if (size == 1) // default size
9D001324  24040001   ADDIU A0, ZERO, 1
9D001328  56A40007   BNEL S5, A0, 0x9D001348
9D00132C  AFB70010   SW S7, 16(SP)
457:                           tft_drawPixel(x+i, y+j, color);
9D001330  8FA4002C   LW A0, 44(SP)
9D001334  7C102E20   SEH A1, S0
9D001338  0F400BE1   JAL tft_drawPixel
9D00133C  02E03021   ADDU A2, S7, ZERO
9D001340  0B4004EA   J 0x9D0013A8
9D001344  00118842   SRL S1, S1, 1
458:                         else {  // big size
459:                           tft_fillRect(x+(i*size), y+(j*size), size, size, color);
9D0012DC  3084FFFF   ANDI A0, A0, -1
9D0012E0  AFA40030   SW A0, 48(SP)
9D0012E4  30A5FFFF   ANDI A1, A1, -1
9D0012E8  AFA50024   SW A1, 36(SP)
9D0012EC  24BE0008   ADDIU S8, A1, 8
9D0012F0  33DEFFFF   ANDI S8, S8, -1
9D001348  8FA4001C   LW A0, 28(SP)
9D00134C  7C122E20   SEH A1, S2
9D001350  02C03021   ADDU A2, S6, ZERO
9D001354  0F400DC8   JAL tft_fillRect
9D001358  02C03821   ADDU A3, S6, ZERO
9D0013F4  8FA30020   LW V1, 32(SP)
9D0013F8  3062FFFF   ANDI V0, V1, -1
9D0013FC  02A0A021   ADDU S4, S5, ZERO
9D001400  8FA40030   LW A0, 48(SP)
9D001404  70552802   MUL A1, V0, S5
9D001408  00A41821   ADDU V1, A1, A0
9D00140C  7C031E20   SEH V1, V1
9D001410  AFA3001C   SW V1, 28(SP)
9D001414  8FB20024   LW S2, 36(SP)
460:                         }
461:                       } else if (bg != color) {
9D001364  10B7000F   BEQ A1, S7, 0x9D0013A4
9D001368  24020001   ADDIU V0, ZERO, 1
462:                         if (size == 1) // default size
9D00136C  16A20007   BNE S5, V0, 0x9D00138C
9D001370  8FA30018   LW V1, 24(SP)
463:                           tft_drawPixel(x+i, y+j, bg);
9D001374  8FA4002C   LW A0, 44(SP)
9D001378  7C102E20   SEH A1, S0
9D00137C  0F400BE1   JAL tft_drawPixel
9D001380  8FA60018   LW A2, 24(SP)
9D001384  0B4004EA   J 0x9D0013A8
9D001388  00118842   SRL S1, S1, 1
9D001420  00441021   ADDU V0, V0, A0
9D001424  7C021620   SEH V0, V0
9D001428  0B4004C6   J 0x9D001318
9D00142C  AFA2002C   SW V0, 44(SP)
464:                         else {  // big size
465:                           tft_fillRect(x+i*size, y+j*size, size, size, bg);
9D00138C  AFA30010   SW V1, 16(SP)
9D001390  8FA4001C   LW A0, 28(SP)
9D001394  7C132E20   SEH A1, S3
9D001398  02C03021   ADDU A2, S6, ZERO
9D00139C  0F400DC8   JAL tft_fillRect
9D0013A0  02C03821   ADDU A3, S6, ZERO
9D001418  02409821   ADDU S3, S2, ZERO
9D00141C  02408021   ADDU S0, S2, ZERO
466:                         }
467:                       }
468:                       line >>= 1;
9D00135C  0B4004EA   J 0x9D0013A8
9D001360  00118842   SRL S1, S1, 1
9D0013A4  00118842   SRL S1, S1, 1
9D0013A8  02549021   ADDU S2, S2, S4
9D0013AC  3252FFFF   ANDI S2, S2, -1
9D0013B0  26100001   ADDIU S0, S0, 1
9D0013B4  3210FFFF   ANDI S0, S0, -1
9D0013B8  02749821   ADDU S3, S3, S4
469:                     }
470:                   }
471:                 }
9D001430  8FBF0064   LW RA, 100(SP)
9D001434  8FBE0060   LW S8, 96(SP)
9D001438  8FB7005C   LW S7, 92(SP)
9D00143C  8FB60058   LW S6, 88(SP)
9D001440  8FB50054   LW S5, 84(SP)
9D001444  8FB40050   LW S4, 80(SP)
9D001448  8FB3004C   LW S3, 76(SP)
9D00144C  8FB20048   LW S2, 72(SP)
9D001450  8FB10044   LW S1, 68(SP)
9D001454  8FB00040   LW S0, 64(SP)
9D001458  03E00008   JR RA
9D00145C  27BD0068   ADDIU SP, SP, 104
472:                 
473:                 inline void tft_setCursor(short x, short y) {
474:                 /* Set cursor for text to be printed
475:                  * Parameters:
476:                  *      x = x-coordinate of top-left of text starting
477:                  *      y = y-coordinate of top-left of text starting
478:                  * Returns: Nothing
479:                  */
480:                   cursor_x = x;
9D001460  A7848072   SH A0, -32654(GP)
481:                   cursor_y = y;
9D001464  03E00008   JR RA
9D001468  A785806C   SH A1, -32660(GP)
482:                 }
483:                 
484:                 inline void tft_setTextSize(unsigned char s) {
9D00146C  308400FF   ANDI A0, A0, 255
485:                 /*Set size of text to be displayed
486:                  * Parameters:
487:                  *      s = text size (1 being smallest)
488:                  * Returns: nothing
489:                  */
490:                   textsize = (s > 0) ? s : 1;
9D001470  24020001   ADDIU V0, ZERO, 1
9D001474  0044200A   MOVZ A0, V0, A0
9D001478  03E00008   JR RA
9D00147C  A7848076   SH A0, -32650(GP)
491:                 }
492:                 
493:                 inline void tft_setTextColor(unsigned short c) {
9D001480  3084FFFF   ANDI A0, A0, -1
494:                   // For 'transparent' background, we'll set the bg
495:                   // to the same as fg instead of using a flag
496:                   textcolor = textbgcolor = c;
9D001484  A784807A   SH A0, -32646(GP)
9D001488  03E00008   JR RA
9D00148C  A784807C   SH A0, -32644(GP)
497:                 }
498:                 
499:                 inline void tft_setTextColor2(unsigned short c, unsigned short b) {
500:                 /* Set color of text to be displayed
501:                  * Parameters:
502:                  *      c = 16-bit color of text
503:                  *      b = 16-bit color of text background
504:                  */
505:                   textcolor   = c;
9D001490  A784807C   SH A0, -32644(GP)
506:                   textbgcolor = b;
9D001494  03E00008   JR RA
9D001498  A785807A   SH A1, -32646(GP)
507:                 }
508:                 
509:                 inline void tft_setTextWrap(char w) {
9D00149C  7C042420   SEB A0, A0
510:                   wrap = w;
9D0014A0  03E00008   JR RA
9D0014A4  A7848074   SH A0, -32652(GP)
511:                 }
512:                 
513:                 inline unsigned char tft_getRotation(void) {
514:                 /* Returns current roation of screen
515:                  *          0 = no rotation (0 degree rotation)
516:                  *          1 = rotate 90 degree clockwise
517:                  *          2 = rotate 180 degree
518:                  *          3 = rotate 90 degree anticlockwise
519:                  */
520:                   return rotation;
521:                 }
9D0014A8  03E00008   JR RA
9D0014AC  9382806E   LBU V0, -32658(GP)
522:                 
523:                 void tft_gfx_setRotation(unsigned char x) {
524:                 /* Set display rotation in 90 degree steps
525:                  * Parameters:
526:                  *      x: dictate direction of rotation
527:                  *          0 = no rotation (0 degree rotation)
528:                  *          1 = rotate 90 degree clockwise
529:                  *          2 = rotate 180 degree
530:                  *          3 = rotate 90 degree anticlockwise
531:                  * Returns: Nothing
532:                  */
533:                   rotation = (x & 3);
9D0014B0  30840003   ANDI A0, A0, 3
534:                   switch(rotation) {
9D0014B4  24020001   ADDIU V0, ZERO, 1
9D0014B8  1082000E   BEQ A0, V0, 0x9D0014F4
9D0014BC  A784806E   SH A0, -32658(GP)
9D0014C0  10800007   BEQ A0, ZERO, 0x9D0014E0
9D0014C4  24020002   ADDIU V0, ZERO, 2
9D0014C8  10820005   BEQ A0, V0, 0x9D0014E0
9D0014CC  24020003   ADDIU V0, ZERO, 3
9D0014D0  1482000C   BNE A0, V0, 0x9D001504
9D0014D4  24020140   ADDIU V0, ZERO, 320
535:                    case 0:
536:                    case 2:
537:                     _width  = ILI9340_TFTWIDTH;
9D0014E0  240200F0   ADDIU V0, ZERO, 240
9D0014E4  A7828070   SH V0, -32656(GP)
538:                     _height = ILI9340_TFTHEIGHT;
9D0014E8  24020140   ADDIU V0, ZERO, 320
539:                     break;
9D0014EC  03E00008   JR RA
9D0014F0  A7828078   SH V0, -32648(GP)
540:                    case 1:
541:                    case 3:
542:                     _width  = ILI9340_TFTHEIGHT;;
9D0014D8  0B40053F   J 0x9D0014FC
9D0014DC  A7828070   SH V0, -32656(GP)
9D0014F4  24020140   ADDIU V0, ZERO, 320
9D0014F8  A7828070   SH V0, -32656(GP)
543:                     _height = ILI9340_TFTWIDTH;
9D0014FC  240200F0   ADDIU V0, ZERO, 240
9D001500  A7828078   SH V0, -32648(GP)
9D001504  03E00008   JR RA
9D001508  00000000   NOP
544:                     break;
545:                   }
546:                 }
547:                 
548:                 // Return the size of the display (per current rotation)
549:                 inline short tft_width(void) {
550:                   return _width;
551:                 }
9D00150C  03E00008   JR RA
9D001510  87828070   LH V0, -32656(GP)
552:                 
553:                 inline short tft_height(void) {
554:                   return _height;
555:                 }
9D001514  03E00008   JR RA
9D001518  87828078   LH V0, -32648(GP)
---  z:/eedocs/4760/pic/big_board_pt_1_2/tft_fixed_point_test_brl4.c  -----------------------------------
1:                   /*
2:                    * File:        Fixed point testing
3:                    * Author:      Bruce Land
4:                    * For use with Sean Carroll's Big Board
5:                    * Adapted from:
6:                    *              main.c by
7:                    * Author:      Syed Tahmid Mahbub
8:                    * Target PIC:  PIC32MX250F128B
9:                    */
10:                  
11:                  ////////////////////////////////////
12:                  // clock AND protoThreads configure!
13:                  // You MUST check this file!
14:                  #include "config.h"
15:                  // threading library
16:                  #include "pt_cornell_1_2_1.h"
17:                  
18:                  ////////////////////////////////////
19:                  // graphics libraries
20:                  // SPI channel 1 connections to TFT
21:                  #include "tft_master.h"
22:                  #include "tft_gfx.h"
23:                  // need for rand function
24:                  #include <stdlib.h>
25:                  ////////////////////////////////////
26:                  
27:                  
28:                  /* Demo code for interfacing TFT (ILI9340 controller) to PIC32
29:                   * The library has been modified from a similar Adafruit library
30:                   */
31:                  // Adafruit data:
32:                  /***************************************************
33:                    This is an example sketch for the Adafruit 2.2" SPI display.
34:                    This library works with the Adafruit 2.2" TFT Breakout w/SD card
35:                    ----> http://www.adafruit.com/products/1480
36:                  
37:                    Check out the links above for our tutorials and wiring diagrams
38:                    These displays use SPI to communicate, 4 or 5 pins are required to
39:                    interface (RST is optional)
40:                    Adafruit invests time and resources providing this open source code,
41:                    please support Adafruit and open-source hardware by purchasing
42:                    products from Adafruit!
43:                  
44:                    Written by Limor Fried/Ladyada for Adafruit Industries.
45:                    MIT license, all text above must be included in any redistribution
46:                   ****************************************************/
47:                  
48:                  // string buffer
49:                  char buffer[60];
50:                  
51:                  // === thread structures ============================================
52:                  // thread control structs
53:                  // note that UART input and output are threads
54:                  static struct pt pt_fixed14, pt_fixed16, pt_float ;
55:                  
56:                  // system 1 second interval tick
57:                  static int sys_time_seconds ;
58:                  // elapsed time cycle counters
59:                  static int t, zero_t, dt ;
60:                  
61:                  // === fixed14 Thread =================================================
62:                  // 
63:                  typedef signed short fix14 ;
64:                  #define multfix14(a,b) ((fix14)((((int)(a))*((int)(b)))>>14)) //multiply two fixed 2.14
65:                  #define float2fix14(a) ((fix14)((a)*16384.0)) // 2^14
66:                  #define fix2float14(a) ((float)(a)/16384.0)
67:                  #define fix2int14(a)    ((int)((a)>>14))
68:                  #define int2fix14(a)    ((fix14)((a)<<14))
69:                  #define absfix14(a) abs(a) 
70:                  
71:                  static fix14 in14_1, in14_2, out14 ;
72:                  
73:                  static PT_THREAD (protothread_fixed14(struct pt *pt))
74:                  {
9D003E78  27BDFFC8   ADDIU SP, SP, -56
9D003E7C  AFBF0034   SW RA, 52(SP)
9D003E80  AFB60030   SW S6, 48(SP)
9D003E84  AFB5002C   SW S5, 44(SP)
9D003E88  AFB40028   SW S4, 40(SP)
9D003E8C  AFB30024   SW S3, 36(SP)
9D003E90  AFB20020   SW S2, 32(SP)
9D003E94  AFB1001C   SW S1, 28(SP)
9D003E98  AFB00018   SW S0, 24(SP)
75:                      PT_BEGIN(pt);
9D003E9C  8C820000   LW V0, 0(A0)
9D003EA0  14400012   BNE V0, ZERO, 0x9D003EEC
9D003EA4  00808021   ADDU S0, A0, ZERO
76:                       tft_setCursor(0, 0);
9D003EA8  00002021   ADDU A0, ZERO, ZERO
9D003EAC  0F400518   JAL tft_setCursor
9D003EB0  00002821   ADDU A1, ZERO, ZERO
77:                       tft_setTextColor(ILI9340_WHITE);  tft_setTextSize(1);
9D003EB4  0F400520   JAL tft_setTextColor
9D003EB8  3404FFFF   ORI A0, ZERO, -1
9D003EBC  0F40051B   JAL tft_setTextSize
9D003EC0  24040001   ADDIU A0, ZERO, 1
78:                       tft_writeString("Operation timing\n");
9D003EC4  3C049D00   LUI A0, -25344
9D003EC8  0F40047B   JAL tft_writeString
9D003ECC  24846A98   ADDIU A0, A0, 27288
79:                  
80:                        while(1) {
81:                          // yield time 1 second
82:                          PT_YIELD_TIME_msec(1000) ;
9D003ED0  8F828084   LW V0, -32636(GP)
9D003ED4  244203E8   ADDIU V0, V0, 1000
9D003ED8  AF828064   SW V0, -32668(GP)
9D003EDC  3C029D00   LUI V0, -25344
9D003EE0  24423EEC   ADDIU V0, V0, 16108
9D003EE4  0B401041   J 0x9D004104
9D003EE8  AE020000   SW V0, 0(S0)
9D003EEC  3C029D00   LUI V0, -25344
9D003EF0  24423EEC   ADDIU V0, V0, 16108
9D003EF4  AC820000   SW V0, 0(A0)
9D003EF8  8F838084   LW V1, -32636(GP)
9D003EFC  8F828064   LW V0, -32668(GP)
9D003F00  0062102B   SLTU V0, V1, V0
9D003F04  14400080   BNE V0, ZERO, 0x9D004108
9D003F08  24020001   ADDIU V0, ZERO, 1
83:                          sys_time_seconds++ ;
9D003F0C  8F84802C   LW A0, -32724(GP)
9D003F10  24840001   ADDIU A0, A0, 1
84:                          
85:                          // 14 bit fix ///////////////////
86:                          // all numbers less than 2!
87:                          in14_1 = float2fix14((float)sys_time_seconds/10.) ; //(float)sys_time_seconds/100
9D003F14  0F401BF9   JAL sitofp
9D003F18  AF84802C   SW A0, -32724(GP)
9D003F1C  00402021   ADDU A0, V0, ZERO
9D003F20  3C029D00   LUI V0, -25344
9D003F24  0F4016E1   JAL __divsf3
9D003F28  8C456B28   LW A1, 27432(V0)
9D003F2C  3C159D00   LUI S5, -25344
9D003F30  00402021   ADDU A0, V0, ZERO
9D003F34  0F401879   JAL __mulsf3
9D003F38  8EA56B2C   LW A1, 27436(S5)
9D003F3C  0F401B86   JAL __fixsfsi
9D003F40  00402021   ADDU A0, V0, ZERO
9D003F44  7C021620   SEH V0, V0
9D003F48  A782803C   SH V0, -32708(GP)
88:                          in14_2 = float2fix14(0.1) ;
9D003F4C  24030666   ADDIU V1, ZERO, 1638
9D003F50  A783803E   SH V1, -32706(GP)
89:                          // read the time
90:                          t = TMR2;
9D003F54  3C12BF80   LUI S2, -16512
9D003F58  8E430810   LW V1, 2064(S2)
9D003F5C  AF838030   SW V1, -32720(GP)
91:                          // do the test
92:                          out14 =  multfix14(in14_1,in14_2) ;
9D003F60  00022080   SLL A0, V0, 2
9D003F64  00022900   SLL A1, V0, 4
9D003F68  00A42023   SUBU A0, A1, A0
9D003F6C  00821021   ADDU V0, A0, V0
9D003F70  00022180   SLL A0, V0, 6
9D003F74  00821023   SUBU V0, A0, V0
9D003F78  00021343   SRA V0, V0, 13
9D003F7C  A7828040   SH V0, -32704(GP)
93:                          // compute elapsed time - 5 cycles of overhead
94:                          dt = TMR2 - t - zero_t;
9D003F80  8E420810   LW V0, 2064(S2)
9D003F84  00431823   SUBU V1, V0, V1
9D003F88  8F828034   LW V0, -32716(GP)
9D003F8C  00621823   SUBU V1, V1, V0
9D003F90  AF838038   SW V1, -32712(GP)
95:                          // print it to TFT LCD
96:                          tft_fillRoundRect(0,10, 230, 14, 1, ILI9340_BLACK);// x,y,w,h,radius,color
9D003F94  24140001   ADDIU S4, ZERO, 1
9D003F98  AFB40010   SW S4, 16(SP)
9D003F9C  AFA00014   SW ZERO, 20(SP)
9D003FA0  00002021   ADDU A0, ZERO, ZERO
9D003FA4  2405000A   ADDIU A1, ZERO, 10
9D003FA8  240600E6   ADDIU A2, ZERO, 230
9D003FAC  0F4002C4   JAL tft_fillRoundRect
9D003FB0  2407000E   ADDIU A3, ZERO, 14
97:                          tft_setCursor(0, 10);
9D003FB4  00002021   ADDU A0, ZERO, ZERO
9D003FB8  0F400518   JAL tft_setCursor
9D003FBC  2405000A   ADDIU A1, ZERO, 10
98:                          tft_setTextColor(ILI9340_WHITE); tft_setTextSize(1);
9D003FC0  0F400520   JAL tft_setTextColor
9D003FC4  3404FFFF   ORI A0, ZERO, -1
9D003FC8  0F40051B   JAL tft_setTextSize
9D003FCC  24040001   ADDIU A0, ZERO, 1
99:                          sprintf(buffer, "Multfix14 dt value  %d  %5.3f", dt, fix2float14(out14));
9D003FD0  8F968038   LW S6, -32712(GP)
9D003FD4  0F401BF9   JAL sitofp
9D003FD8  87848040   LH A0, -32704(GP)
9D003FDC  3C139D00   LUI S3, -25344
9D003FE0  00402021   ADDU A0, V0, ZERO
9D003FE4  0F401879   JAL __mulsf3
9D003FE8  8E656B30   LW A1, 27440(S3)
9D003FEC  3C11A000   LUI S1, -24576
9D003FF0  262400C0   ADDIU A0, S1, 192
9D003FF4  3C059D00   LUI A1, -25344
9D003FF8  24A56AAC   ADDIU A1, A1, 27308
9D003FFC  02C03021   ADDU A2, S6, ZERO
9D004000  0F401BC5   JAL _sprintf_cdfFnopuxX
9D004004  00403821   ADDU A3, V0, ZERO
100:                         tft_writeString(buffer);
9D004008  0F40047B   JAL tft_writeString
9D00400C  262400C0   ADDIU A0, S1, 192
101:                         
102:                         // MAC
103:                         in14_1 = float2fix14((float)sys_time_seconds/20.) ; //(float)sys_time_seconds/100
9D004010  0F401BF9   JAL sitofp
9D004014  8F84802C   LW A0, -32724(GP)
9D004018  00402021   ADDU A0, V0, ZERO
9D00401C  3C029D00   LUI V0, -25344
9D004020  0F4016E1   JAL __divsf3
9D004024  8C456B34   LW A1, 27444(V0)
9D004028  00402021   ADDU A0, V0, ZERO
9D00402C  0F401879   JAL __mulsf3
9D004030  8EA56B2C   LW A1, 27436(S5)
9D004034  0F401B86   JAL __fixsfsi
9D004038  00402021   ADDU A0, V0, ZERO
9D00403C  7C021620   SEH V0, V0
9D004040  A782803C   SH V0, -32708(GP)
104:                         in14_2 = float2fix14(0.2) ;
9D004044  24030CCC   ADDIU V1, ZERO, 3276
9D004048  A783803E   SH V1, -32706(GP)
105:                         out14 = float2fix14(-0.5);
106:                         t = TMR2;
9D00404C  8E430810   LW V1, 2064(S2)
9D004050  AF838030   SW V1, -32720(GP)
107:                         // do the test
108:                         out14 =  multfix14(in14_1,in14_2) + out14 ;
9D004054  00022080   SLL A0, V0, 2
9D004058  00022900   SLL A1, V0, 4
9D00405C  00A42023   SUBU A0, A1, A0
9D004060  00821021   ADDU V0, A0, V0
9D004064  00022180   SLL A0, V0, 6
9D004068  00821023   SUBU V0, A0, V0
9D00406C  00021303   SRA V0, V0, 12
9D004070  2442E000   ADDIU V0, V0, -8192
9D004074  A7828040   SH V0, -32704(GP)
109:                         // compute elapsed time - 5 cycles of overhead
110:                         dt = TMR2 - t - zero_t;
9D004078  8E420810   LW V0, 2064(S2)
9D00407C  00431823   SUBU V1, V0, V1
9D004080  8F828034   LW V0, -32716(GP)
9D004084  00621823   SUBU V1, V1, V0
9D004088  AF838038   SW V1, -32712(GP)
111:                         // print it to TFT LCD
112:                         tft_fillRoundRect(0,20, 230, 14, 1, ILI9340_BLACK);// x,y,w,h,radius,color
9D00408C  AFB40010   SW S4, 16(SP)
9D004090  AFA00014   SW ZERO, 20(SP)
9D004094  00002021   ADDU A0, ZERO, ZERO
9D004098  24050014   ADDIU A1, ZERO, 20
9D00409C  240600E6   ADDIU A2, ZERO, 230
9D0040A0  0F4002C4   JAL tft_fillRoundRect
9D0040A4  2407000E   ADDIU A3, ZERO, 14
113:                         tft_setCursor(0, 20);
9D0040A8  00002021   ADDU A0, ZERO, ZERO
9D0040AC  0F400518   JAL tft_setCursor
9D0040B0  24050014   ADDIU A1, ZERO, 20
114:                         tft_setTextColor(ILI9340_WHITE); tft_setTextSize(1);
9D0040B4  0F400520   JAL tft_setTextColor
9D0040B8  3404FFFF   ORI A0, ZERO, -1
9D0040BC  0F40051B   JAL tft_setTextSize
9D0040C0  24040001   ADDIU A0, ZERO, 1
115:                         sprintf(buffer, "Mult+add dt value  %d  %5.3f", dt, fix2float14(out14));
9D0040C4  8F928038   LW S2, -32712(GP)
9D0040C8  0F401BF9   JAL sitofp
9D0040CC  87848040   LH A0, -32704(GP)
9D0040D0  00402021   ADDU A0, V0, ZERO
9D0040D4  0F401879   JAL __mulsf3
9D0040D8  8E656B30   LW A1, 27440(S3)
9D0040DC  262400C0   ADDIU A0, S1, 192
9D0040E0  3C059D00   LUI A1, -25344
9D0040E4  24A56ACC   ADDIU A1, A1, 27340
9D0040E8  02403021   ADDU A2, S2, ZERO
9D0040EC  0F401BC5   JAL _sprintf_cdfFnopuxX
9D0040F0  00403821   ADDU A3, V0, ZERO
116:                         tft_writeString(buffer);
9D0040F4  0F40047B   JAL tft_writeString
9D0040F8  262400C0   ADDIU A0, S1, 192
117:                         // NEVER exit while
118:                       } // END WHILE(1)
9D0040FC  0B400FB4   J 0x9D003ED0
9D004100  00000000   NOP
119:                   PT_END(pt);
120:                 } // timer thread
9D004104  24020001   ADDIU V0, ZERO, 1
9D004108  8FBF0034   LW RA, 52(SP)
9D00410C  8FB60030   LW S6, 48(SP)
9D004110  8FB5002C   LW S5, 44(SP)
9D004114  8FB40028   LW S4, 40(SP)
9D004118  8FB30024   LW S3, 36(SP)
9D00411C  8FB20020   LW S2, 32(SP)
9D004120  8FB1001C   LW S1, 28(SP)
9D004124  8FB00018   LW S0, 24(SP)
9D004128  03E00008   JR RA
9D00412C  27BD0038   ADDIU SP, SP, 56
121:                 
122:                 // === fixed16 Thread =================================================
123:                 // 
124:                 typedef signed int fix16 ;
125:                 #define multfix16(a,b) ((fix16)(((( signed long long)(a))*(( signed long long)(b)))>>16)) //multiply two fixed 16:16
126:                 #define float2fix16(a) ((fix16)((a)*65536.0)) // 2^16
127:                 #define fix2float16(a) ((float)(a)/65536.0)
128:                 #define fix2int16(a)    ((int)((a)>>16))
129:                 #define int2fix16(a)    ((fix16)((a)<<16))
130:                 #define divfix16(a,b) ((fix16)((((signed long long)(a)<<16)/(b)))) 
131:                 #define sqrtfix16(a) (float2fix16(sqrt(fix2float16(a)))) 
132:                 #define absfix16(a) abs(a)
133:                 
134:                 static fix16 in16_1, in16_2, out16 ;
135:                 
136:                 static PT_THREAD (protothread_fixed16(struct pt *pt))
137:                 {
9D004130  27BDFFC8   ADDIU SP, SP, -56
9D004134  AFBF0034   SW RA, 52(SP)
9D004138  AFB50030   SW S5, 48(SP)
9D00413C  AFB4002C   SW S4, 44(SP)
9D004140  AFB30028   SW S3, 40(SP)
9D004144  AFB20024   SW S2, 36(SP)
9D004148  AFB10020   SW S1, 32(SP)
9D00414C  AFB0001C   SW S0, 28(SP)
138:                     PT_BEGIN(pt);
9D004150  8C820000   LW V0, 0(A0)
9D004154  14400008   BNE V0, ZERO, 0x9D004178
9D004158  00808021   ADDU S0, A0, ZERO
139:                       while(1) {
140:                          // yield time 1 second
141:                         PT_YIELD_TIME_msec(1000) ;
9D00415C  8F828084   LW V0, -32636(GP)
9D004160  244203E8   ADDIU V0, V0, 1000
9D004164  AF828060   SW V0, -32672(GP)
9D004168  3C029D00   LUI V0, -25344
9D00416C  24424178   ADDIU V0, V0, 16760
9D004170  0B4010D7   J 0x9D00435C
9D004174  AE020000   SW V0, 0(S0)
9D004178  3C029D00   LUI V0, -25344
9D00417C  24424178   ADDIU V0, V0, 16760
9D004180  AC820000   SW V0, 0(A0)
9D004184  8F838084   LW V1, -32636(GP)
9D004188  8F828060   LW V0, -32672(GP)
9D00418C  0062102B   SLTU V0, V1, V0
9D004190  14400073   BNE V0, ZERO, 0x9D004360
9D004194  24020001   ADDIU V0, ZERO, 1
142:                         
143:                         // 16 bit fix ///////////////////
144:                         // all numbers less than 2!
145:                         in16_1 = float2fix16((float)sys_time_seconds) ; //(float)sys_time_seconds/100
9D004198  0F401BF9   JAL sitofp
9D00419C  8F84802C   LW A0, -32724(GP)
9D0041A0  00402021   ADDU A0, V0, ZERO
9D0041A4  3C029D00   LUI V0, -25344
9D0041A8  0F401879   JAL __mulsf3
9D0041AC  8C456B38   LW A1, 27448(V0)
9D0041B0  0F401B86   JAL __fixsfsi
9D0041B4  00402021   ADDU A0, V0, ZERO
9D0041B8  AF828044   SW V0, -32700(GP)
146:                         in16_2 = float2fix16(0.1) ;
9D0041BC  24041999   ADDIU A0, ZERO, 6553
9D0041C0  AF848048   SW A0, -32696(GP)
147:                         // read the time
148:                         t = TMR2;
9D0041C4  3C12BF80   LUI S2, -16512
9D0041C8  8E450810   LW A1, 2064(S2)
9D0041CC  AF858030   SW A1, -32720(GP)
149:                         // do the test
150:                         out16 =  multfix16(in16_1,in16_2) ;
9D0041D0  000237C3   SRA A2, V0, 31
9D0041D4  00440019   MULTU 0, V0, A0
9D0041D8  00001012   MFLO V0, 0
9D0041DC  00001810   MFHI V1, 0
9D0041E0  70C43802   MUL A3, A2, A0
9D0041E4  00E31821   ADDU V1, A3, V1
9D0041E8  00031C00   SLL V1, V1, 16
9D0041EC  00021402   SRL V0, V0, 16
9D0041F0  00621025   OR V0, V1, V0
9D0041F4  AF82804C   SW V0, -32692(GP)
151:                         // compute elapsed time - 5 cycles of overhead
152:                         dt = TMR2 - t - zero_t;
9D0041F8  8E420810   LW V0, 2064(S2)
9D0041FC  00452823   SUBU A1, V0, A1
9D004200  8F828034   LW V0, -32716(GP)
9D004204  00A22823   SUBU A1, A1, V0
9D004208  AF858038   SW A1, -32712(GP)
153:                         // print it to TFT LCD
154:                         tft_fillRoundRect(0,40, 230, 14, 1, ILI9340_BLACK);// x,y,w,h,radius,color
9D00420C  24140001   ADDIU S4, ZERO, 1
9D004210  AFB40010   SW S4, 16(SP)
9D004214  AFA00014   SW ZERO, 20(SP)
9D004218  00002021   ADDU A0, ZERO, ZERO
9D00421C  24050028   ADDIU A1, ZERO, 40
9D004220  240600E6   ADDIU A2, ZERO, 230
9D004224  0F4002C4   JAL tft_fillRoundRect
9D004228  2407000E   ADDIU A3, ZERO, 14
155:                         tft_setCursor(0, 40);
9D00422C  00002021   ADDU A0, ZERO, ZERO
9D004230  0F400518   JAL tft_setCursor
9D004234  24050028   ADDIU A1, ZERO, 40
156:                         tft_setTextColor(ILI9340_WHITE); tft_setTextSize(1);
9D004238  0F400520   JAL tft_setTextColor
9D00423C  3404FFFF   ORI A0, ZERO, -1
9D004240  0F40051B   JAL tft_setTextSize
9D004244  24040001   ADDIU A0, ZERO, 1
157:                         sprintf(buffer, "Multfix16 dt value  %d  %5.3f", dt, fix2float16(out16));
9D004248  8F958038   LW S5, -32712(GP)
9D00424C  0F401BF9   JAL sitofp
9D004250  8F84804C   LW A0, -32692(GP)
9D004254  3C139D00   LUI S3, -25344
9D004258  00402021   ADDU A0, V0, ZERO
9D00425C  0F401879   JAL __mulsf3
9D004260  8E656B3C   LW A1, 27452(S3)
9D004264  3C11A000   LUI S1, -24576
9D004268  262400C0   ADDIU A0, S1, 192
9D00426C  3C059D00   LUI A1, -25344
9D004270  24A56AEC   ADDIU A1, A1, 27372
9D004274  02A03021   ADDU A2, S5, ZERO
9D004278  0F401BC5   JAL _sprintf_cdfFnopuxX
9D00427C  00403821   ADDU A3, V0, ZERO
158:                         tft_writeString(buffer);
9D004280  0F40047B   JAL tft_writeString
9D004284  262400C0   ADDIU A0, S1, 192
159:                         
160:                         // read the time
161:                         out16 = float2fix16(-0.5);
162:                         t = TMR2;
9D004288  8E440810   LW A0, 2064(S2)
9D00428C  AF848030   SW A0, -32720(GP)
163:                         // do the test
164:                         out16 =  multfix16(in16_1,in16_2) + out16 ;
9D004290  8F838044   LW V1, -32700(GP)
9D004294  000337C3   SRA A2, V1, 31
9D004298  8F828048   LW V0, -32696(GP)
9D00429C  00022FC3   SRA A1, V0, 31
9D0042A0  00A30018   MULT 0, A1, V1
9D0042A4  70C20000   MADD 0, A2, V0
9D0042A8  00002812   MFLO A1, 0
9D0042AC  00620019   MULTU 0, V1, V0
9D0042B0  00001012   MFLO V0, 0
9D0042B4  00001810   MFHI V1, 0
9D0042B8  00A31821   ADDU V1, A1, V1
9D0042BC  00031C00   SLL V1, V1, 16
9D0042C0  00021402   SRL V0, V0, 16
9D0042C4  00621025   OR V0, V1, V0
9D0042C8  24428000   ADDIU V0, V0, -32768
9D0042CC  AF82804C   SW V0, -32692(GP)
165:                         // compute elapsed time - 5 cycles of overhead
166:                         dt = TMR2 - t - zero_t;
9D0042D0  8E420810   LW V0, 2064(S2)
9D0042D4  00442023   SUBU A0, V0, A0
9D0042D8  8F828034   LW V0, -32716(GP)
9D0042DC  00822023   SUBU A0, A0, V0
9D0042E0  AF848038   SW A0, -32712(GP)
167:                         // print it to TFT LCD
168:                         tft_fillRoundRect(0,50, 230, 14, 1, ILI9340_BLACK);// x,y,w,h,radius,color
9D0042E4  AFB40010   SW S4, 16(SP)
9D0042E8  AFA00014   SW ZERO, 20(SP)
9D0042EC  00002021   ADDU A0, ZERO, ZERO
9D0042F0  24050032   ADDIU A1, ZERO, 50
9D0042F4  240600E6   ADDIU A2, ZERO, 230
9D0042F8  0F4002C4   JAL tft_fillRoundRect
9D0042FC  2407000E   ADDIU A3, ZERO, 14
169:                         tft_setCursor(0, 50);
9D004300  00002021   ADDU A0, ZERO, ZERO
9D004304  0F400518   JAL tft_setCursor
9D004308  24050032   ADDIU A1, ZERO, 50
170:                         tft_setTextColor(ILI9340_WHITE); tft_setTextSize(1);
9D00430C  0F400520   JAL tft_setTextColor
9D004310  3404FFFF   ORI A0, ZERO, -1
9D004314  0F40051B   JAL tft_setTextSize
9D004318  24040001   ADDIU A0, ZERO, 1
171:                         sprintf(buffer, "Mult+add dt value  %d  %5.3f", dt, fix2float16(out16));
9D00431C  8F928038   LW S2, -32712(GP)
9D004320  0F401BF9   JAL sitofp
9D004324  8F84804C   LW A0, -32692(GP)
9D004328  00402021   ADDU A0, V0, ZERO
9D00432C  0F401879   JAL __mulsf3
9D004330  8E656B3C   LW A1, 27452(S3)
9D004334  262400C0   ADDIU A0, S1, 192
9D004338  3C059D00   LUI A1, -25344
9D00433C  24A56ACC   ADDIU A1, A1, 27340
9D004340  02403021   ADDU A2, S2, ZERO
9D004344  0F401BC5   JAL _sprintf_cdfFnopuxX
9D004348  00403821   ADDU A3, V0, ZERO
172:                         tft_writeString(buffer);
9D00434C  0F40047B   JAL tft_writeString
9D004350  262400C0   ADDIU A0, S1, 192
173:                 
174:                         
175:                         // NEVER exit while
176:                       } // END WHILE(1)
9D004354  0B401057   J 0x9D00415C
9D004358  00000000   NOP
177:                   PT_END(pt);
178:                 } // color thread
9D00435C  24020001   ADDIU V0, ZERO, 1
9D004360  8FBF0034   LW RA, 52(SP)
9D004364  8FB50030   LW S5, 48(SP)
9D004368  8FB4002C   LW S4, 44(SP)
9D00436C  8FB30028   LW S3, 40(SP)
9D004370  8FB20024   LW S2, 36(SP)
9D004374  8FB10020   LW S1, 32(SP)
9D004378  8FB0001C   LW S0, 28(SP)
9D00437C  03E00008   JR RA
9D004380  27BD0038   ADDIU SP, SP, 56
179:                 
180:                 // === float Thread =============================================
181:                 //  
182:                 static float infloat_1, infloat_2, outfloat ;
183:                 
184:                 static PT_THREAD (protothread_float(struct pt *pt))
185:                 {
9D004384  27BDFFD0   ADDIU SP, SP, -48
9D004388  AFBF002C   SW RA, 44(SP)
9D00438C  AFB40028   SW S4, 40(SP)
9D004390  AFB30024   SW S3, 36(SP)
9D004394  AFB20020   SW S2, 32(SP)
9D004398  AFB1001C   SW S1, 28(SP)
9D00439C  AFB00018   SW S0, 24(SP)
186:                     PT_BEGIN(pt);
9D0043A0  8C820000   LW V0, 0(A0)
9D0043A4  14400008   BNE V0, ZERO, 0x9D0043C8
9D0043A8  00808021   ADDU S0, A0, ZERO
187:                       while(1) {
188:                         // yield time 1 second
189:                         PT_YIELD_TIME_msec(1000);
9D0043AC  8F828084   LW V0, -32636(GP)
9D0043B0  244203E8   ADDIU V0, V0, 1000
9D0043B4  AF828068   SW V0, -32664(GP)
9D0043B8  3C029D00   LUI V0, -25344
9D0043BC  244243C8   ADDIU V0, V0, 17352
9D0043C0  0B40114A   J 0x9D004528
9D0043C4  AE020000   SW V0, 0(S0)
9D0043C8  3C029D00   LUI V0, -25344
9D0043CC  244243C8   ADDIU V0, V0, 17352
9D0043D0  AC820000   SW V0, 0(A0)
9D0043D4  8F838084   LW V1, -32636(GP)
9D0043D8  8F828068   LW V0, -32664(GP)
9D0043DC  0062102B   SLTU V0, V1, V0
9D0043E0  14400052   BNE V0, ZERO, 0x9D00452C
9D0043E4  24020001   ADDIU V0, ZERO, 1
190:                         
191:                         // float ///////////////////
192:                         // all numbers less than 2!
193:                         infloat_1 = (float)sys_time_seconds ; 
9D0043E8  0F401BF9   JAL sitofp
9D0043EC  8F84802C   LW A0, -32724(GP)
9D0043F0  AF828050   SW V0, -32688(GP)
194:                         infloat_2 = 0.1 ;
9D0043F4  3C039D00   LUI V1, -25344
9D0043F8  8C656B40   LW A1, 27456(V1)
9D0043FC  AF858054   SW A1, -32684(GP)
195:                         // read the time
196:                         t = TMR2;
9D004400  3C12BF80   LUI S2, -16512
9D004404  8E510810   LW S1, 2064(S2)
9D004408  AF918030   SW S1, -32720(GP)
197:                         // do the test
198:                         outfloat =  infloat_1 * infloat_2 ;
9D00440C  0F401879   JAL __mulsf3
9D004410  00402021   ADDU A0, V0, ZERO
9D004414  AF828058   SW V0, -32680(GP)
199:                         // compute elapsed time - 5 cycles of overhead
200:                         dt = TMR2 - t - zero_t;
9D004418  8E420810   LW V0, 2064(S2)
9D00441C  00518823   SUBU S1, V0, S1
9D004420  8F828034   LW V0, -32716(GP)
9D004424  02228823   SUBU S1, S1, V0
9D004428  AF918038   SW S1, -32712(GP)
201:                         // print it to TFT LCD
202:                         tft_fillRoundRect(0,70, 230, 14, 1, ILI9340_BLACK);// x,y,w,h,radius,color
9D00442C  24130001   ADDIU S3, ZERO, 1
9D004430  AFB30010   SW S3, 16(SP)
9D004434  AFA00014   SW ZERO, 20(SP)
9D004438  00002021   ADDU A0, ZERO, ZERO
9D00443C  24050046   ADDIU A1, ZERO, 70
9D004440  240600E6   ADDIU A2, ZERO, 230
9D004444  0F4002C4   JAL tft_fillRoundRect
9D004448  2407000E   ADDIU A3, ZERO, 14
203:                         tft_setCursor(0, 70);
9D00444C  00002021   ADDU A0, ZERO, ZERO
9D004450  0F400518   JAL tft_setCursor
9D004454  24050046   ADDIU A1, ZERO, 70
204:                         tft_setTextColor(ILI9340_WHITE); tft_setTextSize(1);
9D004458  0F400520   JAL tft_setTextColor
9D00445C  3404FFFF   ORI A0, ZERO, -1
9D004460  0F40051B   JAL tft_setTextSize
9D004464  24040001   ADDIU A0, ZERO, 1
205:                         sprintf(buffer, "float   dt value  %d  %5.3f", dt, outfloat);
9D004468  3C11A000   LUI S1, -24576
9D00446C  262400C0   ADDIU A0, S1, 192
9D004470  3C059D00   LUI A1, -25344
9D004474  24A56B0C   ADDIU A1, A1, 27404
9D004478  8F868038   LW A2, -32712(GP)
9D00447C  0F401BC5   JAL _sprintf_cdfFnopuxX
9D004480  8F878058   LW A3, -32680(GP)
206:                         tft_writeString(buffer);
9D004484  0F40047B   JAL tft_writeString
9D004488  262400C0   ADDIU A0, S1, 192
207:                         
208:                         // MAC
209:                         outfloat = -0.5;
210:                         t = TMR2;
9D00448C  8E540810   LW S4, 2064(S2)
9D004490  AF948030   SW S4, -32720(GP)
211:                         // do the test
212:                         outfloat =  infloat_1 * infloat_2 + outfloat ;
9D004494  8F848050   LW A0, -32688(GP)
9D004498  0F401879   JAL __mulsf3
9D00449C  8F858054   LW A1, -32684(GP)
9D0044A0  00402021   ADDU A0, V0, ZERO
9D0044A4  3C029D00   LUI V0, -25344
9D0044A8  0F401643   JAL __subsf3
9D0044AC  8C456B44   LW A1, 27460(V0)
9D0044B0  AF828058   SW V0, -32680(GP)
213:                         // compute elapsed time - 5 cycles of overhead
214:                         dt = TMR2 - t - zero_t;
9D0044B4  8E420810   LW V0, 2064(S2)
9D0044B8  0054A023   SUBU S4, V0, S4
9D0044BC  8F828034   LW V0, -32716(GP)
9D0044C0  0282A023   SUBU S4, S4, V0
9D0044C4  AF948038   SW S4, -32712(GP)
215:                         // print it to TFT LCD
216:                         tft_fillRoundRect(0,80, 230, 14, 1, ILI9340_BLACK);// x,y,w,h,radius,color
9D0044C8  AFB30010   SW S3, 16(SP)
9D0044CC  AFA00014   SW ZERO, 20(SP)
9D0044D0  00002021   ADDU A0, ZERO, ZERO
9D0044D4  24050050   ADDIU A1, ZERO, 80
9D0044D8  240600E6   ADDIU A2, ZERO, 230
9D0044DC  0F4002C4   JAL tft_fillRoundRect
9D0044E0  2407000E   ADDIU A3, ZERO, 14
217:                         tft_setCursor(0, 80);
9D0044E4  00002021   ADDU A0, ZERO, ZERO
9D0044E8  0F400518   JAL tft_setCursor
9D0044EC  24050050   ADDIU A1, ZERO, 80
218:                         tft_setTextColor(ILI9340_WHITE); tft_setTextSize(1);
9D0044F0  0F400520   JAL tft_setTextColor
9D0044F4  3404FFFF   ORI A0, ZERO, -1
9D0044F8  0F40051B   JAL tft_setTextSize
9D0044FC  24040001   ADDIU A0, ZERO, 1
219:                         sprintf(buffer, "Mult+add dt value  %d  %5.3f", dt, outfloat);
9D004500  262400C0   ADDIU A0, S1, 192
9D004504  3C059D00   LUI A1, -25344
9D004508  24A56ACC   ADDIU A1, A1, 27340
9D00450C  8F868038   LW A2, -32712(GP)
9D004510  0F401BC5   JAL _sprintf_cdfFnopuxX
9D004514  8F878058   LW A3, -32680(GP)
220:                         tft_writeString(buffer);
9D004518  0F40047B   JAL tft_writeString
9D00451C  262400C0   ADDIU A0, S1, 192
221:                 
222:                         
223:                         // NEVER exit while
224:                       } // END WHILE(1)
9D004520  0B4010EB   J 0x9D0043AC
9D004524  00000000   NOP
225:                   PT_END(pt);
226:                 } // animation thread
9D004528  24020001   ADDIU V0, ZERO, 1
9D00452C  8FBF002C   LW RA, 44(SP)
9D004530  8FB40028   LW S4, 40(SP)
9D004534  8FB30024   LW S3, 36(SP)
9D004538  8FB20020   LW S2, 32(SP)
9D00453C  8FB1001C   LW S1, 28(SP)
9D004540  8FB00018   LW S0, 24(SP)
9D004544  03E00008   JR RA
9D004548  27BD0030   ADDIU SP, SP, 48
227:                 
228:                 // === Main  ======================================================
229:                 void main(void) {
9D00454C  27BDFFE8   ADDIU SP, SP, -24
9D004550  AFBF0014   SW RA, 20(SP)
9D004554  AFB00010   SW S0, 16(SP)
230:                  //SYSTEMConfigPerformance(PBCLK);
231:                   
232:                   ANSELA = 0; ANSELB = 0; 
9D004558  3C02BF88   LUI V0, -16504
9D00455C  AC406000   SW ZERO, 24576(V0)
9D004560  3C02BF88   LUI V0, -16504
9D004564  AC406100   SW ZERO, 24832(V0)
233:                 
234:                   // set up timer on big board
235:                   // timer is used to profile math operations
236:                     OpenTimer2(T2_ON | T2_SOURCE_INT | T2_PS_1_1, 0xffff);
9D004568  3C02BF80   LUI V0, -16512
9D00456C  AC400800   SW ZERO, 2048(V0)
9D004570  3C10BF80   LUI S0, -16512
9D004574  AE000810   SW ZERO, 2064(S0)
9D004578  3403FFFF   ORI V1, ZERO, -1
9D00457C  3C02BF80   LUI V0, -16512
9D004580  AC430820   SW V1, 2080(V0)
9D004584  34038000   ORI V1, ZERO, -32768
9D004588  3C02BF80   LUI V0, -16512
9D00458C  AC430808   SW V1, 2056(V0)
237:                 
238:                   // === config threads ==========
239:                   // turns OFF UART support and debugger pin, unless defines are set
240:                   PT_setup();
9D004590  0F400F70   JAL PT_setup
9D004594  00000000   NOP
241:                 
242:                   // === setup system wide interrupts  ========
243:                   INTEnableSystemMultiVectoredInt();
9D004598  0F401CF4   JAL INTEnableSystemMultiVectoredInt
9D00459C  00000000   NOP
244:                 
245:                   // init the threads
246:                   PT_INIT(&pt_fixed14);
9D0045A0  AF808014   SW ZERO, -32748(GP)
247:                   PT_INIT(&pt_fixed16);
9D0045A4  AF80801C   SW ZERO, -32740(GP)
248:                   PT_INIT(&pt_float);
249:                 
250:                   // init the display
251:                   // NOTE that this init assumes SPI channel 1 connections
252:                   tft_init_hw();
9D0045A8  0F400A59   JAL tft_init_hw
9D0045AC  AF808024   SW ZERO, -32732(GP)
253:                   tft_begin();
9D0045B0  0F400AD5   JAL tft_begin
9D0045B4  00000000   NOP
254:                   tft_fillScreen(ILI9340_BLACK);
9D0045B8  0F400DBC   JAL tft_fillScreen
9D0045BC  00002021   ADDU A0, ZERO, ZERO
255:                   //240x320 vertical display
256:                   tft_setRotation(0); // Use tft_setRotation(1) for 320x240
9D0045C0  0F400E19   JAL tft_setRotation
9D0045C4  00002021   ADDU A0, ZERO, ZERO
257:                 
258:                   // get zero offset reading for timer
259:                    t = TMR2;
9D0045C8  8E020810   LW V0, 2064(S0)
9D0045CC  AF828030   SW V0, -32720(GP)
260:                   // timer reading overhead 
261:                   zero_t = TMR2 - t;
9D0045D0  8E030810   LW V1, 2064(S0)
9D0045D4  00621023   SUBU V0, V1, V0
9D0045D8  AF828034   SW V0, -32716(GP)
262:                   
263:                   // round-robin scheduler for threads
264:                   while (1){
265:                       PT_SCHEDULE(protothread_fixed16(&pt_fixed16));
9D0045DC  0F40104C   JAL 0x9D004130
9D0045E0  2784801C   ADDIU A0, GP, -32740
266:                       PT_SCHEDULE(protothread_fixed14(&pt_fixed14));
9D0045E4  0F400F9E   JAL 0x9D003E78
9D0045E8  27848014   ADDIU A0, GP, -32748
267:                       PT_SCHEDULE(protothread_float(&pt_float));
9D0045EC  0F4010E1   JAL 0x9D004384
9D0045F0  27848024   ADDIU A0, GP, -32732
9D0045F4  0B401177   J 0x9D0045DC
9D0045F8  00000000   NOP
268:                       }
269:                   } // main
270:                 
271:                 // === end  ======================================================
272:                 
---  z:/eedocs/4760/pic/big_board_pt_1_2/pt_cornell_1_2_1.h  --------------------------------------------
1:                   /* 
2:                    * File:   pt_cornell_1_2_1.h
3:                    * Author: brl4
4:                    *
5:                    * Created on Sept 22, 2015
6:                    */
7:                   
8:                   /*
9:                    * Copyright (c) 2004-2005, Swedish Institute of Computer Science.
10:                   * All rights reserved.
11:                   *
12:                   * Redistribution and use in source and binary forms, with or without
13:                   * modification, are permitted provided that the following conditions
14:                   * are met:
15:                   * 1. Redistributions of source code must retain the above copyright
16:                   *    notice, this list of conditions and the following disclaimer.
17:                   * 2. Redistributions in binary form must reproduce the above copyright
18:                   *    notice, this list of conditions and the following disclaimer in the
19:                   *    documentation and/or other materials provided with the distribution.
20:                   * 3. Neither the name of the Institute nor the names of its contributors
21:                   *    may be used to endorse or promote products derived from this software
22:                   *    without specific prior written permission.
23:                   *
24:                   * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
25:                   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
26:                   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
27:                   * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
28:                   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
29:                   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
30:                   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
31:                   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
32:                   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
33:                   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
34:                   * SUCH DAMAGE.
35:                   *
36:                   * This file is part of the Contiki operating system.
37:                   *
38:                   * Author: Adam Dunkels <adam@sics.se>
39:                   *
40:                   * $Id: pt.h,v 1.7 2006/10/02 07:52:56 adam Exp $
41:                   */
42:                  #include <plib.h>
43:                  /**
44:                   * \addtogroup pt
45:                   * @{
46:                   */
47:                  
48:                  /**
49:                   * \file
50:                   * Protothreads implementation.
51:                   * \author
52:                   * Adam Dunkels <adam@sics.se>
53:                   *
54:                   */
55:                  
56:                  #ifndef __PT_H__
57:                  #define __PT_H__
58:                  
59:                  ////////////////////////
60:                  //#include "lc.h"
61:                  ////////////////////////
62:                  /**
63:                   * \file lc.h
64:                   * Local continuations
65:                   * \author
66:                   * Adam Dunkels <adam@sics.se>
67:                   *
68:                   */
69:                  
70:                  #ifdef DOXYGEN
71:                  /**
72:                   * Initialize a local continuation.
73:                   *
74:                   * This operation initializes the local continuation, thereby
75:                   * unsetting any previously set continuation state.
76:                   *
77:                   * \hideinitializer
78:                   */
79:                  #define LC_INIT(lc)
80:                  
81:                  /**
82:                   * Set a local continuation.
83:                   *
84:                   * The set operation saves the state of the function at the point
85:                   * where the operation is executed. As far as the set operation is
86:                   * concerned, the state of the function does <b>not</b> include the
87:                   * call-stack or local (automatic) variables, but only the program
88:                   * counter and such CPU registers that needs to be saved.
89:                   *
90:                   * \hideinitializer
91:                   */
92:                  #define LC_SET(lc)
93:                  
94:                  /**
95:                   * Resume a local continuation.
96:                   *
97:                   * The resume operation resumes a previously set local continuation, thus
98:                   * restoring the state in which the function was when the local
99:                   * continuation was set. If the local continuation has not been
100:                  * previously set, the resume operation does nothing.
101:                  *
102:                  * \hideinitializer
103:                  */
104:                 #define LC_RESUME(lc)
105:                 
106:                 /**
107:                  * Mark the end of local continuation usage.
108:                  *
109:                  * The end operation signifies that local continuations should not be
110:                  * used any more in the function. This operation is not needed for
111:                  * most implementations of local continuation, but is required by a
112:                  * few implementations.
113:                  *
114:                  * \hideinitializer 
115:                  */
116:                 #define LC_END(lc)
117:                 
118:                 /**
119:                  * \var typedef lc_t;
120:                  *
121:                  * The local continuation type.
122:                  *
123:                  * \hideinitializer
124:                  */
125:                 #endif /* DOXYGEN */
126:                 
127:                 //#ifndef __LC_H__
128:                 //#define __LC_H__
129:                 
130:                 
131:                 //#ifdef LC_INCLUDE
132:                 //#include LC_INCLUDE
133:                 //#else
134:                 
135:                 /////////////////////////////
136:                 //#include "lc-switch.h"
137:                 /////////////////////////////
138:                 
139:                 //#ifndef __LC_SWITCH_H__
140:                 //#define __LC_SWITCH_H__
141:                 
142:                 /* WARNING! lc implementation using switch() does not work if an
143:                    LC_SET() is done within another switch() statement! */
144:                 
145:                 /** \hideinitializer */
146:                 /*
147:                 typedef unsigned short lc_t;
148:                 
149:                 #define LC_INIT(s) s = 0;
150:                 
151:                 #define LC_RESUME(s) switch(s) { case 0:
152:                 
153:                 #define LC_SET(s) s = __LINE__; case __LINE__:
154:                 
155:                 #define LC_END(s) }
156:                 
157:                 #endif /* __LC_SWITCH_H__ */
158:                 
159:                 /** @} */
160:                 
161:                 //#endif /* LC_INCLUDE */
162:                 
163:                 //#endif /* __LC_H__ */
164:                 
165:                 /** @} */
166:                 /** @} */
167:                 
168:                 /////////////////////////////
169:                 //#include "lc-addrlabels.h"
170:                 /////////////////////////////
171:                 
172:                 #ifndef __LC_ADDRLABELS_H__
173:                 #define __LC_ADDRLABELS_H__
174:                 
175:                 /** \hideinitializer */
176:                 typedef void * lc_t;
177:                 
178:                 #define LC_INIT(s) s = NULL
179:                 
180:                 #define LC_RESUME(s)				\
181:                   do {						\
182:                     if(s != NULL) {				\
183:                       goto *s;					\
184:                     }						\
185:                   } while(0)
186:                 
187:                 #define LC_CONCAT2(s1, s2) s1##s2
188:                 #define LC_CONCAT(s1, s2) LC_CONCAT2(s1, s2)
189:                 
190:                 #define LC_SET(s)				\
191:                   do {						\
192:                     LC_CONCAT(LC_LABEL, __LINE__):   	        \
193:                     (s) = &&LC_CONCAT(LC_LABEL, __LINE__);	\
194:                   } while(0)
195:                 
196:                 #define LC_END(s)
197:                 
198:                 #endif /* __LC_ADDRLABELS_H__ */
199:                 
200:                 
201:                 
202:                 //////////////////////////////////////////
203:                 struct pt {
204:                   lc_t lc;
205:                   int pri;
206:                 };
207:                 
208:                 #define PT_WAITING 0
209:                 #define PT_YIELDED 1
210:                 #define PT_EXITED  2
211:                 #define PT_ENDED   3
212:                 
213:                 /**
214:                  * \name Initialization
215:                  * @{
216:                  */
217:                 
218:                 /**
219:                  * Initialize a protothread.
220:                  *
221:                  * Initializes a protothread. Initialization must be done prior to
222:                  * starting to execute the protothread.
223:                  *
224:                  * \param pt A pointer to the protothread control structure.
225:                  *
226:                  * \sa PT_SPAWN()
227:                  *
228:                  * \hideinitializer
229:                  */
230:                 #define PT_INIT(pt)   LC_INIT((pt)->lc)
231:                 
232:                 /** @} */
233:                 
234:                 /**
235:                  * \name Declaration and definition
236:                  * @{
237:                  */
238:                 
239:                 /**
240:                  * Declaration of a protothread.
241:                  *
242:                  * This macro is used to declare a protothread. All protothreads must
243:                  * be declared with this macro.
244:                  *
245:                  * \param name_args The name and arguments of the C function
246:                  * implementing the protothread.
247:                  *
248:                  * \hideinitializer
249:                  */
250:                 #define PT_THREAD(name_args) char name_args
251:                 
252:                 /**
253:                  * Declare the start of a protothread inside the C function
254:                  * implementing the protothread.
255:                  *
256:                  * This macro is used to declare the starting point of a
257:                  * protothread. It should be placed at the start of the function in
258:                  * which the protothread runs. All C statements above the PT_BEGIN()
259:                  * invokation will be executed each time the protothread is scheduled.
260:                  *
261:                  * \param pt A pointer to the protothread control structure.
262:                  *
263:                  * \hideinitializer
264:                  */
265:                 #define PT_BEGIN(pt) { char PT_YIELD_FLAG = 1; LC_RESUME((pt)->lc)
266:                 
267:                 /**
268:                  * Declare the end of a protothread.
269:                  *
270:                  * This macro is used for declaring that a protothread ends. It must
271:                  * always be used together with a matching PT_BEGIN() macro.
272:                  *
273:                  * \param pt A pointer to the protothread control structure.
274:                  *
275:                  * \hideinitializer
276:                  */
277:                 #define PT_END(pt) LC_END((pt)->lc); PT_YIELD_FLAG = 0; \
278:                                    PT_INIT(pt); return PT_ENDED; }
279:                 
280:                 /** @} */
281:                 
282:                 /**
283:                  * \name Blocked wait
284:                  * @{
285:                  */
286:                 
287:                 /**
288:                  * Block and wait until condition is true.
289:                  *
290:                  * This macro blocks the protothread until the specified condition is
291:                  * true.
292:                  *
293:                  * \param pt A pointer to the protothread control structure.
294:                  * \param condition The condition.
295:                  *
296:                  * \hideinitializer
297:                  */
298:                 #define PT_WAIT_UNTIL(pt, condition)	        \
299:                   do {						\
300:                     LC_SET((pt)->lc);				\
301:                     if(!(condition)) {				\
302:                       return PT_WAITING;			\
303:                     }						\
304:                   } while(0)
305:                 
306:                 /**
307:                  * Block and wait while condition is true.
308:                  *
309:                  * This function blocks and waits while condition is true. See
310:                  * PT_WAIT_UNTIL().
311:                  *
312:                  * \param pt A pointer to the protothread control structure.
313:                  * \param cond The condition.
314:                  *
315:                  * \hideinitializer
316:                  */
317:                 #define PT_WAIT_WHILE(pt, cond)  PT_WAIT_UNTIL((pt), !(cond))
318:                 
319:                 /** @} */
320:                 
321:                 /**
322:                  * \name Hierarchical protothreads
323:                  * @{
324:                  */
325:                 
326:                 /**
327:                  * Block and wait until a child protothread completes.
328:                  *
329:                  * This macro schedules a child protothread. The current protothread
330:                  * will block until the child protothread completes.
331:                  *
332:                  * \note The child protothread must be manually initialized with the
333:                  * PT_INIT() function before this function is used.
334:                  *
335:                  * \param pt A pointer to the protothread control structure.
336:                  * \param thread The child protothread with arguments
337:                  *
338:                  * \sa PT_SPAWN()
339:                  *
340:                  * \hideinitializer
341:                  */
342:                 #define PT_WAIT_THREAD(pt, thread) PT_WAIT_WHILE((pt), PT_SCHEDULE(thread))
343:                 
344:                 /**
345:                  * Spawn a child protothread and wait until it exits.
346:                  *
347:                  * This macro spawns a child protothread and waits until it exits. The
348:                  * macro can only be used within a protothread.
349:                  *
350:                  * \param pt A pointer to the protothread control structure.
351:                  * \param child A pointer to the child protothread's control structure.
352:                  * \param thread The child protothread with arguments
353:                  *
354:                  * \hideinitializer
355:                  */
356:                 #define PT_SPAWN(pt, child, thread)		\
357:                   do {						\
358:                     PT_INIT((child));				\
359:                     PT_WAIT_THREAD((pt), (thread));		\
360:                   } while(0)
361:                 
362:                 /** @} */
363:                 
364:                 /**
365:                  * \name Exiting and restarting
366:                  * @{
367:                  */
368:                 
369:                 /**
370:                  * Restart the protothread.
371:                  *
372:                  * This macro will block and cause the running protothread to restart
373:                  * its execution at the place of the PT_BEGIN() call.
374:                  *
375:                  * \param pt A pointer to the protothread control structure.
376:                  *
377:                  * \hideinitializer
378:                  */
379:                 #define PT_RESTART(pt)				\
380:                   do {						\
381:                     PT_INIT(pt);				\
382:                     return PT_WAITING;			\
383:                   } while(0)
384:                 
385:                 /**
386:                  * Exit the protothread.
387:                  *
388:                  * This macro causes the protothread to exit. If the protothread was
389:                  * spawned by another protothread, the parent protothread will become
390:                  * unblocked and can continue to run.
391:                  *
392:                  * \param pt A pointer to the protothread control structure.
393:                  *
394:                  * \hideinitializer
395:                  */
396:                 #define PT_EXIT(pt)				\
397:                   do {						\
398:                     PT_INIT(pt);				\
399:                     return PT_EXITED;			\
400:                   } while(0)
401:                 
402:                 /** @} */
403:                 
404:                 /**
405:                  * \name Calling a protothread
406:                  * @{
407:                  */
408:                 
409:                 /**
410:                  * Schedule a protothread.
411:                  *
412:                  * This function shedules a protothread. The return value of the
413:                  * function is non-zero if the protothread is running or zero if the
414:                  * protothread has exited.
415:                  *
416:                  * \param f The call to the C function implementing the protothread to
417:                  * be scheduled
418:                  *
419:                  * \hideinitializer
420:                  */
421:                 #define PT_SCHEDULE(f) ((f) < PT_EXITED)
422:                 //#define PT_SCHEDULE(f) ((f))
423:                 
424:                 /** @} */
425:                 
426:                 /**
427:                  * \name Yielding from a protothread
428:                  * @{
429:                  */
430:                 
431:                 /**
432:                  * Yield from the current protothread.
433:                  *
434:                  * This function will yield the protothread, thereby allowing other
435:                  * processing to take place in the system.
436:                  *
437:                  * \param pt A pointer to the protothread control structure.
438:                  *
439:                  * \hideinitializer
440:                  */
441:                 #define PT_YIELD(pt)				\
442:                   do {						\
443:                     PT_YIELD_FLAG = 0;				\
444:                     LC_SET((pt)->lc);				\
445:                     if(PT_YIELD_FLAG == 0) {			\
446:                       return PT_YIELDED;			\
447:                     }						\
448:                   } while(0)
449:                 
450:                 /**
451:                  * \brief      Yield from the protothread until a condition occurs.
452:                  * \param pt   A pointer to the protothread control structure.
453:                  * \param cond The condition.
454:                  *
455:                  *             This function will yield the protothread, until the
456:                  *             specified condition evaluates to true.
457:                  *
458:                  *
459:                  * \hideinitializer
460:                  */
461:                 #define PT_YIELD_UNTIL(pt, cond)		\
462:                   do {						\
463:                     PT_YIELD_FLAG = 0;				\
464:                     LC_SET((pt)->lc);				\
465:                     if((PT_YIELD_FLAG == 0) || !(cond)) {	\
466:                       return PT_YIELDED;                        \
467:                     }						\
468:                   } while(0)
469:                 
470:                 /** @} */
471:                 
472:                 #endif /* __PT_H__ */
473:                 
474:                 #ifndef __PT_SEM_H__
475:                 #define __PT_SEM_H__
476:                 
477:                 //#include "pt.h"
478:                 
479:                 struct pt_sem {
480:                   unsigned int count;
481:                 };
482:                 
483:                 /**
484:                  * Initialize a semaphore
485:                  *
486:                  * This macro initializes a semaphore with a value for the
487:                  * counter. Internally, the semaphores use an "unsigned int" to
488:                  * represent the counter, and therefore the "count" argument should be
489:                  * within range of an unsigned int.
490:                  *
491:                  * \param s (struct pt_sem *) A pointer to the pt_sem struct
492:                  * representing the semaphore
493:                  *
494:                  * \param c (unsigned int) The initial count of the semaphore.
495:                  * \hide initializer
496:                  */
497:                 #define PT_SEM_INIT(s, c) (s)->count = c
498:                 
499:                 /**
500:                  * Wait for a semaphore
501:                  *
502:                  * This macro carries out the "wait" operation on the semaphore. The
503:                  * wait operation causes the protothread to block while the counter is
504:                  * zero. When the counter reaches a value larger than zero, the
505:                  * protothread will continue.
506:                  *
507:                  * \param pt (struct pt *) A pointer to the protothread (struct pt) in
508:                  * which the operation is executed.
509:                  *
510:                  * \param s (struct pt_sem *) A pointer to the pt_sem struct
511:                  * representing the semaphore
512:                  *
513:                  * \hideinitializer
514:                  */
515:                 #define PT_SEM_WAIT(pt, s)	\
516:                   do {						\
517:                     PT_WAIT_UNTIL(pt, (s)->count > 0);		\
518:                     --(s)->count;				\
519:                   } while(0)
520:                 
521:                 /**
522:                  * Signal a semaphore
523:                  *
524:                  * This macro carries out the "signal" operation on the semaphore. The
525:                  * signal operation increments the counter inside the semaphore, which
526:                  * eventually will cause waiting protothreads to continue executing.
527:                  *
528:                  * \param pt (struct pt *) A pointer to the protothread (struct pt) in
529:                  * which the operation is executed.
530:                  *
531:                  * \param s (struct pt_sem *) A pointer to the pt_sem struct
532:                  * representing the semaphore
533:                  *
534:                  * \hideinitializer
535:                  */
536:                 #define PT_SEM_SIGNAL(pt, s) ++(s)->count
537:                 
538:                 #endif /* __PT_SEM_H__ */
539:                 
540:                 //=====================================================================
541:                 //=== BRL4 additions for PIC 32 =======================================
542:                 //=====================================================================
543:                 
544:                 // macro to time a thread execution interveal in millisec
545:                 // max time 4000 sec
546:                 //#include <plib.h>
547:                 //#include <limits.h>
548:                 //#include "config.h"
549:                 
550:                 #define PT_YIELD_TIME_msec(delay_time)  \
551:                     do { static unsigned int time_thread ;\
552:                     time_thread = time_tick_millsec + (unsigned int)delay_time ; \
553:                     PT_YIELD_UNTIL(pt, (time_tick_millsec >= time_thread)); \
554:                     } while(0);
555:                 
556:                 // macro to return system time
557:                 #define PT_GET_TIME() (time_tick_millsec)
558:                 
559:                 // init rate sehcduler
560:                 //#define PT_INIT(pt, priority)   LC_INIT((pt)->lc ; (pt)->pri = priority)
561:                 //PT_PRIORITY_INIT
562:                 #define PT_RATE_INIT() int pt_pri_count = 0;
563:                 // maitain proority frame count
564:                 //PT_PRIORITY_LOOP maitains a counter used to control execution
565:                 #define PT_RATE_LOOP() pt_pri_count = (pt_pri_count+1) & 0xf ;
566:                 // schecedule priority thread
567:                 //PT_PRIORITY_SCHEDULE
568:                 // 5 levels
569:                 // rate 0 is highest -- every time thru loop
570:                 // priority 1 -- every 2 times thru loop
571:                 // priority 2 -- every 4 times thru loop
572:                 //  3 is  -- every 8 times thru loop
573:                 #define PT_RATE_SCHEDULE(f,rate) \
574:                     if((rate==0) | \
575:                     (rate==1 && ((pt_pri_count & 0b1)==0) ) | \
576:                     (rate==2 && ((pt_pri_count & 0b11)==0) ) | \
577:                     (rate==3 && ((pt_pri_count & 0b111)==0)) | \
578:                     (rate==4 && ((pt_pri_count & 0b1111)==0))) \
579:                         PT_SCHEDULE(f);
580:                 
581:                 // macro to use 4 bit DAC as debugger output
582:                 // level range 0-15; duration in microseconds
583:                 // -- with zero meaning HOLD it on forever
584:                 //while((signed int)ReadTimer45() <= time_hold){};
585:                 // time_hold = duration + ReadTimer45() ;
586:                 #define PT_DEBUG_VALUE(level, duration) \
587:                 do { static int i ; \
588:                     CVRCON = CVRCON_setup | (level & 0xf); \
589:                     if (duration>0){                   \
590:                         for (i=0; i<duration*7; i++){};\
591:                         CVRCON = CVRCON_setup; \
592:                     } \
593:                 } while(0);
594:                 
595:                 // macros to manipulate a semaphore without blocking
596:                 #define PT_SEM_SET(s) (s)->count=1
597:                 #define PT_SEM_CLEAR(s) (s)->count=0
598:                 #define PT_SEM_READ(s) (s)->count
599:                 #define PT_SEM_ACCEPT(s) \
600:                   s->count; \
601:                   if (s->count) s->count-- ; \
602:                 
603:                 //====================================================================
604:                 //=== serial setup ===================================================
605:                 //#ifdef use_uart_serial
606:                 ///////////////////////////
607:                 // UART parameters
608:                 
609:                 #define PB_DIVISOR (1 << OSCCONbits.PBDIV) // read the peripheral bus divider, FPBDIV
610:                 #define PB_FREQ sys_clock/PB_DIVISOR // periperhal bus frequency
611:                 #define clrscr() printf( "\x1b[2J")
612:                 #define home()   printf( "\x1b[H")
613:                 #define pcr()    printf( '\r')
614:                 #define crlf     putchar(0x0a); putchar(0x0d);
615:                 #define backspace 0x7f // make sure your backspace matches this!
616:                 #define max_chars 64 // for input/output buffer
617:                 //====================================================================
618:                 // build a string from the UART2 /////////////
619:                 //////////////////////////////////////////////
620:                 char PT_term_buffer[max_chars];
621:                 int num_char;
622:                 int PT_GetSerialBuffer(struct pt *pt)
623:                 {
624:                     static char character;
625:                     // mark the beginnning of the input thread
626:                     PT_BEGIN(pt);
9D0039B8  8C820000   LW V0, 0(A0)
9D0039BC  5040006C   BEQL V0, ZERO, 0x9D003B70
9D0039C0  AF808088   SW ZERO, -32632(GP)
9D0039C4  00400008   JR V0
9D0039C8  00000000   NOP
627:                 
628:                     num_char = 0;
629:                     //memset(term_buffer, 0, max_chars);
630:                 
631:                     while(num_char < max_chars)
9D003B4C  8F828088   LW V0, -32632(GP)
9D003B50  28420040   SLTI V0, V0, 64
9D003B54  54400007   BNEL V0, ZERO, 0x9D003B74
9D003B58  3C029D00   LUI V0, -25344
632:                     {
633:                         // get the character
634:                         // yield until there is a valid character so that other
635:                         // threads can execute
636:                         PT_YIELD_UNTIL(pt, UARTReceivedDataIsAvailable(UART2));
9D0039CC  3C029D00   LUI V0, -25344
9D0039D0  244239CC   ADDIU V0, V0, 14796
9D0039D4  AC820000   SW V0, 0(A0)
9D0039E8  10A00069   BEQ A1, ZERO, 0x9D003B90
9D0039EC  24020001   ADDIU V0, ZERO, 1
9D003B70  3C029D00   LUI V0, -25344
9D003B74  244239CC   ADDIU V0, V0, 14796
9D003B78  AC820000   SW V0, 0(A0)
9D003B7C  03E00008   JR RA
9D003B80  24020001   ADDIU V0, ZERO, 1
637:                        // while(!UARTReceivedDataIsAvailable(UART2)){};
638:                         character = UARTGetDataByte(UART2);
9D0039F4  A382805C   SB V0, -32676(GP)
639:                         PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D0039F8  3C029D00   LUI V0, -25344
9D0039FC  24423A0C   ADDIU V0, V0, 14860
9D003A00  AC820000   SW V0, 0(A0)
9D003A04  03E00008   JR RA
9D003A08  24020001   ADDIU V0, ZERO, 1
9D003A0C  3C029D00   LUI V0, -25344
9D003A10  24423A0C   ADDIU V0, V0, 14860
9D003A14  AC820000   SW V0, 0(A0)
9D003A28  14A00059   BNE A1, ZERO, 0x9D003B90
9D003A2C  24020001   ADDIU V0, ZERO, 1
640:                         UARTSendDataByte(UART2, character);
9D003A30  8382805C   LB V0, -32676(GP)
641:                 
642:                         // unomment to check backspace character!!!
643:                         //printf("--%x--",character );
644:                 
645:                         // end line
646:                         if(character == '\r'){
9D003A3C  2403000D   ADDIU V1, ZERO, 13
9D003A40  14430017   BNE V0, V1, 0x9D003AA0
9D003A44  2403007F   ADDIU V1, ZERO, 127
647:                             PT_term_buffer[num_char] = 0; // zero terminate the string
9D003A48  3C02A000   LUI V0, -24576
9D003A4C  244200FC   ADDIU V0, V0, 252
9D003A50  8F838088   LW V1, -32632(GP)
9D003A54  00621021   ADDU V0, V1, V0
9D003A58  A0400000   SB ZERO, 0(V0)
648:                             //crlf; // send a new line
649:                             PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D003A5C  3C029D00   LUI V0, -25344
9D003A60  24423A70   ADDIU V0, V0, 14960
9D003A64  AC820000   SW V0, 0(A0)
9D003A68  03E00008   JR RA
9D003A6C  24020001   ADDIU V0, ZERO, 1
9D003A70  3C029D00   LUI V0, -25344
9D003A74  24423A70   ADDIU V0, V0, 14960
9D003A78  AC820000   SW V0, 0(A0)
9D003A8C  14600036   BNE V1, ZERO, 0x9D003B68
9D003A90  2403000A   ADDIU V1, ZERO, 10
9D003B68  03E00008   JR RA
9D003B6C  24020001   ADDIU V0, ZERO, 1
650:                             UARTSendDataByte(UART2, '\n');
651:                             break;
652:                         }
653:                         // backspace
654:                         else if (character == backspace){
9D003AA0  14430024   BNE V0, V1, 0x9D003B34
9D003AA4  8F838088   LW V1, -32632(GP)
9D003AA8  0B400EE1   J 0x9D003B84
9D003AAC  3C029D00   LUI V0, -25344
655:                             PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D003AB0  3C029D00   LUI V0, -25344
9D003AB4  24423AB0   ADDIU V0, V0, 15024
9D003AB8  AC820000   SW V0, 0(A0)
9D003ACC  14A00030   BNE A1, ZERO, 0x9D003B90
9D003AD0  24020001   ADDIU V0, ZERO, 1
9D003B84  24423AB0   ADDIU V0, V0, 15024
9D003B88  AC820000   SW V0, 0(A0)
9D003B8C  24020001   ADDIU V0, ZERO, 1
656:                             UARTSendDataByte(UART2, ' ');
657:                             PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D003ADC  3C029D00   LUI V0, -25344
9D003AE0  24423AF0   ADDIU V0, V0, 15088
9D003AE4  AC820000   SW V0, 0(A0)
9D003AE8  03E00008   JR RA
9D003AEC  24020001   ADDIU V0, ZERO, 1
9D003AF0  3C029D00   LUI V0, -25344
9D003AF4  24423AF0   ADDIU V0, V0, 15088
9D003AF8  AC820000   SW V0, 0(A0)
9D003B0C  14A00020   BNE A1, ZERO, 0x9D003B90
9D003B10  24020001   ADDIU V0, ZERO, 1
658:                             UARTSendDataByte(UART2, backspace);
659:                             num_char--;
9D003B1C  8F828088   LW V0, -32632(GP)
9D003B20  2442FFFF   ADDIU V0, V0, -1
9D003B2C  0B400ED3   J 0x9D003B4C
9D003B30  AF828088   SW V0, -32632(GP)
660:                             // check for buffer underflow
661:                             if (num_char<0) {num_char = 0 ;}
9D003B24  04420012   BLTZL V0, 0x9D003B70
9D003B28  AF808088   SW ZERO, -32632(GP)
662:                         }
663:                         else  {PT_term_buffer[num_char++] = character ;}
9D003B34  24650001   ADDIU A1, V1, 1
9D003B38  AF858088   SW A1, -32632(GP)
9D003B3C  3C05A000   LUI A1, -24576
9D003B40  24A500FC   ADDIU A1, A1, 252
9D003B44  00651821   ADDU V1, V1, A1
9D003B48  A0620000   SB V0, 0(V1)
664:                          //if (character == backspace)
665:                 
666:                     } //end while(num_char < max_size)
667:                 
668:                     // kill this input thread, to allow spawning thread to execute
669:                     PT_EXIT(pt);
9D003A98  0B400ED8   J 0x9D003B60
9D003A9C  AC800000   SW ZERO, 0(A0)
9D003B5C  AC800000   SW ZERO, 0(A0)
9D003B60  03E00008   JR RA
9D003B64  24020002   ADDIU V0, ZERO, 2
670:                     // and indicate the end of the thread
671:                     PT_END(pt);
672:                 }
9D003B90  03E00008   JR RA
9D003B94  00000000   NOP
673:                 
674:                 //====================================================================
675:                 // === send a string to the UART2 ====================================
676:                 char PT_send_buffer[max_chars];
677:                 int num_send_chars ;
678:                 int PutSerialBuffer(struct pt *pt)
679:                 {
680:                     PT_BEGIN(pt);
9D003B98  8C820000   LW V0, 0(A0)
9D003B9C  14400003   BNE V0, ZERO, 0x9D003BAC
9D003BA0  3C029D00   LUI V0, -25344
681:                     num_send_chars = 0;
682:                     while (PT_send_buffer[num_send_chars] != 0){
9D003BA4  0B400EFB   J 0x9D003BEC
9D003BA8  AF808080   SW ZERO, -32640(GP)
9D003BEC  3C02A000   LUI V0, -24576
9D003BF0  24420080   ADDIU V0, V0, 128
9D003BF4  8F838080   LW V1, -32640(GP)
9D003BF8  00621021   ADDU V0, V1, V0
9D003BFC  80420000   LB V0, 0(V0)
9D003C00  54400004   BNEL V0, ZERO, 0x9D003C14
9D003C04  3C029D00   LUI V0, -25344
683:                         PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D003BAC  24423BAC   ADDIU V0, V0, 15276
9D003BB0  AC820000   SW V0, 0(A0)
9D003BC4  14A00016   BNE A1, ZERO, 0x9D003C20
9D003BC8  24020001   ADDIU V0, ZERO, 1
9D003C14  24423BAC   ADDIU V0, V0, 15276
9D003C18  AC820000   SW V0, 0(A0)
9D003C1C  24020001   ADDIU V0, ZERO, 1
684:                         UARTSendDataByte(UART2, PT_send_buffer[num_send_chars]);
9D003BCC  8F828080   LW V0, -32640(GP)
9D003BD0  3C05A000   LUI A1, -24576
9D003BD4  24A50080   ADDIU A1, A1, 128
9D003BD8  00452821   ADDU A1, V0, A1
685:                         num_send_chars++;
9D003BE4  24420001   ADDIU V0, V0, 1
9D003BE8  AF828080   SW V0, -32640(GP)
686:                     }
687:                     // kill this output thread, to allow spawning thread to execute
688:                     PT_EXIT(pt);
9D003C08  AC800000   SW ZERO, 0(A0)
9D003C0C  03E00008   JR RA
9D003C10  24020002   ADDIU V0, ZERO, 2
689:                     // and indicate the end of the thread
690:                     PT_END(pt);
691:                 }
9D003C20  03E00008   JR RA
9D003C24  00000000   NOP
692:                 
693:                 //====================================================================
694:                 // === DMA send string to the UART2 ==================================
695:                 int PT_DMA_PutSerialBuffer(struct pt *pt)
696:                 {
9D003C28  27BDFFE8   ADDIU SP, SP, -24
9D003C2C  AFBF0014   SW RA, 20(SP)
9D003C30  AFB00010   SW S0, 16(SP)
697:                     PT_BEGIN(pt);
9D003C34  8C820000   LW V0, 0(A0)
9D003C38  10400003   BEQ V0, ZERO, 0x9D003C48
9D003C3C  00808021   ADDU S0, A0, ZERO
9D003C40  00400008   JR V0
9D003C44  00000000   NOP
698:                     //mPORTBSetBits(BIT_0);
699:                     // check for null string
700:                     if (PT_send_buffer[0]==0)PT_EXIT(pt);
9D003C48  3C02A000   LUI V0, -24576
9D003C4C  80430080   LB V1, 128(V0)
9D003C50  10600033   BEQ V1, ZERO, 0x9D003D20
9D003C54  24020002   ADDIU V0, ZERO, 2
9D003C58  0B400F40   J 0x9D003D00
9D003C5C  3C029D00   LUI V0, -25344
701:                     // sent the first character
702:                     PT_YIELD_UNTIL(pt, UARTTransmitterIsReady(UART2));
9D003C60  3C029D00   LUI V0, -25344
9D003C64  24423C60   ADDIU V0, V0, 15456
9D003C68  AC820000   SW V0, 0(A0)
9D003C7C  14800028   BNE A0, ZERO, 0x9D003D20
9D003C80  24020001   ADDIU V0, ZERO, 1
9D003D00  24423C60   ADDIU V0, V0, 15456
9D003D04  AC820000   SW V0, 0(A0)
9D003D08  0B400F48   J 0x9D003D20
9D003D0C  24020001   ADDIU V0, ZERO, 1
703:                     UARTSendDataByte(UART2, PT_send_buffer[0]);
9D003C84  3C02A000   LUI V0, -24576
704:                     //DmaChnStartTxfer(DMA_CHANNEL1, DMA_WAIT_NOT, 0);
705:                     // start the DMA
706:                     DmaChnEnable(DMA_CHANNEL1);
9D003C90  0F401D52   JAL DmaChnEnable
9D003C94  24040001   ADDIU A0, ZERO, 1
707:                     // wait for DMA done
708:                     //mPORTBClearBits(BIT_0);
709:                     PT_YIELD_UNTIL(pt, DmaChnGetEvFlags(DMA_CHANNEL1) & DMA_EV_BLOCK_DONE);
9D003C98  3C029D00   LUI V0, -25344
9D003C9C  24423CAC   ADDIU V0, V0, 15532
9D003CA0  AE020000   SW V0, 0(S0)
9D003CA4  0B400F48   J 0x9D003D20
9D003CA8  24020001   ADDIU V0, ZERO, 1
9D003CAC  3C029D00   LUI V0, -25344
9D003CB0  24423CAC   ADDIU V0, V0, 15532
9D003CB4  AC820000   SW V0, 0(A0)
9D003CB8  0F401D70   JAL DmaChnGetEvFlags
9D003CBC  24040001   ADDIU A0, ZERO, 1
9D003CC0  30430008   ANDI V1, V0, 8
9D003CC4  14600012   BNE V1, ZERO, 0x9D003D10
9D003CC8  24020001   ADDIU V0, ZERO, 1
9D003CCC  0B400F49   J 0x9D003D24
9D003CD0  8FBF0014   LW RA, 20(SP)
710:                     //wait until the transmit buffer is empty
711:                     PT_YIELD_UNTIL(pt, U2STA&0x100);
9D003CD4  3C029D00   LUI V0, -25344
9D003CD8  24423CD4   ADDIU V0, V0, 15572
9D003CDC  AC820000   SW V0, 0(A0)
9D003CE0  3C02BF80   LUI V0, -16512
9D003CE4  8C426210   LW V0, 25104(V0)
9D003CE8  30420100   ANDI V0, V0, 256
9D003CEC  5040000C   BEQL V0, ZERO, 0x9D003D20
9D003CF0  24020001   ADDIU V0, ZERO, 1
9D003D10  3C029D00   LUI V0, -25344
9D003D14  24423CD4   ADDIU V0, V0, 15572
9D003D18  AE020000   SW V0, 0(S0)
9D003D1C  24020001   ADDIU V0, ZERO, 1
712:                     
713:                     // kill this output thread, to allow spawning thread to execute
714:                     PT_EXIT(pt);
9D003CF4  AC800000   SW ZERO, 0(A0)
9D003CF8  0B400F48   J 0x9D003D20
9D003CFC  24020002   ADDIU V0, ZERO, 2
715:                     // and indicate the end of the thread
716:                     PT_END(pt);
717:                 }
9D003D20  8FBF0014   LW RA, 20(SP)
9D003D24  8FB00010   LW S0, 16(SP)
9D003D28  03E00008   JR RA
9D003D2C  27BD0018   ADDIU SP, SP, 24
718:                 //#endif //#ifdef use_uart_serial
719:                 
720:                 //======================================================================
721:                 // vref confing (if used)
722:                 int CVRCON_setup ;
723:                 
724:                 // system time
725:                 volatile unsigned int time_tick_millsec ;
726:                 // force full context save
727:                 //int w;
728:                 //void waste(void){w=1;};
729:                 // Timer 5 interrupt handler ///////
730:                 // ipl2 means "interrupt priority level 2"
731:                 void __ISR(_TIMER_5_VECTOR, IPL2AUTO) Timer5Handler(void) //_TIMER_5_VECTOR
732:                 {
9D003D30  415DE800   RDPGPR SP, SP
9D003D34  401B7000   MFC0 K1, EPC
9D003D38  401A6002   MFC0 K0, SRSCtl
9D003D3C  27BDFFE8   ADDIU SP, SP, -24
9D003D40  AFBB0014   SW K1, 20(SP)
9D003D44  401B6000   MFC0 K1, Status
9D003D48  AFBA000C   SW K0, 12(SP)
9D003D4C  AFBB0010   SW K1, 16(SP)
9D003D50  7C1B7844   INS K1, ZERO, 1, 15
9D003D54  377B0800   ORI K1, K1, 2048
9D003D58  409B6000   MTC0 K1, Status
9D003D5C  AFA30004   SW V1, 4(SP)
9D003D60  AFA20000   SW V0, 0(SP)
733:                     // clear the interrupt flag
734:                     mT5ClearIntFlag();
9D003D64  3C030100   LUI V1, 256
9D003D68  3C02BF88   LUI V0, -16504
9D003D6C  AC431034   SW V1, 4148(V0)
735:                     //count milliseconds
736:                     time_tick_millsec++ ;
9D003D70  8F828084   LW V0, -32636(GP)
9D003D74  24420001   ADDIU V0, V0, 1
9D003D78  AF828084   SW V0, -32636(GP)
737:                     //waste();
738:                 }
9D003D7C  8FA2000C   LW V0, 12(SP)
9D003D80  3042000F   ANDI V0, V0, 15
9D003D84  14400003   BNE V0, ZERO, 0x9D003D94
9D003D88  00000000   NOP
9D003D8C  8FA30004   LW V1, 4(SP)
9D003D90  8FA20000   LW V0, 0(SP)
9D003D94  41606000   DI ZERO
9D003D98  000000C0   EHB
9D003D9C  8FBA0014   LW K0, 20(SP)
9D003DA0  8FBB0010   LW K1, 16(SP)
9D003DA4  409A7000   MTC0 K0, EPC
9D003DA8  8FBA000C   LW K0, 12(SP)
9D003DAC  27BD0018   ADDIU SP, SP, 24
9D003DB0  409A6002   MTC0 K0, SRSCtl
9D003DB4  41DDE800   WRPGPR SP, SP
9D003DB8  409B6000   MTC0 K1, Status
9D003DBC  42000018   ERET
739:                 
740:                 void PT_setup (void)
741:                 {
9D003DC0  27BDFFE8   ADDIU SP, SP, -24
9D003DC4  AFBF0014   SW RA, 20(SP)
742:                   // Configure the device for maximum performance but do not change the PBDIV
743:                     // Given the options, this function will change the flash wait states, RAM
744:                     // wait state and enable prefetch cache but will not change the PBDIV.
745:                     // The PBDIV value is already set via the pragma FPBDIV option above..
746:                     SYSTEMConfig(sys_clock, SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
747:                 
748:                   ANSELA =0; //make sure analog is cleared
9D003DEC  3C02BF88   LUI V0, -16504
9D003DF0  AC406000   SW ZERO, 24576(V0)
749:                   ANSELB =0;
9D003DF4  3C02BF88   LUI V0, -16504
9D003DF8  AC406100   SW ZERO, 24832(V0)
750:                   
751:                 #ifdef use_uart_serial
752:                   // === init the uart2 ===================
753:                  PPSInput (2, U2RX, RPB11); //Assign U2RX to pin RPB11 -- Physical pin 22 on 28 PDIP
754:                  PPSOutput(4, RPB10, U2TX); //Assign U2TX to pin RPB10 -- Physical pin 21 on 28 PDIP
755:                   UARTConfigure(UART2, UART_ENABLE_PINS_TX_RX_ONLY);
756:                   UARTSetLineControl(UART2, UART_DATA_SIZE_8_BITS | UART_PARITY_NONE | UART_STOP_BITS_1);
757:                   UARTSetDataRate(UART2, pb_clock, BAUDRATE);
758:                   UARTEnable(UART2, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
759:                   printf("\n\r..protothreads start..\n\r");
760:                   // === set up DMA for UART output =========
761:                   // configure the channel and enable end-on-match
762:                   DmaChnOpen(DMA_CHANNEL1, DMA_CHN_PRI2, DMA_OPEN_MATCH);
763:                   // trigger a byte everytime the UART is empty
764:                   DmaChnSetEventControl(DMA_CHANNEL1, DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_TX_IRQ));
765:                   // source and destination
766:                   DmaChnSetTxfer(DMA_CHANNEL1, PT_send_buffer+1, (void*)&U2TXREG, max_chars, 1, 1);
767:                   // signal when done
768:                   DmaChnSetEvEnableFlags(DMA_CHANNEL1, DMA_EV_BLOCK_DONE);
769:                   // set null as ending character (of a string)
770:                   DmaChnSetMatchPattern(DMA_CHANNEL1, 0x00);
771:                 #endif //#ifdef use_uart_serial
772:                   
773:                   // ===Set up timer5 ======================
774:                   // timer 5: on,  interrupts, internal clock, 
775:                   // set up to count millsec
776:                   OpenTimer5(T5_ON  | T5_SOURCE_INT | T5_PS_1_1 , pb_clock/1000);
9D003DFC  3C02BF80   LUI V0, -16512
9D003E00  AC400E00   SW ZERO, 3584(V0)
9D003E04  3C02BF80   LUI V0, -16512
9D003E08  AC400E10   SW ZERO, 3600(V0)
9D003E0C  34039C40   ORI V1, ZERO, -25536
9D003E10  3C02BF80   LUI V0, -16512
9D003E14  AC430E20   SW V1, 3616(V0)
9D003E18  34038000   ORI V1, ZERO, -32768
9D003E1C  3C02BF80   LUI V0, -16512
9D003E20  AC430E08   SW V1, 3592(V0)
777:                   // set up the timer interrupt with a priority of 2
778:                   ConfigIntTimer5(T5_INT_ON | T5_INT_PRIOR_2);
9D003E24  3C03BF88   LUI V1, -16504
9D003E28  3C020100   LUI V0, 256
9D003E2C  AC621034   SW V0, 4148(V1)
9D003E30  3C05BF88   LUI A1, -16504
9D003E34  2404001C   ADDIU A0, ZERO, 28
9D003E38  ACA410E4   SW A0, 4324(A1)
9D003E3C  3C04BF88   LUI A0, -16504
9D003E40  24060008   ADDIU A2, ZERO, 8
9D003E44  AC8610E8   SW A2, 4328(A0)
9D003E48  24060003   ADDIU A2, ZERO, 3
9D003E4C  ACA610E4   SW A2, 4324(A1)
9D003E50  AC8010E8   SW ZERO, 4328(A0)
9D003E54  3C04BF88   LUI A0, -16504
9D003E58  AC821064   SW V0, 4196(A0)
9D003E5C  3C04BF88   LUI A0, -16504
9D003E60  AC821068   SW V0, 4200(A0)
779:                   mT5ClearIntFlag(); // and clear the interrupt flag
9D003E64  AC621034   SW V0, 4148(V1)
780:                   // zero the system time tick
781:                   time_tick_millsec = 0;
9D003E68  AF808084   SW ZERO, -32636(GP)
782:                 
783:                   //=== Set up VREF as a debugger output =======
784:                   #ifdef use_vref_debug
785:                   // set up the Vref pin and use as a DAC
786:                   // enable module| eanble output | use low range output | use internal reference | desired step
787:                   CVREFOpen( CVREF_ENABLE | CVREF_OUTPUT_ENABLE | CVREF_RANGE_LOW | CVREF_SOURCE_AVDD | CVREF_STEP_0 );
788:                   // And read back setup from CVRCON for speed later
789:                   // 0x8060 is enabled with output enabled, Vdd ref, and 0-0.6(Vdd) range
790:                   CVRCON_setup = CVRCON; //CVRCON = 0x8060 from Tahmid http://tahmidmc.blogspot.com/
791:                 
792:                 #endif //#ifdef use_vref_debug
793:                 
794:                 }
9D003E6C  8FBF0014   LW RA, 20(SP)
9D003E70  03E00008   JR RA
9D003E74  27BD0018   ADDIU SP, SP, 24
---  c:/program files (x86)/microchip/xc32/v1.40/pic32mx/include/peripheral/uart.h  ---------------------
1:                   /*******************************************************************************
2:                     UART Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the interface definition for the UART peripheral library.
6:                   
7:                     Description:
8:                       This library provides a low-level abstraction of the UART (Universal
9:                       Asynchronous Receiver/Transmtter) module on Microchip PIC32MX family
10:                      microcontrollers with a convenient C language interface.  It can be used to
11:                      simplify low-level access to the module without the necessity of interacting
12:                      directly with the module's registers, thus hiding differences from one
13:                      microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       uart.h
18:                  Dependencies:   See includes
19:                  Processor:      PIC32MX
20:                  
21:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
22:                  Company:        Microchip Technology Inc.
23:                  
24:                  Copyright  2008-2009 released Microchip Technology Inc.  All rights
25:                  reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************
46:                  
47:                  Author      Date          Description
48:                  -------------------------------------------------------------------------------
49:                  RP          12-Nov-2012   Cleaned up various code examples and comments.
50:                  *******************************************************************************/
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _UART_H_
54:                  #define _UART_H_
55:                  
56:                  #include <xc.h>
57:                  #include <GenericTypeDefs.h>
58:                  #ifndef _PLIB_DISABLE_LEGACY
59:                      #include <peripheral/legacy/uart_legacy.h>  // Legacy definitions, do not use
60:                  #endif
61:                  
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  // Section: Constants & Data Types
81:                  // *****************************************************************************
82:                  // *****************************************************************************
83:                  
84:                  //DOM-IGNORE-BEGIN
85:                  /****
86:                   NOTE: It might be wise to place the generic clr/set/inv reg structure in
87:                         the device file.  Also the UART register set could also be placed there
88:                  *****/
89:                  typedef struct
90:                  {
91:                      volatile UINT   reg;
92:                      volatile UINT   clr;
93:                      volatile UINT   set;
94:                      volatile UINT   inv;
95:                  }REG_SET;
96:                  
97:                  typedef struct
98:                  {
99:                      volatile REG_SET    mode;
100:                     volatile REG_SET    sta;
101:                     volatile REG_SET    tx;
102:                     volatile REG_SET    rx;
103:                     volatile REG_SET    brg;
104:                 }UART_REGS;
105:                 
106:                 extern UART_REGS * const uartReg[];
107:                 //DOM-IGNORE-END
108:                 
109:                 // *****************************************************************************
110:                 /* UART Module
111:                 
112:                   Summary:
113:                     UART modules supported.
114:                 
115:                   Description:
116:                     This enumeration identifies the available UART modules.
117:                 */
118:                 
119:                 typedef enum
120:                 {
121:                 #if defined _UART1
122:                     // UART1 Module ID.
123:                     UART1 = 0,
124:                 #endif
125:                 #if defined _UART2
126:                     // UART2 Module ID.
127:                     UART2,
128:                 #endif
129:                 #ifdef _UART3
130:                     // UART3 Module ID.
131:                     UART3,
132:                 #endif
133:                 #ifdef _UART4
134:                     // UART4 Module ID (not available if UART1 CTS/RTS used).
135:                     UART4,
136:                 #endif
137:                 #ifdef _UART5
138:                     // UART5 Module ID (not available if UART2 CTS/RTS used).
139:                     UART5,
140:                 #endif
141:                 #ifdef _UART6
142:                     // UART6 Module ID (not available if UART3 CTS/RTS used).
143:                     UART6,
144:                 #endif
145:                     // Number of available UART modules.
146:                     UART_NUMBER_OF_MODULES
147:                 
148:                 } UART_MODULE;
149:                 
150:                 
151:                 // *****************************************************************************
152:                 /* UART Enable Modes
153:                 
154:                   Summary:
155:                     Operating modes of UART.
156:                 
157:                   Description:
158:                     This enumeration defines the supported modes in which the UART may be
159:                     enabled or disbled.
160:                 
161:                   Remarks:
162:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
163:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
164:                     has been pre-loaded with data.
165:                 
166:                     The caller should not rely on the specific numbers assigned to any of these
167:                     values as they may change from one processor to the next.
168:                 */
169:                 
170:                 typedef enum
171:                 {
172:                     // Disables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
173:                     UART_DISABLE        /*DOM-IGNORE-BEGIN*/= 0x00/*DOM-IGNORE-END*/,
174:                 
175:                     // Enables UART module functionality, must be OR'd with UART_MODULE, UART_RX, or UART_TX.
176:                     UART_ENABLE         /*DOM-IGNORE-BEGIN*/= 0x80/*DOM-IGNORE-END*/,
177:                 
178:                 
179:                     // UART Module, receiver and transmitter functionality is not.
180:                     // enabled or disabled
181:                     UART_PERIPHERAL     /*DOM-IGNORE-BEGIN*/= 0x01/*DOM-IGNORE-END*/,
182:                 
183:                     // UART Module receiver.
184:                     UART_RX             /*DOM-IGNORE-BEGIN*/= 0x02/*DOM-IGNORE-END*/,
185:                 
186:                     // UART Module transmitter.
187:                     UART_TX             /*DOM-IGNORE-BEGIN*/= 0x04/*DOM-IGNORE-END*/
188:                 
189:                 
190:                 } UART_ENABLE_MODE;
191:                 
192:                 // *****************************************************************************
193:                 /* UART Enable Helper Macro
194:                 
195:                   Summary:
196:                     Macro for enabling module operating modes.
197:                 
198:                   Description:
199:                     This macro creates the proper flags for enabling operating modes of the UART module.
200:                 
201:                   Example:
202:                     <code>
203:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX));
204:                     </code>
205:                 
206:                   Remarks:
207:                     Enabling the UART trasnmitter may cause an immediate UART TX interrupt
208:                     request (if the UART TX interrupt is enabled), unless the transmit buffer
209:                     has been pre-loaded with data.
210:                 */
211:                 #define UART_ENABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_ENABLE | (a))/*DOM-IGNORE-END*/
212:                 
213:                 // *****************************************************************************
214:                 /* UART Disable Helper Macro
215:                 
216:                   Summary:
217:                     Macro for disabling module operating modes.
218:                 
219:                   Description:
220:                     This macro creates the proper flags for disabling operating modes of the UART module.
221:                 
222:                   Example:
223:                     <code>
224:                     UARTEnable(UART1, UART_DISABLE_FLAGS(UART_TX));
225:                     </code>
226:                 
227:                 */
228:                 #define UART_DISABLE_FLAGS(a)    /*DOM-IGNORE-BEGIN*/(UART_DISABLE | (a))/*DOM-IGNORE-END*/
229:                 
230:                 // *****************************************************************************
231:                 /* UART Configuration Settings
232:                 
233:                   Summary:
234:                     Supported configuration flags for the UART module.
235:                 
236:                   Description:
237:                     This enumeration defines the various configuration options for the UART
238:                     module.  These values can be OR'd together to create a configuration mask
239:                     passed to the UARTConfigure routine.
240:                 
241:                   Remarks:
242:                     Several of the configuration options are mutually exclusive:
243:                     * Only one of the "ENABLE_PINS" modes can be used at a time
244:                     * Only one of the "RTS_WHEN" modes can be used at a time
245:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
246:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
247:                 
248:                     The caller should not rely on the specific numbers assigned to any of these
249:                     values as they may change from one processor ot the next.
250:                 */
251:                 
252:                 typedef enum
253:                 {
254:                     // Enables high-speed range of the UART (see UARTSetBitRate).
255:                     UART_ENABLE_HIGH_SPEED              /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
256:                 
257:                     // Inverts polarity of data interpretation the received (RX) pin.
258:                     UART_INVERT_RECEIVE_POLARITY        /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
259:                 
260:                     // Enables UART TX-to-RX Loop-back mode.
261:                     UART_ENABLE_LOOPBACK                /*DOM-IGNORE-BEGIN*/= 0x00000040/*DOM-IGNORE-END*/,
262:                 
263:                     // Enables Wake-up of the part when a start bit is received.
264:                     UART_ENABLE_WAKE_ON_START           /*DOM-IGNORE-BEGIN*/= 0x00000080/*DOM-IGNORE-END*/,
265:                 
266:                     // Enable Bit-clock for external IrDA transceiver support (Note:  CTS and RTS
267:                     // cannot be used in bit-clock/IrDA mode).
268:                     UART_ENABLE_PINS_BIT_CLOCK          /*DOM-IGNORE-BEGIN*/= 0x00000300/*DOM-IGNORE-END*/,
269:                 
270:                     // Enable Request-To-Send and Clear-To-Send signals (Note: The bit-clock
271:                     // cannot be used in CTS/RTS mode).
272:                     UART_ENABLE_PINS_CTS_RTS            /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
273:                 
274:                     // Enable Request-To-send signal only (Note: The bit-clock and CTS cannot
275:                     // be used in RTS-Only mode).
276:                     UART_ENABLE_PINS_RTS                /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
277:                 
278:                     // Disables use of Clear-To-Send and Request-To-Send signals (Note: This is
279:                     // the default mode and this parameter can be left out if it is desired).
280:                     UART_ENABLE_PINS_TX_RX_ONLY         /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
281:                 
282:                     // If RTS is enabled, it is asserted (driven low) when the receive buffer
283:                     // is not full (i.e., the UART is ready to receive data).  This is also known
284:                     // as "RTS Flow-Control Mode".
285:                     UART_RTS_WHEN_RX_NOT_FULL           /*DOM-IGNORE-BEGIN*/= 0x00000000/*DOM-IGNORE-END*/,
286:                 
287:                     // If RTS is enabled, it is asserted (driven low) when the transmit buffer
288:                     // is not empty (i.e., when the UART has data ready to send).  This is also
289:                     // known as "RTS Simplex Mode".
290:                     UART_RTS_WHEN_TX_NOT_EMPTY          /*DOM-IGNORE-BEGIN*/= 0x00000800/*DOM-IGNORE-END*/,
291:                 
292:                     // Enable the IrDA encoder/decoder.
293:                     UART_ENABLE_IRDA                    /*DOM-IGNORE-BEGIN*/= 0x00001000/*DOM-IGNORE-END*/,
294:                 
295:                     // Enables stopping of the UART operation to save power when the core has
296:                     // been put in idle mode.
297:                     UART_ENABLE_STOP_ON_IDLE            /*DOM-IGNORE-BEGIN*/= 0x00002000/*DOM-IGNORE-END*/,
298:                 
299:                     // Inverts the polarity of data sent on the transmit (TX) pin.
300:                     UART_INVERT_TRANSMIT_POLARITY       /*DOM-IGNORE-BEGIN*/= 0x20000000/*DOM-IGNORE-END*/,
301:                 
302:                     // Enables support for IEEE-485 protocol (equivalent the following OR'd
303:                     // together: UART_RTS_WHEN_TX_NOT_EMPTY | UART_ENABLE_PINS_RTS )
304:                     // Note:  The address must still be set using UARTEnableAddressDetect
305:                     // to support IEEE-485 protocol.
306:                     UART_SUPPORT_IEEE_485               /*DOM-IGNORE-BEGIN*/= 0x00000900/*DOM-IGNORE-END*/
307:                 
308:                 } UART_CONFIGURATION;
309:                 
310:                 
311:                 // *****************************************************************************
312:                 /* UART FIFO Modes
313:                 
314:                   Summary:
315:                     Supported FIFO modes for the UART module.
316:                 
317:                   Description:
318:                     This enumeration defines supported FIFO modes that determine when the Tx
319:                     and Rx interrupts will occur.
320:                 
321:                   Remarks:
322:                     These modes consist of two sets of mutially exclusive modes:
323:                     * Only one of the "INTERRUPT_ON_TX" modes can be used at a time
324:                     * Only one of the "INTERRUPT_ON_RX" modes can be used at a time
325:                 
326:                     The caller should not rely on the specific numbers assigned to any of these
327:                     values as they may change from one processor ot the next.
328:                 
329:                 */
330:                 
331:                 typedef enum
332:                 {
333:                     // If enabled, the TX interrupt will occur when the TX buffer is empty.
334:                     UART_INTERRUPT_ON_TX_BUFFER_EMPTY   /*DOM-IGNORE-BEGIN*/= 0x8000/*DOM-IGNORE-END*/,
335:                 
336:                     // If enabled, the TX interrupt will occur when all data has been transmitted.
337:                     UART_INTERRUPT_ON_TX_DONE           /*DOM-IGNORE-BEGIN*/= 0x4000/*DOM-IGNORE-END*/,
338:                 
339:                     // If enabled, the TX interrupt will occur whenever the TX buffer is not
340:                     // full (i.e. there is space available for more data)  This is the default.
341:                     UART_INTERRUPT_ON_TX_NOT_FULL       /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
342:                 
343:                     // If enabled, the RX interrupt will occur whenever the RX buffer is
344:                     // completely full.  (Not supported on PIC32MX5xx, PIC32MX6xx, or PIC32MX7xx.).
345:                     UART_INTERRUPT_ON_RX_FULL           /*DOM-IGNORE-BEGIN*/= 0x00C0/*DOM-IGNORE-END*/,
346:                 
347:                     // If enabled, the RX interrupt will occur whenever the RX buffer is 3/4
348:                     // (three-quarter) full.
349:                     UART_INTERRUPT_ON_RX_3_QUARTER_FULL /*DOM-IGNORE-BEGIN*/= 0x0080/*DOM-IGNORE-END*/,
350:                 
351:                     // If enabled, the RX interrupt will occur wheneer the RX buffer is half
352:                     // full.  (Not supported on PIC32X3xx or PIC32MX4xx.).
353:                     UART_INTERRUPT_ON_RX_HALF_FULL      /*DOM-IGNORE-BEGIN*/= 0x0040/*DOM-IGNORE-END*/,
354:                 
355:                     // If enabled, the RX interrupt will occur whenever the RX buffer has any
356:                     // data.
357:                     UART_INTERRUPT_ON_RX_NOT_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
358:                 
359:                 } UART_FIFO_MODE;
360:                 
361:                 
362:                 // *****************************************************************************
363:                 /* UART Line Control Mode
364:                 
365:                   Summary:
366:                     UART line control mode.
367:                 
368:                   Description:
369:                     This data type defines the supported line control modes for the UART.
370:                 
371:                   Remarks:
372:                     Some of the line-control options are mutually exclusive:
373:                     * Only one of the "DATA_SIZE" options can be used at a time
374:                     * Only one of the "PARITY" options can be used at a time
375:                     * Only one of the "STOP_BITS" options can be used at a time
376:                 
377:                     The caller should not rely on the specific numbers assigned to any of these
378:                     values as they may change from one processor ot the next.
379:                 */
380:                 
381:                 typedef enum
382:                 {
383:                     // Sets the data transfer size to 8-bits per frame.
384:                     UART_DATA_SIZE_8_BITS   /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
385:                 
386:                     // Sets the data transfer size to 9-bits per frame.
387:                     UART_DATA_SIZE_9_BITS   /*DOM-IGNORE-BEGIN*/= 0x0006/*DOM-IGNORE-END*/,
388:                 
389:                     // Enables parity bit generation for odd parity.
390:                     UART_PARITY_ODD         /*DOM-IGNORE-BEGIN*/= 0x0004/*DOM-IGNORE-END*/,
391:                 
392:                     // Enables parity bit generation for even parity.
393:                     UART_PARITY_EVEN        /*DOM-IGNORE-BEGIN*/= 0x0002/*DOM-IGNORE-END*/,
394:                 
395:                     // Disables parity bit generation.
396:                     UART_PARITY_NONE        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/,
397:                 
398:                     // Enables generation of 2 stop bits per frame.
399:                     UART_STOP_BITS_2        /*DOM-IGNORE-BEGIN*/= 0x0001/*DOM-IGNORE-END*/,
400:                 
401:                     // Enables generation of 1 stop bit per frame (default).
402:                     UART_STOP_BITS_1        /*DOM-IGNORE-BEGIN*/= 0x0000/*DOM-IGNORE-END*/
403:                 
404:                 } UART_LINE_CONTROL_MODE;
405:                 
406:                 
407:                 // *****************************************************************************
408:                 /* UART Line Status Flags
409:                 
410:                   Summary:
411:                     UART line-status bitmask flags.
412:                 
413:                   Description:
414:                     This enumeration defines the UART line-status bits.  These values are
415:                     OR'd together to make up the bitmask returned by UARTGetLineStatus.
416:                 
417:                   Remarks:
418:                     The caller should not rely on the specific numbers assigned to any of these
419:                     values as they may change from one processor ot the next.
420:                 */
421:                 
422:                 typedef enum
423:                 {
424:                     // The transmitter is able to accept data to transmit.
425:                     UART_TRANSMITTER_NOT_FULL   /*DOM-IGNORE-BEGIN*/= 0x00000200/*DOM-IGNORE-END*/,
426:                 
427:                     // The transmitter is empty (no data is available to transmit).
428:                     UART_TRANSMITTER_EMPTY      /*DOM-IGNORE-BEGIN*/= 0x00000100/*DOM-IGNORE-END*/,
429:                 
430:                     // The receiver is currently idle.
431:                     UART_RECEIVER_IDLE          /*DOM-IGNORE-BEGIN*/= 0x00000010/*DOM-IGNORE-END*/,
432:                 
433:                     // A received data parity error was detected.
434:                     UART_PARITY_ERROR           /*DOM-IGNORE-BEGIN*/= 0x00000008/*DOM-IGNORE-END*/,
435:                 
436:                     // Data was received that violated the framing protocol (the data word did
437:                     // not start or stop at the appropriate place).  Note:  A break condition
438:                     // will always indicate a framing error.
439:                     UART_FRAMING_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000004/*DOM-IGNORE-END*/,
440:                 
441:                     // The UART has received more data than it can buffer.  Data has been lost.
442:                     UART_OVERRUN_ERROR          /*DOM-IGNORE-BEGIN*/= 0x00000002/*DOM-IGNORE-END*/,
443:                 
444:                     // UART data has been received and is avaiable in the FIFO.
445:                     UART_DATA_READY             /*DOM-IGNORE-BEGIN*/= 0x00000001/*DOM-IGNORE-END*/
446:                 
447:                 } UART_LINE_STATUS;
448:                 
449:                 #define UART_LINE_STATUS_MASK   (UART_TRANSMITTER_NOT_FULL | UART_TRANSMITTER_EMPTY |\
450:                                                 UART_RECEIVER_IDLE | UART_PARITY_ERROR | UART_FRAMING_ERROR |\
451:                                                 UART_OVERRUN_ERROR | UART_DATA_READY)
452:                 
453:                 
454:                 
455:                 // *****************************************************************************
456:                 /* UART Data
457:                 
458:                   Summary:
459:                     UART data.
460:                 
461:                   Description:
462:                     This data type defines the supported data sizes for the UART.
463:                 */
464:                 
465:                 typedef union
466:                 {
467:                     // 8-bit data
468:                     struct
469:                     {
470:                         UINT16  data8bit    : 8;
471:                     };
472:                 
473:                     // 9-bit data
474:                     struct
475:                     {
476:                         UINT16  data9bit    : 9;
477:                     };
478:                 
479:                     UINT16 __data;
480:                 } UART_DATA;
481:                 
482:                 
483:                 // *****************************************************************************
484:                 // *****************************************************************************
485:                 // Section: UART Peripheral Library Interface Routines
486:                 // *****************************************************************************
487:                 // *****************************************************************************
488:                 
489:                 
490:                 /*******************************************************************************
491:                   Function:
492:                     void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode )
493:                 
494:                   Summary:
495:                     Enables or disables the given UART module in the desired mode.
496:                 
497:                   Description:
498:                     This routine enables or disables the given UART module in the desired mode.
499:                 
500:                   Precondition:
501:                     The UART module should be appropriately configured before being enabled.
502:                 
503:                   Parameters:
504:                     id    - Identifies the desired UART module.
505:                 
506:                     mode  - Identifies the desired mode of UART operation.
507:                 
508:                   Returns:
509:                     None
510:                 
511:                   Example:
512:                     <code>
513:                     UARTEnable(UART1, UART_ENABLE_FLAGS(UART_PERIPHERAL | UART_RX | UART_TX));
514:                     </code>
515:                 
516:                   Remarks:
517:                     Enabling UART transmissions will immediately cause a TX interrupt to
518:                     indicate that the transmitter needs data, unless the transmitter FIFO/buffer
519:                     was pre-loaded with data.
520:                   *****************************************************************************/
521:                 
522:                 void UARTEnable( UART_MODULE id, UART_ENABLE_MODE mode );
523:                 
524:                 
525:                 /*******************************************************************************
526:                   Function:
527:                     void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags )
528:                 
529:                   Summary:
530:                     UART module configuration routine.
531:                 
532:                   Description:
533:                     This routine allows the caller to configure various features of the UART
534:                     module for desired operation.
535:                 
536:                   Precondition:
537:                     None
538:                 
539:                   Parameters:
540:                     id      - Identifies the desired UART module.
541:                 
542:                     flags   - Bit-wise OR of the desired module configuration settings.
543:                 
544:                   Returns:
545:                     None
546:                 
547:                   Example:
548:                     <code>
549:                     UARTConfigure(UART1, UART_RTS_WHEN_RX_NOT_FULL|UART_ENABLE_PINS_CTS_RTS);
550:                     </code>
551:                 
552:                   Remarks:
553:                     Refer to the UART_CONFIGURATION enumerated data type for details on each
554:                     configuration flag.  Note that the bitmask resulting from the bit-wise OR
555:                     of these values will result in a value that is not explicitly defined in
556:                     the enumeration.
557:                   *****************************************************************************/
558:                 
559:                 void UARTConfigure ( UART_MODULE id, UART_CONFIGURATION flags );
560:                 
561:                 
562:                 /*******************************************************************************
563:                   Function:
564:                     void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode )
565:                 
566:                   Summary:
567:                     Controls UART module TX and RX FIFO operation.
568:                 
569:                   Description:
570:                     This routine allows the caller to configure when interrupts occur relative
571:                     to different "watermark" levels in the UART TX and RX FIFOs (i.e., how full
572:                     or empty the FIFOs are).
573:                 
574:                   Precondition:
575:                     None
576:                 
577:                   Parameters:
578:                     id      - Identifies the desired UART module.
579:                 
580:                     mode    - Bit-wise OR of the desired FIFO mode values.
581:                 
582:                   Returns:
583:                     None
584:                 
585:                   Example:
586:                     <code>
587:                     UARTSetFifoMode(UART1, UART_INTERRUPT_ON_TX_DONE|UART_INTERRUPT_ON_RX_NOT_EMPTY);
588:                     </code>
589:                 
590:                   Remarks:
591:                     Refer to the UART_FIFO_MODE enumerated data type for details on each
592:                     mode flag.  Note that the bitmask resulting from the bit-wise OR
593:                     of these values will result in a value that is not explicitly defined in
594:                     the enumeration.
595:                   *****************************************************************************/
596:                 
597:                 void UARTSetFifoMode ( UART_MODULE id, UART_FIFO_MODE mode );
598:                 
599:                 
600:                 /*******************************************************************************
601:                   Function:
602:                     UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate )
603:                 
604:                   Summary:
605:                     Routine to set the UART module's desired data data rate.
606:                 
607:                   Description:
608:                     This routine allows the caller to set the desired data rate for the UART.
609:                 
610:                   Precondition:
611:                     The source clock's frequency must be operating at the frequency passed in the
612:                     "sourceClock" parameter.
613:                 
614:                   Parameters:
615:                     id          - Identifies the desired UART module.
616:                 
617:                     sourceClock - Frequency (Hz) of the source clock being provided to the
618:                                   UART module.
619:                 
620:                     dataRate     - Desired data rate (bits per second).
621:                 
622:                   Returns:
623:                     Actual bit rate selected
624:                 
625:                   Example:
626:                     <code>
627:                     #define PERIPHERAL_CLOCK    10000000
628:                     #define DESIRED_DATA_RATE   19200
629:                 
630:                     UINT32    actualDataRate;
631:                 
632:                     actualDataRate = UARTSetDataRate(UART1, PERIPHERAL_CLOCK, DESIRED_DATA_RATE);
633:                     </code>
634:                 
635:                   Remarks:
636:                     Actual data rate selected may be slightly different than the data rate
637:                     requested due to truncation error.
638:                 
639:                     Note:  In normal mode, the maximum possible data rate is sourceClock/16.  If
640:                     the UART_ENABLE_HIGH_SPEED flag is sent to the UARTConfigure routine, then
641:                     the maximum data rate is sourceClock/4.
642:                   *****************************************************************************/
643:                 
644:                 UINT32 UARTSetDataRate ( UART_MODULE id, UINT32 sourceClock, UINT32 dataRate );
645:                 
646:                 
647:                 /*******************************************************************************
648:                   Function:
649:                     UINT32 UARTGetDataRate ( UART_MODULE id, UINT32 sourceClock )
650:                 
651:                   Summary:
652:                     Routine to get the UART module's current data data rate.
653:                 
654:                   Description:
655:                     This routine allows the caller to get the current data rate for the UART module.
656:                 
657:                   Precondition:
658:                     The source clock's frequency must be operating at the frequency passed in the
659:                     "sourceClock" parameter.
660:                 
661:                   Parameters:
662:                     id          - Identifies the desired UART module.
663:                 
664:                     sourceClock - Frequency (Hz) of the source clock being provided to the
665:                                   UART module.
666:                 
667:                   Returns:
668:                     The UART's current data rate (bits per second).
669:                 
670:                   Example:
671:                     <code>
672:                     #define PERIPHERAL_CLOCK    10000000
673:                 
674:                     UINT32    currentDataRate;
675:                 
676:                     currentDataRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
677:                     </code>
678:                 
679:                   Remarks:
680:                     The current (actual) data rate returned may be slightly different than bit
681:                     rate requested due to truncation error.
682:                   *****************************************************************************/
683:                 
684:                 UINT32 UARTGetDataRate( UART_MODULE id, UINT32 sourceClock );
685:                 
686:                 
687:                 /*******************************************************************************
688:                   Function:
689:                         void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode )
690:                 
691:                   Summary:
692:                     Routine to set the UART module's desired line control parameters.
693:                 
694:                   Description:
695:                     This routine allows the caller to select the desired size of the UART data
696:                     frame, the generation of parity and framing parameters (collectively
697:                     referred to as the "line control" mode).
698:                 
699:                   Precondition:
700:                 
701:                   Parameters:
702:                     id      - Identifies the desired UART module.
703:                 
704:                     mode    - This is a bit-wise OR of the desired line control mode flags.
705:                 
706:                   Returns:
707:                     None
708:                 
709:                   Example:
710:                     <code>
711:                     UARTSetLineControl(UART1, UART_DATA_SIZE_8_BITS|UART_PARITY_NONE|UART_STOP_BITS_1);
712:                     </code>
713:                 
714:                   Remarks:
715:                     Refer to the UART_LINE_CONTROL_MODE enumerated data type for details on
716:                     each mode flag.  Note that the bitmask resulting from the bit-wise OR
717:                     of these values will result in a value that is not explicitly defined in
718:                     the enumeration.
719:                   *****************************************************************************/
720:                 
721:                 void UARTSetLineControl ( UART_MODULE id, UART_LINE_CONTROL_MODE mode );
722:                 
723:                 
724:                 /*******************************************************************************
725:                   Function:
726:                     UART_LINE_STATUS UARTGetLineStatus ( UART_MODULE id )
727:                 
728:                   Summary:
729:                     Provides current UART line status.
730:                 
731:                   Description:
732:                     This routine allows the caller to get the current line status of the UART,
733:                     indicating the current state of the transmitter and receiver buffers, and
734:                     if any errors have occurred.
735:                 
736:                   Precondition:
737:                     None
738:                 
739:                   Parameters:
740:                     id      - Identifies the desired UART module.
741:                 
742:                   Returns:
743:                     A bit-wise OR of the current line status flags.
744:                 
745:                   Example:
746:                     <code>
747:                     UART_LINE_STATUS lineStatus;
748:                 
749:                     lineStatus = UARTGetLineStatus(UART1);
750:                     if ( (UART_PARITY_ERROR|UART_FRAMING_ERROR|UART_OVERRUN_ERROR) & lineStatus )
751:                     {
752:                         // Handle receiver error
753:                     }
754:                     </code>
755:                 
756:                   Remarks:
757:                     Refer to the UART_LINE_STATUS enumerated data type for details on each
758:                     status flag.
759:                 
760:                     The receiver line status flags are only valid when data has been received
761:                     and for the data at the top of the RX FIFO.
762:                 
763:                     Note that the bitmask resulting from the bit-wise OR of these values will
764:                     result in a value that is not explicitly defined in the enumeration.
765:                   *****************************************************************************/
766:                 extern inline UART_LINE_STATUS __attribute__((always_inline)) UARTGetLineStatus ( UART_MODULE id )
767:                 {
768:                     return (UART_LINE_STATUS)(uartReg[id]->sta.reg & (UART_LINE_STATUS_MASK));
769:                 }
770:                 
771:                 
772:                 /*******************************************************************************
773:                   Function:
774:                     BOOL UARTTransmitterIsReady ( UART_MODULE id )
775:                 
776:                   Summary:
777:                     Routine to detect if the transmitter is ready to accept data to transmit.
778:                 
779:                   Description:
780:                     This routine determines if the transmitter is ready to accept more data to
781:                     be transmitted.
782:                 
783:                   Precondition:
784:                     The UART module should have been appropriately configured and enabled.
785:                 
786:                   Parameters:
787:                     id      - Identifies the desired UART module.
788:                 
789:                   Returns:
790:                     Boolean identifying whether or not the transmitter is ready:
791:                     * TRUE    - If the transmitter is ready to accept more data
792:                     * FALSE   - If the transmitter is not ready to accept more data
793:                 
794:                   Example:
795:                     <code>
796:                     unsigned char data;
797:                 
798:                     data = 'a';
799:                 
800:                     if (UARTTransmitterIsReady(UART1))
801:                     {
802:                         UARTSendDataByte(UART1, data);
803:                     }
804:                     </code>
805:                 
806:                   Remarks:
807:                   *****************************************************************************/
808:                 
809:                 extern inline BOOL __attribute__ ((always_inline)) UARTTransmitterIsReady ( UART_MODULE id )
810:                 {
811:                     return (BOOL)(!(uartReg[id]->sta.reg & _U1STA_UTXBF_MASK));
9D003A18  3C029D00   LUI V0, -25344
9D003A7C  3C029D00   LUI V0, -25344
9D003ABC  3C029D00   LUI V0, -25344
9D003AFC  3C029D00   LUI V0, -25344
9D003BB4  3C029D00   LUI V0, -25344
9D003C6C  3C029D00   LUI V0, -25344
812:                 }
813:                 
814:                 
815:                 /*******************************************************************************
816:                   Function:
817:                     void UARTSendDataByte ( UART_MODULE id, BYTE data )
818:                 
819:                   Summary:
820:                     Routine to send a byte of data.
821:                 
822:                   Description:
823:                     This routine allows the caller to send a byte of data.
824:                 
825:                   Precondition:
826:                     The UART should have been appropriately configured.  The configuration must
827:                     have been for 8-bit data (see UART_DATA_SIZE_8_BITS).  The transmitter must
828:                     have been ready, although not necessarily enabled yet.
829:                 
830:                   Parameters:
831:                     id      - Identifies the desired UART module.
832:                 
833:                     data    - Data byte to be sent.
834:                 
835:                   Returns:
836:                     None
837:                 
838:                   Example:
839:                     <code>
840:                     unsigned char data;
841:                 
842:                     data = 'a';
843:                 
844:                     if (UARTTransmitterIsReady(UART1))
845:                     {
846:                         UARTSendDataByte(UART1, data);
847:                     }
848:                     </code>
849:                 
850:                   Remarks:
851:                     This routine is optimized to send 8-bit (1-byte) data through the UART.
852:                     This is an optimization of the "UARTSendData" routine for 8-bit (or less)
853:                     data.
854:                   *****************************************************************************/
855:                 
856:                 extern inline void __attribute__((always_inline)) UARTSendDataByte ( UART_MODULE id, BYTE data )
857:                 {
858:                     uartReg[id]->tx.reg = data;
9D003A34  304500FF   ANDI A1, V0, 255
9D003A94  AC430020   SW V1, 32(V0)
9D003AD4  24020020   ADDIU V0, ZERO, 32
9D003B14  2402007F   ADDIU V0, ZERO, 127
9D003BDC  90A50000   LBU A1, 0(A1)
9D003C88  90420080   LBU V0, 128(V0)
859:                 }
860:                 
861:                 
862:                 /*******************************************************************************
863:                   Function:
864:                     void UARTSendData ( UART_MODULE id, UART_DATA data )
865:                 
866:                   Summary:
867:                     Routine to send data through the UART.
868:                 
869:                   Description:
870:                     This routine allows the caller to send data of any permitted size through
871:                     the UART.
872:                 
873:                   Precondition:
874:                     The UART module should have been appropriately configured.  The configuration must
875:                     have been for desired data size.  The transmitter must have been ready,
876:                     although not necessarily enabled yet.
877:                 
878:                   Parameters:
879:                     id      - Identifies the desired UART module.
880:                 
881:                     data    - Data to be sent.
882:                 
883:                   Returns:
884:                     None
885:                 
886:                   Example:
887:                     <code>
888:                     UART_DATA data = 0x1ff; //can be 8-bit or 9-bit word, depending on how UART is configured
889:                 
890:                     if (UARTTransmitterIsReady(UART1))
891:                     {
892:                         UARTSendData(UART1, data);
893:                     }
894:                     </code>
895:                 
896:                   Remarks:
897:                     Size of the data word size depends on the current configuration (see
898:                     UARTSetLineControl and UART_LINE_CONTROL_MODE).
899:                   *****************************************************************************/
900:                 
901:                 extern inline void __attribute__((always_inline)) UARTSendData( UART_MODULE id, UART_DATA data )
902:                 {
903:                     uartReg[id]->tx.reg = data.__data;
904:                 }
905:                 
906:                 /*******************************************************************************
907:                   Function:
908:                     BOOL UARTTransmissionHasCompleted ( UART_MODULE id )
909:                 
910:                   Summary:
911:                     Routine to detect if the UART module has finshed transmitting the most recent
912:                     data.
913:                 
914:                   Description:
915:                     This routine determines if the transmitter has finished sending all
916:                     available data.
917:                 
918:                   Preconditions:
919:                     The UART module should have been appropriately configured and enabled and data
920:                     sent to the UART TX buffer.
921:                 
922:                   Parameters:
923:                     id      - Identifies the desired UART module.
924:                 
925:                   Returns:
926:                     Boolean identifying if the transmission has completed:
927:                     * TRUE    - If the transmitter has completed sending the data
928:                     * FALSE   - If the transmitter is still busy sending the data
929:                 
930:                   Example:
931:                     <code>
932:                     if (UARTTransmissionHasCompleted(UART1))
933:                     {
934:                         // Perform any tasks necessary when all data has been sent
935:                     }
936:                     </code>
937:                 
938:                   Remarks:
939:                   *****************************************************************************/
940:                 
941:                 extern inline BOOL __attribute__((always_inline)) UARTTransmissionHasCompleted ( UART_MODULE id )
942:                 {
943:                     return (BOOL)(_U1STA_TRMT_MASK == (uartReg[id]->sta.reg & _U1STA_TRMT_MASK));
944:                 }
945:                 
946:                 
947:                 /*******************************************************************************
948:                   Function:
949:                     BOOL UARTReceivedDataIsAvailable ( UART_MODULE id )
950:                 
951:                   Summary:
952:                     Routine to detect if the receiver has data available.
953:                 
954:                   Description:
955:                     This routine determines if the receiver has data available to be read.
956:                 
957:                   Precondition:
958:                     The UART module must have been configured appropriately and enabled. A complete
959:                     data frame must have been sent to the UART before it will return a TRUE.
960:                 
961:                   Parameters:
962:                     id      - Identifies the desired UART module.
963:                 
964:                   Returns:
965:                     Boolean identifying whether or not data is available:
966:                     * TRUE    - If the receiver has data available
967:                     * FALSE   - If the receiver does not have data availble
968:                 
969:                   Example:
970:                     <code>
971:                     UART_DATA data;
972:                 
973:                     if (UARTReceivedDataIsAvailable(UART1))
974:                     {
975:                         data = UARTGetData(UART1);
976:                     }
977:                     </code>
978:                 
979:                   Remarks:
980:                     This routine provides the same information as the UART_DATA_READY line
981:                     status flag.
982:                   *****************************************************************************/
983:                 
984:                 extern inline BOOL __attribute__((always_inline)) UARTReceivedDataIsAvailable ( UART_MODULE id )
985:                 {
986:                     return (BOOL)(_U1STA_URXDA_MASK == (uartReg[id]->sta.reg & _U1STA_URXDA_MASK));
9D0039D8  3C029D00   LUI V0, -25344
987:                 }
988:                 
989:                 
990:                 /*******************************************************************************
991:                   Function:
992:                     BYTE UARTGetDataByte ( UART_MODULE id )
993:                 
994:                   Summary:
995:                     Routine to get a byte of data received by the UART.
996:                 
997:                   Description:
998:                     This routine allows the caller to read a byte of data received by the UART.
999:                 
1000:                  Precondition:
1001:                    The UART module must have been appropriately configured, the configuration must
1002:                    have been for 8-bit data (see UART_DATA_SIZE_8_BITS), and the UART must have
1003:                    been enabled.  Also, a complete data frame must have been received by the UART.
1004:                
1005:                  Parameters:
1006:                    id      - Identifies the desired UART module.
1007:                
1008:                  Returns:
1009:                    A byte of data received by the UART.
1010:                
1011:                  Example:
1012:                    <code>
1013:                    unsigned char data;
1014:                
1015:                    if (UARTReceivedDataIsAvailable(UART1))
1016:                    {
1017:                        data = UARTGetDataByte(UART1);
1018:                    }
1019:                    </code>
1020:                
1021:                  Remarks:
1022:                    This routine is optimized for receiving 8-bit data through the UART.
1023:                  *****************************************************************************/
1024:                
1025:                extern inline BYTE __attribute__((always_inline)) UARTGetDataByte ( UART_MODULE id )
1026:                {
1027:                    return (BYTE)uartReg[id]->rx.reg;
9D0039F0  8C620030   LW V0, 48(V1)
1028:                }
1029:                
1030:                
1031:                /*******************************************************************************
1032:                  Function:
1033:                    UART_DATA UARTGetData ( UART_MODULE id )
1034:                
1035:                  Summary:
1036:                    Routine to get data received by the UART.
1037:                
1038:                  Description:
1039:                    This routine allows the caller to read a data word received by the UART.
1040:                
1041:                  Precondition:
1042:                    The module must have been appropriately configured, the UART module must have been
1043:                    enabled, and a complete data frame must have been received by the UART.
1044:                
1045:                  Parameters:
1046:                    id      - Identifies the desired UART module.
1047:                
1048:                  Returns:
1049:                    Data received by the UART.
1050:                
1051:                  Example:
1052:                    <code>
1053:                    UART_DATA data;
1054:                
1055:                    if (UARTReceivedDataIsAvailable(UART1))
1056:                    {
1057:                        data = UARTGetData(UART1);
1058:                    }
1059:                    </code>
1060:                
1061:                  Remarks:
1062:                    Size of the data word depends on the current configuration (see
1063:                    UARTSetLineControl).
1064:                  *****************************************************************************/
1065:                
1066:                extern inline UART_DATA __attribute__((always_inline)) UARTGetData ( UART_MODULE id )
1067:                {
1068:                    UART_DATA data;
1069:                
1070:                    data.__data = uartReg[id]->rx.reg;
1071:                
1072:                    return data;
1073:                }
1074:                
1075:                
1076:                /*******************************************************************************
1077:                  Function:
1078:                    void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch )
1079:                
1080:                  Summary:
1081:                    Routine to program the address for which the UART module may watch.
1082:                
1083:                  Description:
1084:                    This routine programs the 8-bit address for which the module may watch.
1085:                
1086:                  Precondition:
1087:                    None
1088:                
1089:                  Parameters:
1090:                    id      - Identifies the desired UART module.
1091:                
1092:                    address - 8-bit address for which the module will watch.
1093:                
1094:                    watch   - Determines if the "address watch" mode will be enabled or disabled:
1095:                              * TRUE - Enable address watch mode
1096:                              * FALSE - Disable address watch mode
1097:                
1098:                  Returns:
1099:                    None.
1100:                
1101:                  Example:
1102:                    <code>
1103:                    #define SLAVE_ADDRESS  0x42
1104:                
1105:                    UARTSetAddress(UART1, SLAVE_ADDRESS, TRUE);
1106:                    </code>
1107:                
1108:                  Remarks:
1109:                    The module can be placed into a mode where it will ignore all data received
1110:                    until it identifies the programmed adress.  After the programmed address
1111:                    has been identified, it will begin receiving data normally.  This mode is
1112:                    particularly useful for supporting the IEEE-485 protocol.
1113:                  *****************************************************************************/
1114:                
1115:                void UARTSetAddress ( UART_MODULE id, BYTE address, BOOL watch );
1116:                
1117:                
1118:                /*******************************************************************************
1119:                  Function:
1120:                    void UARTWatchForAddress ( UART_MODULE id, BOOL watch )
1121:                
1122:                  Summary:
1123:                    Routine to enable or disable recognition of the programmed address byte.
1124:                
1125:                  Description:
1126:                    This routine can enable or disable the "address watch" mode.  In this mode,
1127:                    the UART module will ignore all data until it recognizes the programmed address.
1128:                
1129:                  Precondition:
1130:                    UART should have already been enabled and set with watch address.
1131:                
1132:                  Parameters:
1133:                    id      - Identifies the desired UART module.
1134:                
1135:                    watch   - Determines if the "address watch" mode will be enabled or
1136:                              disabled.
1137:                              * TRUE - Enable address watch mode
1138:                              * FALSE - Disable address watch mode
1139:                
1140:                  Returns:
1141:                    None.
1142:                
1143:                  Example:
1144:                    <code>
1145:                    #define SLAVE_ADDRESS 0x42
1146:                
1147:                    // Set the address, but don't enable the watch until later,
1148:                    // UART continues to receive data normally
1149:                    UARTSetAddress(UART1, SLAVE_ADDRESS, FALSE);
1150:                
1151:                    // ...
1152:                
1153:                    // Now begin to ignore all UART traffic until we are addressed
1154:                    UARTWatchForAddress(UART1, TRUE);
1155:                    </code>
1156:                
1157:                  Remarks:
1158:                    The UART module can be placed into a mode where it will ignore all data received
1159:                    until it identifies the programmed address.  After the programmed address
1160:                    has been identified, it will begin receiving data normally.  This mode is
1161:                    particularly useful for supporting the IEEE-485 protocol.
1162:                  *****************************************************************************/
1163:                
1164:                void UARTWatchForAddress ( UART_MODULE id, BOOL watch );
1165:                
1166:                
1167:                /*******************************************************************************
1168:                  Function:
1169:                    void UARTSendBreak ( UART_MODULE id )
1170:                
1171:                  Summary:
1172:                    Routine to send a break signal from the UART.
1173:                
1174:                  Description:
1175:                    This routine allows the caller to send a break signal (12-bits of '0' data).
1176:                
1177:                  Precondition:
1178:                    The UART should have been appropriately configured.  The transmitter should
1179:                    be idle, although not necessarily enabled yet.
1180:                
1181:                  Parameters:
1182:                    id      - Identifies the desired UART module.
1183:                
1184:                  Returns:
1185:                    None
1186:                
1187:                  Example:
1188:                    <code>
1189:                    if (UARTTransmissionHasCompleted(UART1))
1190:                    {
1191:                        UARTSendBreak(UART1);
1192:                    }
1193:                    </code>
1194:                
1195:                  Remarks:
1196:                    After calling UARTSendBreak (and ensuring that the transmitter is enabled),
1197:                    data may be pre-loaded into the FIFO and it will be send immediately
1198:                    following the break signal.
1199:                  *****************************************************************************/
1200:                
1201:                extern inline void __attribute__((always_inline)) UARTSendBreak ( UART_MODULE id )
1202:                {
1203:                    uartReg[id]->sta.set = _U1STA_UTXBRK_MASK;
1204:                }
1205:                
1206:                
1207:                /*******************************************************************************
1208:                  Function:
1209:                    void UARTStartAutoDataRateDetect ( UART_MODULE id )
1210:                
1211:                  Summary:
1212:                    Routine to automatically determine the data rate (bits-per-second) of an
1213:                    external transmitter to the UART.
1214:                
1215:                  Description:
1216:                    This routine initiates the process of automatically determining the data
1217:                    rate (bits-per-second) of an external transmitter to the UART.
1218:                
1219:                  Precondition:
1220:                    The UART should have been appropriately configured.  The transmitter should
1221:                    be idle, although not necessarily enabled yet.
1222:                
1223:                  Parameters:
1224:                    id      - Identifies the desired UART module.
1225:                
1226:                  Returns:
1227:                    None
1228:                
1229:                  Example:
1230:                    <code>
1231:                    // See "PIC32 Family Reference Manual, Sect. 21 UART" for information on
1232:                    // methods to detect a Break.
1233:                
1234:                    if (breakDetected && useAutoRateDetect)
1235:                    {
1236:                        UARTStartAutoDataRateDetect (UART1);
1237:                    }
1238:                    </code>
1239:                
1240:                  Remarks:
1241:                    The UART module begins measuring the data rate beginning at the next start
1242:                    bit.  The external transmitter should send an alternating pattern (0x55)
1243:                    for the byte to be measured for an effective rate detection.  To ensure
1244:                    an effective measurement sequence, this can be done immediately following
1245:                    a break reception. It is important that this UART module is not
1246:                    transmitting data while it is trying to detect RX baud rate, see the
1247:                    "PIC32 Family Reference Manual, Sect. 21 UART".
1248:                  *****************************************************************************/
1249:                
1250:                extern inline void __attribute__((always_inline)) UARTStartAutoDataRateDetect ( UART_MODULE id )
1251:                {
1252:                   uartReg[id]->mode.set = _U1MODE_ABAUD_MASK;
1253:                }
1254:                
1255:                
1256:                
1257:                /*******************************************************************************
1258:                  Function:
1259:                    BOOL UARTDataRateDetected ( UART_MODULE id )
1260:                
1261:                  Summary:
1262:                    Routine to identify when automatic data rate detection has completed.
1263:                
1264:                  Description:
1265:                    This routine checks to see if automatic data rate detection has completed.
1266:                
1267:                  Precondition:
1268:                    Automatic rate detection should have been previously started.
1269:                
1270:                  Parameters:
1271:                    id      - Identifies the desired UART module.
1272:                
1273:                  Returns:
1274:                    * TRUE    - Indicates that automatic rate detection has completed.
1275:                    * FALSE   - Indicates that automatic rate detection is still ongoing.
1276:                
1277:                  Example:
1278:                    <code>
1279:                    #define PERIPHERAL_CLOCK    10000000
1280:                
1281:                    UINT32 currentRate;
1282:                
1283:                    if (UARTDataRateDetected(UART1))
1284:                    {
1285:                        currentRate = UARTGetDataRate(UART1, PERIPHERAL_CLOCK);
1286:                    }
1287:                    </code>
1288:                
1289:                  Remarks:
1290:                    This routine returns FALSE after automatic rate detection
1291:                    has been started but before rate is detectdd, it will return TRUE
1292:                    at any other time.
1293:                  *****************************************************************************/
1294:                
1295:                extern inline BOOL __attribute__((always_inline)) UARTDataRateDetected ( UART_MODULE id )
1296:                {
1297:                    return (BOOL)(!(uartReg[id]->mode.reg & _U1MODE_ABAUD_MASK));
1298:                }
1299:                
1300:                #ifdef __cplusplus
1301:                  }
1302:                #endif
1303:                
1304:                #endif // _UART_h_
1305:                
---  c:/program files (x86)/microchip/xc32/v1.40/pic32mx/include/peripheral/system.h  -------------------
1:                   /********************************************************************
2:                   
3:                       System Library Interface Definition
4:                   
5:                       Summary:
6:                           This file contains the interface definition for the System
7:                           peripheral library.
8:                   
9:                       Description:
10:                          This library provides functions for configuring the peripheral
11:                          clock, cache settings, and wait states.  For details on the
12:                          register and bit settings used by these functions, refer to the
13:                          PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:        System.h
20:                   * Dependencies:
21:                   * Processor:       PIC32
22:                   * Hardware:        N/A
23:                   * Assembler:       N/A
24:                   * Linker:          N/A
25:                   * Company:         Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the ?Company?) for its PICmicro Microcontroller is intended and
30:                   * supplied to you, the Company?s customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  
67:                  /*
68:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
69:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
70:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
71:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
72:                  */
73:                  #ifndef _SUPPRESS_PLIB_WARNING
74:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
75:                  #endif
76:                  
77:                  
78:                  
79:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
80:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
81:                  
82:                  /*********************************************************************
83:                   * SYSTEMConfig Flags
84:                   *********************************************************************/
85:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
86:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
87:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
88:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
89:                  
90:                  /*********************************************************************
91:                   Function:
92:                      unsigned int SYSTEMConfigPB(unsigned int sys_clock)
93:                  
94:                   Description:
95:                      The function sets the PB divider to the optimum value.
96:                  
97:                   PreCondition:
98:                      None
99:                  
100:                  Parameters:
101:                     sys_clock - system clock in Hz
102:                 
103:                  Returns:
104:                     the PB clock frequency in Hz
105:                 
106:                  Side Effects:
107:                     The PB clock may be changed
108:                 
109:                  Overview:
110:                     The function sets the PB divider to the optimum value.
111:                 
112:                  Remarks:
113:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
114:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
115:                 
116:                  Example:
117:                     <code>
118:                     SYSTEMConfigPB(72000000);
119:                     </code>
120:                  ********************************************************************/
121:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
122:                 {
123:                     unsigned int pb_div;
124:                     unsigned int pb_clock;
125:                 
126:                     pb_clock = sys_clock;
127:                 
128:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
129:                     {
130:                         pb_div=OSC_PB_DIV_2;
131:                         pb_clock >>= 1;
132:                     }
133:                     else
134:                     {
135:                         pb_div=OSC_PB_DIV_1;
136:                     }
137:                 
138:                     OSCSetPBDIV(pb_div);
139:                 
140:                     return pb_clock;
141:                 }
142:                 
143:                 
144:                 /*********************************************************************
145:                   Function:
146:                     void SYSTEMConfigWaitStates(unsigned int sys_clock)
147:                 
148:                   Description:
149:                     The function sets the Flash Wait states to the optimum value.
150:                 
151:                   PreCondition:
152:                     None
153:                 
154:                   Parameters:
155:                     sys_clock - system clock in Hz
156:                 
157:                   Returns:
158:                     None
159:                 
160:                   Side Effects:
161:                     The Wait States may be changed
162:                 
163:                   Remarks:
164:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
165:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
166:                 
167:                   Example:
168:                     <code>
169:                     SYSTEMConfigWaitStates(72000000);
170:                     </code>
171:                  ********************************************************************/
172:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
173:                 {
174:                 #ifdef _PCACHE
175:                     unsigned int wait_states;
176:                     unsigned int int_status;
177:                 #endif
178:                 
179:                 #ifdef _PCACHE
180:                     wait_states = 0;
181:                 
182:                     while(sys_clock > FLASH_SPEED_HZ)
183:                     {
184:                         wait_states++;
185:                         sys_clock -= FLASH_SPEED_HZ;
186:                     }
187:                 
188:                     int_status=INTDisableInterrupts();
189:                     mCheConfigure(wait_states);
190:                     INTRestoreInterrupts(int_status);
191:                 
192:                 #endif
193:                 }
194:                 
195:                 /*********************************************************************
196:                   Function:
197:                         unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
198:                 
199:                   Description:
200:                     The function sets the PB divider and the Flash Wait states to the optimum value.
201:                 
202:                   PreCondition:
203:                     None
204:                 
205:                   Parameters:
206:                     sys_clock - system clock in Hz
207:                 
208:                   Returns:
209:                     the PB clock frequency in Hz
210:                 
211:                   Side Effects:
212:                     The PB clock and wait states may be changed
213:                 
214:                   Remarks:
215:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
216:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
217:                 
218:                   Example:
219:                     <code>
220:                     SYSTEMConfigWaitStatesAndPB(72000000);
221:                     </code>
222:                  ********************************************************************/
223:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
224:                 {
225:                 #ifdef _PCACHE
226:                     unsigned int wait_states;
227:                 #endif
228:                     unsigned int pb_clock;
229:                     unsigned int int_status;
230:                 
231:                     pb_clock = SYSTEMConfigPB(sys_clock);
232:                 
233:                 
234:                     // set the flash wait states based on 1 wait state
235:                     // for every 20 MHz
236:                 #ifdef _PCACHE
237:                     wait_states = 0;
238:                 
239:                     while(sys_clock > FLASH_SPEED_HZ)
240:                     {
241:                         wait_states++;
242:                         sys_clock -= FLASH_SPEED_HZ;
243:                     }
244:                 
245:                     int_status=INTDisableInterrupts();
246:                     mCheConfigure(wait_states);
247:                     INTRestoreInterrupts(int_status);
248:                 
249:                 #endif
250:                 
251:                     return pb_clock;
252:                 }
253:                 /*********************************************************************
254:                   Function:
255:                     unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
256:                 
257:                   Description:
258:                     The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
259:                     It also enables the cacheability for the K0 segment.
260:                 
261:                   PreCondition:
262:                     None
263:                 
264:                   Parameters:
265:                     sys_clock - system clock in Hz
266:                 
267:                   Output:
268:                     the PB clock frequency in Hz
269:                 
270:                   Side Effects:
271:                     Sets the PB and Flash Wait states
272:                 
273:                   Remarks:
274:                     The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
275:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
276:                 
277:                   Example:
278:                     <code>
279:                     SYSTEMConfigPerformance(72000000);
280:                     </code>
281:                  ********************************************************************/
282:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
283:                 {
284:                     // set up the wait states
285:                     unsigned int pb_clk;
286:                 #ifdef _PCACHE
287:                     unsigned int cache_status;
288:                 #endif
289:                     unsigned int int_status;
290:                 
291:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
292:                 
293:                     int_status=INTDisableInterrupts();
294:                 
295:                     mBMXDisableDRMWaitState();
296:                 
297:                 #ifdef _PCACHE
298:                     cache_status = mCheGetCon();
299:                     cache_status |= CHE_CONF_PF_ALL;
300:                     mCheConfigure(cache_status);
301:                     CheKseg0CacheOn();
302:                 #endif
303:                 
304:                     INTRestoreInterrupts(int_status);
305:                 
306:                     return pb_clk;
307:                 
308:                 }
309:                 /*********************************************************************
310:                   Function:
311:                     unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
312:                 
313:                   Description:
314:                     The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value,
315:                     based on the flags selected and on the frequency of the system clock.
316:                     It also enables the cacheability for the K0 segment.
317:                 
318:                   PreCondition:
319:                     None
320:                 
321:                   Parameters:
322:                     sys_clock - system clock frequency in Hz
323:                     flags -
324:                         *    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
325:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
326:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
327:                         *    SYS_CFG_ALL          - configure all based on system clock
328:                 
329:                   Returns:
330:                     the PB clock frequency in Hz
331:                 
332:                   Side Effects:
333:                     Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
334:                     wait state to 0.
335:                 
336:                 
337:                   Remarks:
338:                     The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
339:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
340:                 
341:                   Example:
342:                     <code>
343:                     SYSTEMConfig(72000000, SYS_CFG_ALL);
344:                     </code>
345:                  ********************************************************************/
346:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
347:                 {
348:                     unsigned int pb_clk;
349:                     unsigned int int_status;
350:                 #ifdef _PCACHE
351:                     unsigned int cache_status;
352:                 #endif
353:                 
354:                     int_status=INTDisableInterrupts();
9D003DC8  0F401D8F   JAL INTDisableInterrupts
9D003DCC  00000000   NOP
355:                 
356:                     mBMXDisableDRMWaitState();
9D003DD0  24040040   ADDIU A0, ZERO, 64
9D003DD4  3C03BF88   LUI V1, -16504
9D003DD8  AC642004   SW A0, 8196(V1)
357:                 
358:                     if(flags & SYS_CFG_WAIT_STATES)
359:                     {
360:                         SYSTEMConfigWaitStates(sys_clock);
361:                     }
362:                 
363:                     if(flags & SYS_CFG_PB_BUS)
364:                     {
365:                         SYSTEMConfigPB(sys_clock);
366:                     }
367:                 
368:                 
369:                 #ifdef _PCACHE
370:                     if(flags & SYS_CFG_PCACHE)
371:                     {
372:                         cache_status = mCheGetCon();
373:                         cache_status |= CHE_CONF_PF_ALL;
374:                         mCheConfigure(cache_status);
375:                         CheKseg0CacheOn();
376:                     }
377:                 #endif
378:                 
379:                     pb_clk = sys_clock;
380:                     pb_clk >>= OSCCONbits.PBDIV;
9D003DDC  3C03BF81   LUI V1, -16511
9D003DE0  8C63F000   LW V1, -4096(V1)
381:                 
382:                     INTRestoreInterrupts(int_status);
9D003DE4  0F401D79   JAL INTRestoreInterrupts
9D003DE8  00402021   ADDU A0, V0, ZERO
383:                 
384:                     return pb_clk;
385:                 
386:                 }
387:                 #ifdef __cplusplus
388:                   }
389:                 #endif
390:                 #endif
391:                 
---  /Volumes/home/c11067/xc32/build/xc32-XC32_v1_40_branch/src48x/gcc/libgcc/libgcc2.c  ----------------
9D005050  00C04021   ADDU T0, A2, ZERO
9D0054B4  00C04021   ADDU T0, A2, ZERO
9D005054  00804821   ADDU T1, A0, ZERO
9D0054B8  00801021   ADDU V0, A0, ZERO
9D005058  14E0003B   BNE A3, ZERO, 0x9D005148
9D00505C  00A01821   ADDU V1, A1, ZERO
9D0054BC  14E0003F   BNE A3, ZERO, 0x9D0055BC
9D0054C0  00A04821   ADDU T1, A1, ZERO
9D005060  00A6102B   SLTU V0, A1, A2
9D005064  10400048   BEQ V0, ZERO, 0x9D005188
9D005068  70C21020   CLZ V0, A2
9D0054C4  00A6182B   SLTU V1, A1, A2
9D0054C8  10600047   BEQ V1, ZERO, 0x9D0055E8
9D0054CC  70C31820   CLZ V1, A2
9D00506C  50400008   BEQL V0, ZERO, 0x9D005090
9D005070  00083402   SRL A2, T0, 16
9D0054D0  50600008   BEQL V1, ZERO, 0x9D0054F4
9D0054D4  00081C02   SRL V1, T0, 16
9D005080  00464004   SLLV T0, A2, V0
9D0054E4  00664004   SLLV T0, A2, V1
9D005074  00021823   SUBU V1, ZERO, V0
9D005078  00452804   SLLV A1, A1, V0
9D00507C  00641806   SRLV V1, A0, V1
9D005084  00651825   OR V1, V1, A1
9D0054D8  00034823   SUBU T1, ZERO, V1
9D0054DC  00652804   SLLV A1, A1, V1
9D0054E0  01244806   SRLV T1, A0, T1
9D0054E8  01254825   OR T1, T1, A1
9D005088  00444804   SLLV T1, A0, V0
9D0054EC  00641004   SLLV V0, A0, V1
9D00508C  00083402   SRL A2, T0, 16
9D005090  0066001B   DIVU V1, A2
9D005094  00C001F4   TEQ A2, ZERO
9D005098  00002010   MFHI A0, 0
9D00509C  00005812   MFLO T3, 0
9D0050A0  310CFFFF   ANDI T4, T0, -1
9D0050A4  00095402   SRL T2, T1, 16
9D0050A8  716C5802   MUL T3, T3, T4
9D0050AC  00042400   SLL A0, A0, 16
9D0050B0  008A5025   OR T2, A0, T2
9D0050B4  014B682B   SLTU T5, T2, T3
9D0050B8  0066001B   DIVU V1, A2
9D0050BC  00C001F4   TEQ A2, ZERO
9D0050C0  51A00009   BEQL T5, ZERO, 0x9D0050E8
9D0050C4  014B5023   SUBU T2, T2, T3
9D0050C8  01485021   ADDU T2, T2, T0
9D0050CC  0148182B   SLTU V1, T2, T0
9D0050D0  54600005   BNEL V1, ZERO, 0x9D0050E8
9D0050D4  014B5023   SUBU T2, T2, T3
9D0050D8  014B202B   SLTU A0, T2, T3
9D0050DC  01481821   ADDU V1, T2, T0
9D0050E0  0064500B   MOVN T2, V1, A0
9D0050E4  014B5023   SUBU T2, T2, T3
9D0050E8  3123FFFF   ANDI V1, T1, -1
9D0050EC  0146001B   DIVU T2, A2
9D0050F0  00C001F4   TEQ A2, ZERO
9D0050F4  00004810   MFHI T1, 0
9D0050F8  00002012   MFLO A0, 0
9D0050FC  708C2002   MUL A0, A0, T4
9D005100  00094C00   SLL T1, T1, 16
9D005104  01234825   OR T1, T1, V1
9D005108  0124182B   SLTU V1, T1, A0
9D00510C  0146001B   DIVU T2, A2
9D005110  00C001F4   TEQ A2, ZERO
9D005114  50600009   BEQL V1, ZERO, 0x9D00513C
9D005118  01244823   SUBU T1, T1, A0
9D00511C  01284821   ADDU T1, T1, T0
9D005120  0128182B   SLTU V1, T1, T0
9D005124  54600005   BNEL V1, ZERO, 0x9D00513C
9D005128  01244823   SUBU T1, T1, A0
9D00512C  0124182B   SLTU V1, T1, A0
9D005130  01284021   ADDU T0, T1, T0
9D005134  0103480B   MOVN T1, T0, V1
9D005138  01244823   SUBU T1, T1, A0
9D0054F0  00081C02   SRL V1, T0, 16
9D0054F4  0123001B   DIVU T1, V1
9D0054F8  006001F4   TEQ V1, ZERO
9D0054FC  00006010   MFHI T4, 0
9D005500  00005812   MFLO T3, 0
9D005504  310AFFFF   ANDI T2, T0, -1
9D005508  00022402   SRL A0, V0, 16
9D00550C  00003012   MFLO A2, 0
9D005510  716A3802   MUL A3, T3, T2
9D005514  000C6400   SLL T4, T4, 16
9D005518  01842025   OR A0, T4, A0
9D00551C  0087602B   SLTU T4, A0, A3
9D005520  0123001B   DIVU T1, V1
9D005524  006001F4   TEQ V1, ZERO
9D005528  1180000B   BEQ T4, ZERO, 0x9D005558
9D00552C  00872823   SUBU A1, A0, A3
9D005530  00882021   ADDU A0, A0, T0
9D005534  0088282B   SLTU A1, A0, T0
9D005538  14A00006   BNE A1, ZERO, 0x9D005554
9D00553C  2566FFFF   ADDIU A2, T3, -1
9D005540  0087282B   SLTU A1, A0, A3
9D005544  10A00004   BEQ A1, ZERO, 0x9D005558
9D005548  00872823   SUBU A1, A0, A3
9D00554C  2566FFFE   ADDIU A2, T3, -2
9D005550  00882021   ADDU A0, A0, T0
9D005554  00872823   SUBU A1, A0, A3
9D005558  3042FFFF   ANDI V0, V0, -1
9D00555C  00A3001B   DIVU A1, V1
9D005560  006001F4   TEQ V1, ZERO
9D005564  00004810   MFHI T1, 0
9D005568  00003812   MFLO A3, 0
9D00556C  00002012   MFLO A0, 0
9D005570  70EA5002   MUL T2, A3, T2
9D005574  00094C00   SLL T1, T1, 16
9D005578  01221025   OR V0, T1, V0
9D00557C  004A482B   SLTU T1, V0, T2
9D005580  00A3001B   DIVU A1, V1
9D005584  006001F4   TEQ V1, ZERO
9D005588  51200009   BEQL T1, ZERO, 0x9D0055B0
9D00558C  00061400   SLL V0, A2, 16
9D005590  00481021   ADDU V0, V0, T0
9D005594  0048402B   SLTU T0, V0, T0
9D005598  15000004   BNE T0, ZERO, 0x9D0055AC
9D00559C  24E4FFFF   ADDIU A0, A3, -1
9D0055A0  004A502B   SLTU T2, V0, T2
9D0055A4  24E7FFFE   ADDIU A3, A3, -2
9D0055A8  00EA200B   MOVN A0, A3, T2
9D0055AC  00061400   SLL V0, A2, 16
9D0055B0  00821025   OR V0, A0, V0
9D0055B4  03E00008   JR RA
9D0055B8  00001821   ADDU V1, ZERO, ZERO
9D005188  14C00006   BNE A2, ZERO, 0x9D0051A4
9D00518C  71021020   CLZ V0, T0
9D0055E8  14C00006   BNE A2, ZERO, 0x9D005604
9D0055EC  71031820   CLZ V1, T0
9D005190  24020001   ADDIU V0, ZERO, 1
9D005194  0046001B   DIVU V0, A2
9D005198  00C001F4   TEQ A2, ZERO
9D00519C  00004012   MFLO T0, 0
9D0055F0  24030001   ADDIU V1, ZERO, 1
9D0055F4  0066001B   DIVU V1, A2
9D0055F8  00C001F4   TEQ A2, ZERO
9D0055FC  00004012   MFLO T0, 0
9D0051A0  71021020   CLZ V0, T0
9D005600  71031820   CLZ V1, T0
9D0051A4  5440007D   BNEL V0, ZERO, 0x9D00539C
9D0051A8  00484004   SLLV T0, T0, V0
9D005604  5460007B   BNEL V1, ZERO, 0x9D0057F4
9D005608  00684004   SLLV T0, T0, V1
9D0051AC  00A82823   SUBU A1, A1, T0
9D0051B0  00081C02   SRL V1, T0, 16
9D0051B4  3107FFFF   ANDI A3, T0, -1
9D00560C  00A82023   SUBU A0, A1, T0
9D005610  00083C02   SRL A3, T0, 16
9D005614  310BFFFF   ANDI T3, T0, -1
9D005618  24030001   ADDIU V1, ZERO, 1
9D00539C  24090020   ADDIU T1, ZERO, 32
9D0053A0  01224823   SUBU T1, T1, V0
9D0057F4  24020020   ADDIU V0, ZERO, 32
9D0057F8  00431023   SUBU V0, V0, V1
9D0053A4  01255006   SRLV T2, A1, T1
9D0057FC  00454806   SRLV T1, A1, V0
9D0053C0  00452804   SLLV A1, A1, V0
9D0053C4  01244806   SRLV T1, A0, T1
9D0053C8  01252825   OR A1, T1, A1
9D005818  00652804   SLLV A1, A1, V1
9D00581C  00441006   SRLV V0, A0, V0
9D005820  00452825   OR A1, V0, A1
9D0053D0  00444804   SLLV T1, A0, V0
9D005828  00641004   SLLV V0, A0, V1
9D0053A8  00081C02   SRL V1, T0, 16
9D0053AC  0143001B   DIVU T2, V1
9D0053B0  006001F4   TEQ V1, ZERO
9D0053B4  00003010   MFHI A2, 0
9D0053B8  00005812   MFLO T3, 0
9D0053BC  3107FFFF   ANDI A3, T0, -1
9D0053CC  00056402   SRL T4, A1, 16
9D0053D4  71675802   MUL T3, T3, A3
9D0053D8  00063400   SLL A2, A2, 16
9D0053DC  01863025   OR A2, T4, A2
9D0053E0  00CB202B   SLTU A0, A2, T3
9D0053E4  0143001B   DIVU T2, V1
9D0053E8  006001F4   TEQ V1, ZERO
9D0053EC  50800006   BEQL A0, ZERO, 0x9D005408
9D0053F0  00CB3023   SUBU A2, A2, T3
9D0053F4  00C83021   ADDU A2, A2, T0
9D0053F8  00C8202B   SLTU A0, A2, T0
9D0053FC  10800024   BEQ A0, ZERO, 0x9D005490
9D005400  00CB502B   SLTU T2, A2, T3
9D005404  00CB3023   SUBU A2, A2, T3
9D005408  30AAFFFF   ANDI T2, A1, -1
9D00540C  00C3001B   DIVU A2, V1
9D005410  006001F4   TEQ V1, ZERO
9D005414  00002010   MFHI A0, 0
9D005418  00002812   MFLO A1, 0
9D00541C  70A72802   MUL A1, A1, A3
9D005420  00042400   SLL A0, A0, 16
9D005424  008A2025   OR A0, A0, T2
9D005428  0085502B   SLTU T2, A0, A1
9D00542C  00C3001B   DIVU A2, V1
9D005430  006001F4   TEQ V1, ZERO
9D005434  5140FF60   BEQL T2, ZERO, 0x9D0051B8
9D005438  00852823   SUBU A1, A0, A1
9D00543C  00882021   ADDU A0, A0, T0
9D005440  0088302B   SLTU A2, A0, T0
9D005444  54C0FF5C   BNEL A2, ZERO, 0x9D0051B8
9D005448  00852823   SUBU A1, A0, A1
9D00544C  0085502B   SLTU T2, A0, A1
9D005450  00883021   ADDU A2, A0, T0
9D005454  00CA200B   MOVN A0, A2, T2
9D005458  0B40146E   J 0x9D0051B8
9D00545C  00852823   SUBU A1, A0, A1
9D005490  00C82021   ADDU A0, A2, T0
9D005494  0B401501   J 0x9D005404
9D005498  008A300B   MOVN A2, A0, T2
9D005800  00083C02   SRL A3, T0, 16
9D005804  0127001B   DIVU T1, A3
9D005808  00E001F4   TEQ A3, ZERO
9D00580C  00003010   MFHI A2, 0
9D005810  00006012   MFLO T4, 0
9D005814  310BFFFF   ANDI T3, T0, -1
9D005824  00056C02   SRL T5, A1, 16
9D00582C  00001812   MFLO V1, 0
9D005830  718B5002   MUL T2, T4, T3
9D005834  00063400   SLL A2, A2, 16
9D005838  01A63025   OR A2, T5, A2
9D00583C  00CA202B   SLTU A0, A2, T2
9D005840  0127001B   DIVU T1, A3
9D005844  00E001F4   TEQ A3, ZERO
9D005848  5080000B   BEQL A0, ZERO, 0x9D005878
9D00584C  00CA3023   SUBU A2, A2, T2
9D005850  00C83021   ADDU A2, A2, T0
9D005854  00C8202B   SLTU A0, A2, T0
9D005858  14800006   BNE A0, ZERO, 0x9D005874
9D00585C  2583FFFF   ADDIU V1, T4, -1
9D005860  00CA202B   SLTU A0, A2, T2
9D005864  50800004   BEQL A0, ZERO, 0x9D005878
9D005868  00CA3023   SUBU A2, A2, T2
9D00586C  2583FFFE   ADDIU V1, T4, -2
9D005870  00C83021   ADDU A2, A2, T0
9D005874  00CA3023   SUBU A2, A2, T2
9D005878  30ACFFFF   ANDI T4, A1, -1
9D00587C  00C7001B   DIVU A2, A3
9D005880  00E001F4   TEQ A3, ZERO
9D005884  00002010   MFHI A0, 0
9D005888  00005012   MFLO T2, 0
9D00588C  00004812   MFLO T1, 0
9D005890  714B2802   MUL A1, T2, T3
9D005894  00042400   SLL A0, A0, 16
9D005898  008C2025   OR A0, A0, T4
9D00589C  0085602B   SLTU T4, A0, A1
9D0058A0  00C7001B   DIVU A2, A3
9D0058A4  00E001F4   TEQ A3, ZERO
9D0058A8  5180000B   BEQL T4, ZERO, 0x9D0058D8
9D0058AC  00031C00   SLL V1, V1, 16
9D0058B0  00882021   ADDU A0, A0, T0
9D0058B4  0088302B   SLTU A2, A0, T0
9D0058B8  14C00006   BNE A2, ZERO, 0x9D0058D4
9D0058BC  2549FFFF   ADDIU T1, T2, -1
9D0058C0  0085302B   SLTU A2, A0, A1
9D0058C4  50C00004   BEQL A2, ZERO, 0x9D0058D8
9D0058C8  00031C00   SLL V1, V1, 16
9D0058CC  2549FFFE   ADDIU T1, T2, -2
9D0058D0  00882021   ADDU A0, A0, T0
9D0058D4  00031C00   SLL V1, V1, 16
9D0058D8  00852023   SUBU A0, A0, A1
9D0058DC  0B401587   J 0x9D00561C
9D0058E0  01231825   OR V1, T1, V1
9D0051B8  00092402   SRL A0, T1, 16
9D0051BC  00A3001B   DIVU A1, V1
9D0051C0  006001F4   TEQ V1, ZERO
9D0051C4  00005010   MFHI T2, 0
9D0051C8  00003012   MFLO A2, 0
9D0051CC  70C73002   MUL A2, A2, A3
9D0051D0  000A5400   SLL T2, T2, 16
9D0051D4  01442025   OR A0, T2, A0
9D0051D8  0086502B   SLTU T2, A0, A2
9D0051DC  00A3001B   DIVU A1, V1
9D0051E0  006001F4   TEQ V1, ZERO
9D0051E4  51400009   BEQL T2, ZERO, 0x9D00520C
9D0051E8  00862023   SUBU A0, A0, A2
9D0051EC  00882021   ADDU A0, A0, T0
9D0051F0  0088282B   SLTU A1, A0, T0
9D0051F4  54A00005   BNEL A1, ZERO, 0x9D00520C
9D0051F8  00862023   SUBU A0, A0, A2
9D0051FC  0086502B   SLTU T2, A0, A2
9D005200  00882821   ADDU A1, A0, T0
9D005204  00AA200B   MOVN A0, A1, T2
9D005208  00862023   SUBU A0, A0, A2
9D00520C  3126FFFF   ANDI A2, T1, -1
9D005210  0083001B   DIVU A0, V1
9D005214  006001F4   TEQ V1, ZERO
9D005218  00004810   MFHI T1, 0
9D00521C  00002812   MFLO A1, 0
9D005220  70A72802   MUL A1, A1, A3
9D005224  00094C00   SLL T1, T1, 16
9D005228  01264825   OR T1, T1, A2
9D00522C  0125302B   SLTU A2, T1, A1
9D005230  0083001B   DIVU A0, V1
9D005234  006001F4   TEQ V1, ZERO
9D005238  50C00009   BEQL A2, ZERO, 0x9D005260
9D00523C  01254823   SUBU T1, T1, A1
9D005240  01284821   ADDU T1, T1, T0
9D005244  0128182B   SLTU V1, T1, T0
9D005248  54600005   BNEL V1, ZERO, 0x9D005260
9D00524C  01254823   SUBU T1, T1, A1
9D005250  0125182B   SLTU V1, T1, A1
9D005254  01284021   ADDU T0, T1, T0
9D005258  0103480B   MOVN T1, T0, V1
9D00525C  01254823   SUBU T1, T1, A1
9D00561C  00023402   SRL A2, V0, 16
9D005620  0087001B   DIVU A0, A3
9D005624  00E001F4   TEQ A3, ZERO
9D005628  00006810   MFHI T5, 0
9D00562C  00006012   MFLO T4, 0
9D005630  00004812   MFLO T1, 0
9D005634  718B5002   MUL T2, T4, T3
9D005638  000D6C00   SLL T5, T5, 16
9D00563C  01A63025   OR A2, T5, A2
9D005640  00CA682B   SLTU T5, A2, T2
9D005644  0087001B   DIVU A0, A3
9D005648  00E001F4   TEQ A3, ZERO
9D00564C  11A00009   BEQ T5, ZERO, 0x9D005674
9D005650  00CA2823   SUBU A1, A2, T2
9D005654  00C83021   ADDU A2, A2, T0
9D005658  00C8202B   SLTU A0, A2, T0
9D00565C  14800004   BNE A0, ZERO, 0x9D005670
9D005660  2589FFFF   ADDIU T1, T4, -1
9D005664  00CA202B   SLTU A0, A2, T2
9D005668  548000A6   BNEL A0, ZERO, 0x9D005904
9D00566C  2589FFFE   ADDIU T1, T4, -2
9D005670  00CA2823   SUBU A1, A2, T2
9D005674  3042FFFF   ANDI V0, V0, -1
9D005678  00A7001B   DIVU A1, A3
9D00567C  00E001F4   TEQ A3, ZERO
9D005680  00005010   MFHI T2, 0
9D005684  00003012   MFLO A2, 0
9D005688  00002012   MFLO A0, 0
9D00568C  70CB5802   MUL T3, A2, T3
9D005690  000A5400   SLL T2, T2, 16
9D005694  01421025   OR V0, T2, V0
9D005698  004B502B   SLTU T2, V0, T3
9D00569C  00A7001B   DIVU A1, A3
9D0056A0  00E001F4   TEQ A3, ZERO
9D0056A4  51400009   BEQL T2, ZERO, 0x9D0056CC
9D0056A8  00091400   SLL V0, T1, 16
9D0056AC  00481021   ADDU V0, V0, T0
9D0056B0  0048402B   SLTU T0, V0, T0
9D0056B4  15000004   BNE T0, ZERO, 0x9D0056C8
9D0056B8  24C4FFFF   ADDIU A0, A2, -1
9D0056BC  004B582B   SLTU T3, V0, T3
9D0056C0  24C6FFFE   ADDIU A2, A2, -2
9D0056C4  00CB200B   MOVN A0, A2, T3
9D0056C8  00091400   SLL V0, T1, 16
9D0056CC  03E00008   JR RA
9D0056D0  00821025   OR V0, A0, V0
9D005904  0B40159C   J 0x9D005670
9D005908  00C83021   ADDU A2, A2, T0
9D00513C  00491006   SRLV V0, T1, V0
9D005260  00491006   SRLV V0, T1, V0
9D005140  03E00008   JR RA
9D005144  00001821   ADDU V1, ZERO, ZERO
9D005264  03E00008   JR RA
9D005268  00001821   ADDU V1, ZERO, ZERO
9D005148  00A7102B   SLTU V0, A1, A3
9D00514C  14400047   BNE V0, ZERO, 0x9D00526C
9D005150  70EA5020   CLZ T2, A3
9D0055BC  00A7102B   SLTU V0, A1, A3
9D0055C0  14400044   BNE V0, ZERO, 0x9D0056D4
9D0055C4  70E84020   CLZ T0, A3
9D0056D4  00001821   ADDU V1, ZERO, ZERO
9D0056D8  03E00008   JR RA
9D0056DC  00001021   ADDU V0, ZERO, ZERO
9D00526C  00801021   ADDU V0, A0, ZERO
9D005270  03E00008   JR RA
9D005274  00A01821   ADDU V1, A1, ZERO
9D005154  15400048   BNE T2, ZERO, 0x9D005278
9D005158  240B0020   ADDIU T3, ZERO, 32
9D0055C8  55000045   BNEL T0, ZERO, 0x9D0056E0
9D0055CC  24020020   ADDIU V0, ZERO, 32
9D00515C  00E5102B   SLTU V0, A3, A1
9D005160  14400005   BNE V0, ZERO, 0x9D005178
9D005164  00861023   SUBU V0, A0, A2
9D005168  0086402B   SLTU T0, A0, A2
9D00516C  15000089   BNE T0, ZERO, 0x9D005394
9D005170  00801021   ADDU V0, A0, ZERO
9D0055D0  00E5282B   SLTU A1, A3, A1
9D0055D4  14A000C8   BNE A1, ZERO, 0x9D0058F8
9D0055D8  0086302B   SLTU A2, A0, A2
9D0055DC  38C20001   XORI V0, A2, 1
9D0055E0  03E00008   JR RA
9D0055E4  00001821   ADDU V1, ZERO, ZERO
9D0058F8  00001821   ADDU V1, ZERO, ZERO
9D005174  00861023   SUBU V0, A0, A2
9D005178  00A72823   SUBU A1, A1, A3
9D00517C  0082202B   SLTU A0, A0, V0
9D005180  03E00008   JR RA
9D005184  00A41823   SUBU V1, A1, A0
9D005278  016A5823   SUBU T3, T3, T2
9D0056E0  00481023   SUBU V0, V0, T0
9D00527C  01473804   SLLV A3, A3, T2
9D005280  01661006   SRLV V0, A2, T3
9D005284  00473825   OR A3, V0, A3
9D0056E4  01073804   SLLV A3, A3, T0
9D0056E8  00461806   SRLV V1, A2, V0
9D0056EC  00673825   OR A3, V1, A3
9D0052B4  01463004   SLLV A2, A2, T2
9D005288  01656806   SRLV T5, A1, T3
9D0056F0  00455006   SRLV T2, A1, V0
9D0052A4  01452804   SLLV A1, A1, T2
9D0052A8  01641006   SRLV V0, A0, T3
9D0052AC  00451025   OR V0, V0, A1
9D00570C  01052804   SLLV A1, A1, T0
9D005710  00441006   SRLV V0, A0, V0
9D005714  00452825   OR A1, V0, A1
9D00528C  00074C02   SRL T1, A3, 16
9D005290  01A9001B   DIVU T5, T1
9D005294  012001F4   TEQ T1, ZERO
9D005298  00006010   MFHI T4, 0
9D00529C  00001812   MFLO V1, 0
9D0052A0  30EEFFFF   ANDI T6, A3, -1
9D0052B0  00022C02   SRL A1, V0, 16
9D0052B8  00004012   MFLO T0, 0
9D0052BC  706E7802   MUL T7, V1, T6
9D0052C0  000C6400   SLL T4, T4, 16
9D0052C4  01856025   OR T4, T4, A1
9D0052C8  018F282B   SLTU A1, T4, T7
9D0052CC  01A9001B   DIVU T5, T1
9D0052D0  012001F4   TEQ T1, ZERO
9D0052D4  10A0000A   BEQ A1, ZERO, 0x9D005300
9D0052D8  01442004   SLLV A0, A0, T2
9D0052DC  01876021   ADDU T4, T4, A3
9D0052E0  0187282B   SLTU A1, T4, A3
9D0052E4  14A00006   BNE A1, ZERO, 0x9D005300
9D0052E8  2468FFFF   ADDIU T0, V1, -1
9D0052EC  018F282B   SLTU A1, T4, T7
9D0052F0  50A00004   BEQL A1, ZERO, 0x9D005304
9D0052F4  018F6023   SUBU T4, T4, T7
9D0052F8  2468FFFE   ADDIU T0, V1, -2
9D0052FC  01876021   ADDU T4, T4, A3
9D005300  018F6023   SUBU T4, T4, T7
9D005304  3042FFFF   ANDI V0, V0, -1
9D005308  0189001B   DIVU T4, T1
9D00530C  012001F4   TEQ T1, ZERO
9D005310  00002810   MFHI A1, 0
9D005314  00001812   MFLO V1, 0
9D005318  00006812   MFLO T5, 0
9D00531C  706E7002   MUL T6, V1, T6
9D005320  00052C00   SLL A1, A1, 16
9D005324  00A21025   OR V0, A1, V0
9D005328  004E282B   SLTU A1, V0, T6
9D00532C  0189001B   DIVU T4, T1
9D005330  012001F4   TEQ T1, ZERO
9D005334  50A00006   BEQL A1, ZERO, 0x9D005350
9D005338  00084400   SLL T0, T0, 16
9D00533C  00471021   ADDU V0, V0, A3
9D005340  0047282B   SLTU A1, V0, A3
9D005344  10A0004C   BEQ A1, ZERO, 0x9D005478
9D005348  246DFFFF   ADDIU T5, V1, -1
9D00534C  00084400   SLL T0, T0, 16
9D005350  01A84025   OR T0, T5, T0
9D005354  004E1023   SUBU V0, V0, T6
9D005478  004E282B   SLTU A1, V0, T6
9D00547C  50A0FFB4   BEQL A1, ZERO, 0x9D005350
9D005480  00084400   SLL T0, T0, 16
9D005484  246DFFFE   ADDIU T5, V1, -2
9D005488  0B4014D3   J 0x9D00534C
9D00548C  00471021   ADDU V0, V0, A3
9D0056F4  00071C02   SRL V1, A3, 16
9D0056F8  0143001B   DIVU T2, V1
9D0056FC  006001F4   TEQ V1, ZERO
9D005700  00004810   MFHI T1, 0
9D005704  00006812   MFLO T5, 0
9D005708  30EBFFFF   ANDI T3, A3, -1
9D005718  00057402   SRL T6, A1, 16
9D00571C  00001012   MFLO V0, 0
9D005720  71AB6002   MUL T4, T5, T3
9D005724  00094C00   SLL T1, T1, 16
9D005728  012E4825   OR T1, T1, T6
9D00572C  012C702B   SLTU T6, T1, T4
9D005730  0143001B   DIVU T2, V1
9D005734  006001F4   TEQ V1, ZERO
9D005738  11C0000A   BEQ T6, ZERO, 0x9D005764
9D00573C  01063004   SLLV A2, A2, T0
9D005740  01274821   ADDU T1, T1, A3
9D005744  0127502B   SLTU T2, T1, A3
9D005748  15400006   BNE T2, ZERO, 0x9D005764
9D00574C  25A2FFFF   ADDIU V0, T5, -1
9D005750  012C502B   SLTU T2, T1, T4
9D005754  51400004   BEQL T2, ZERO, 0x9D005768
9D005758  012C4823   SUBU T1, T1, T4
9D00575C  25A2FFFE   ADDIU V0, T5, -2
9D005760  01274821   ADDU T1, T1, A3
9D005764  012C4823   SUBU T1, T1, T4
9D005768  30A5FFFF   ANDI A1, A1, -1
9D00576C  0123001B   DIVU T1, V1
9D005770  006001F4   TEQ V1, ZERO
9D005774  00006810   MFHI T5, 0
9D005778  00006012   MFLO T4, 0
9D00577C  00005012   MFLO T2, 0
9D005780  718B5802   MUL T3, T4, T3
9D005784  000D6C00   SLL T5, T5, 16
9D005788  01A52825   OR A1, T5, A1
9D00578C  00AB682B   SLTU T5, A1, T3
9D005790  0123001B   DIVU T1, V1
9D005794  006001F4   TEQ V1, ZERO
9D005798  51A0000B   BEQL T5, ZERO, 0x9D0057C8
9D00579C  00021400   SLL V0, V0, 16
9D0057A0  00A72821   ADDU A1, A1, A3
9D0057A4  00A7182B   SLTU V1, A1, A3
9D0057A8  14600006   BNE V1, ZERO, 0x9D0057C4
9D0057AC  258AFFFF   ADDIU T2, T4, -1
9D0057B0  00AB182B   SLTU V1, A1, T3
9D0057B4  50600004   BEQL V1, ZERO, 0x9D0057C8
9D0057B8  00021400   SLL V0, V0, 16
9D0057BC  258AFFFE   ADDIU T2, T4, -2
9D0057C0  00A72821   ADDU A1, A1, A3
9D0057C4  00021400   SLL V0, V0, 16
9D0057C8  01421025   OR V0, T2, V0
9D0057CC  00AB2823   SUBU A1, A1, T3
9D005358  01060019   MULTU 0, T0, A2
9D00535C  00004810   MFHI T1, 0
9D005374  00003012   MFLO A2, 0
9D0057D0  00460019   MULTU 0, V0, A2
9D0057D4  00003810   MFHI A3, 0
9D005360  0049182B   SLTU V1, V0, T1
9D005364  1460003E   BNE V1, ZERO, 0x9D005460
9D005368  00004012   MFLO T0, 0
9D00536C  1049004B   BEQ V0, T1, 0x9D00549C
9D005370  00491823   SUBU V1, V0, T1
9D00549C  0088182B   SLTU V1, A0, T0
9D0054A0  5460FFF0   BNEL V1, ZERO, 0x9D005464
9D0054A4  01063023   SUBU A2, T0, A2
9D0054A8  00003012   MFLO A2, 0
9D0054AC  0B4014DE   J 0x9D005378
9D0054B0  00001821   ADDU V1, ZERO, ZERO
9D0057D8  00A7182B   SLTU V1, A1, A3
9D0057DC  14600044   BNE V1, ZERO, 0x9D0058F0
9D0057E0  00003012   MFLO A2, 0
9D0057E4  10A7003F   BEQ A1, A3, 0x9D0058E4
9D0057E8  01042004   SLLV A0, A0, T0
9D0058E4  0086302B   SLTU A2, A0, A2
9D0058E8  10C0FFC0   BEQ A2, ZERO, 0x9D0057EC
9D0058EC  00000000   NOP
9D0057EC  03E00008   JR RA
9D0057F0  00001821   ADDU V1, ZERO, ZERO
9D0058F0  0B4015FB   J 0x9D0057EC
9D0058F4  2442FFFF   ADDIU V0, V0, -1
9D005460  01063023   SUBU A2, T0, A2
9D005464  01271823   SUBU V1, T1, A3
9D005468  0106402B   SLTU T0, T0, A2
9D00546C  00681823   SUBU V1, V1, T0
9D005470  0B4014DE   J 0x9D005378
9D005474  00431823   SUBU V1, V0, V1
9D005378  00863023   SUBU A2, A0, A2
9D00537C  0086202B   SLTU A0, A0, A2
9D005380  00641823   SUBU V1, V1, A0
9D005384  01631004   SLLV V0, V1, T3
9D005388  01463006   SRLV A2, A2, T2
9D00538C  00461025   OR V0, V0, A2
9D005390  01431806   SRLV V1, V1, T2
9D005394  03E00008   JR RA
9D005398  00000000   NOP
9D0058FC  03E00008   JR RA
9D005900  24020001   ADDIU V0, ZERO, 1
---  /Volumes/home/c11067/xc32/build/xc32-XC32_v1_40_branch/src48x/gcc/libgcc/floatunsisf.c  ------------
9D0070F4  27BDFFE8   ADDIU SP, SP, -24
9D0070F8  AFBF0014   SW RA, 20(SP)
9D0070FC  04800006   BLTZ A0, 0x9D007118
9D007100  00801021   ADDU V0, A0, ZERO
9D007118  00042042   SRL A0, A0, 1
9D00711C  30420001   ANDI V0, V0, 1
9D007120  0F401BF9   JAL sitofp
9D007124  00822025   OR A0, A0, V0
9D007128  00402021   ADDU A0, V0, ZERO
9D00712C  0F401645   JAL fpadd
9D007130  00402821   ADDU A1, V0, ZERO
9D007104  0F401BF9   JAL sitofp
9D007108  00000000   NOP
9D00710C  8FBF0014   LW RA, 20(SP)
9D007110  03E00008   JR RA
9D007114  27BD0018   ADDIU SP, SP, 24
9D007134  8FBF0014   LW RA, 20(SP)
9D007138  03E00008   JR RA
9D00713C  27BD0018   ADDIU SP, SP, 24
